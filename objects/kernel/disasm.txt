
a20.o:     file format elf32-i386


Disassembly of section .text:

00000000 <enable_A20>:
   0:	66 b8 01 24          	mov    $0x2401,%ax
   4:	cd 15                	int    $0x15
   6:	c3                   	ret    

atoi.o:     file format elf32-i386


Disassembly of section .text:

00000000 <atoi>:
#include <lib/string.h>

int atoi(const char* str){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp

	return (int) strtol(str, 0, 10);
   6:	83 ec 04             	sub    $0x4,%esp
   9:	6a 0a                	push   $0xa
   b:	6a 00                	push   $0x0
   d:	ff 75 08             	pushl  0x8(%ebp)
  10:	e8 fc ff ff ff       	call   11 <atoi+0x11>
  15:	83 c4 10             	add    $0x10,%esp
  18:	c9                   	leave  
  19:	c3                   	ret    

clearScreen.o:     file format elf32-i386


Disassembly of section .text:

00000000 <clearScreen>:
#include <lib/stdio.h>
#include <monitor/monitor.h>

void clearScreen(){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	monitor_clear();
   6:	e8 fc ff ff ff       	call   7 <clearScreen+0x7>
   b:	90                   	nop
   c:	c9                   	leave  
   d:	c3                   	ret    

cpu.o:     file format elf32-i386


Disassembly of section .text:

00000000 <cpuid>:
#include <hal/idt.h>

static void cpuid(int code, uint32_t* a, uint32_t* b, uint32_t* c, uint32_t* d);

static inline void cpuid(int code, uint32_t* a, uint32_t* b, uint32_t* c, uint32_t* d)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	56                   	push   %esi
   4:	53                   	push   %ebx
    asm volatile ( "cpuid" : "=a"(*a),"=b"(*b),"=c"(*c),"=d"(*d): "0"(code));
   5:	8b 45 08             	mov    0x8(%ebp),%eax
   8:	0f a2                	cpuid  
   a:	8b 75 0c             	mov    0xc(%ebp),%esi
   d:	89 06                	mov    %eax,(%esi)
   f:	8b 45 10             	mov    0x10(%ebp),%eax
  12:	89 18                	mov    %ebx,(%eax)
  14:	8b 45 14             	mov    0x14(%ebp),%eax
  17:	89 08                	mov    %ecx,(%eax)
  19:	8b 45 18             	mov    0x18(%ebp),%eax
  1c:	89 10                	mov    %edx,(%eax)
}
  1e:	90                   	nop
  1f:	5b                   	pop    %ebx
  20:	5e                   	pop    %esi
  21:	5d                   	pop    %ebp
  22:	c3                   	ret    

00000023 <i86_cpu_initialize>:

int i86_cpu_initialize(){
  23:	55                   	push   %ebp
  24:	89 e5                	mov    %esp,%ebp
  26:	83 ec 08             	sub    $0x8,%esp
	i86_gdt_initialize();
  29:	e8 fc ff ff ff       	call   2a <i86_cpu_initialize+0x7>
	i86_idt_initialize(0x8);
  2e:	83 ec 0c             	sub    $0xc,%esp
  31:	6a 08                	push   $0x8
  33:	e8 fc ff ff ff       	call   34 <i86_cpu_initialize+0x11>
  38:	83 c4 10             	add    $0x10,%esp

	return 0;
  3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40:	c9                   	leave  
  41:	c3                   	ret    

00000042 <i86_cpu_shutdown>:

void i86_cpu_shutdown(){
  42:	55                   	push   %ebp
  43:	89 e5                	mov    %esp,%ebp
	// Do nothing yet.
}
  45:	90                   	nop
  46:	5d                   	pop    %ebp
  47:	c3                   	ret    

00000048 <i86_cpu_get_vendor>:

const char* i86_cpu_get_vendor(){
  48:	55                   	push   %ebp
  49:	89 e5                	mov    %esp,%ebp
  4b:	83 ec 20             	sub    $0x20,%esp
	union{
		uint32_t reg;
		char byte[4]; 
	}edx;

	cpuid(0, &(eax.reg), &(ebx.reg), &(ecx.reg), &(edx.reg));
  4e:	8d 45 ec             	lea    -0x14(%ebp),%eax
  51:	50                   	push   %eax
  52:	8d 45 f0             	lea    -0x10(%ebp),%eax
  55:	50                   	push   %eax
  56:	8d 45 f4             	lea    -0xc(%ebp),%eax
  59:	50                   	push   %eax
  5a:	8d 45 f8             	lea    -0x8(%ebp),%eax
  5d:	50                   	push   %eax
  5e:	6a 00                	push   $0x0
  60:	e8 9b ff ff ff       	call   0 <cpuid>
  65:	83 c4 14             	add    $0x14,%esp

	for(int i = 0; i < 4; ++i)
  68:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  6f:	eb 48                	jmp    b9 <i86_cpu_get_vendor+0x71>
	{
		vendor[i] = ebx.byte[i];
  71:	8d 55 f4             	lea    -0xc(%ebp),%edx
  74:	8b 45 fc             	mov    -0x4(%ebp),%eax
  77:	01 d0                	add    %edx,%eax
  79:	0f b6 00             	movzbl (%eax),%eax
  7c:	8b 55 fc             	mov    -0x4(%ebp),%edx
  7f:	81 c2 00 00 00 00    	add    $0x0,%edx
  85:	88 02                	mov    %al,(%edx)
		vendor[i+4] = edx.byte[i];
  87:	8b 45 fc             	mov    -0x4(%ebp),%eax
  8a:	8d 50 04             	lea    0x4(%eax),%edx
  8d:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  90:	8b 45 fc             	mov    -0x4(%ebp),%eax
  93:	01 c8                	add    %ecx,%eax
  95:	0f b6 00             	movzbl (%eax),%eax
  98:	88 82 00 00 00 00    	mov    %al,0x0(%edx)
		vendor[i+8] = ecx.byte[i];
  9e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  a1:	8d 50 08             	lea    0x8(%eax),%edx
  a4:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  aa:	01 c8                	add    %ecx,%eax
  ac:	0f b6 00             	movzbl (%eax),%eax
  af:	88 82 00 00 00 00    	mov    %al,0x0(%edx)
		char byte[4]; 
	}edx;

	cpuid(0, &(eax.reg), &(ebx.reg), &(ecx.reg), &(edx.reg));

	for(int i = 0; i < 4; ++i)
  b5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  b9:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
  bd:	7e b2                	jle    71 <i86_cpu_get_vendor+0x29>
		vendor[i] = ebx.byte[i];
		vendor[i+4] = edx.byte[i];
		vendor[i+8] = ecx.byte[i];
	}

	return (const char*) vendor;
  bf:	b8 00 00 00 00       	mov    $0x0,%eax

  c4:	c9                   	leave  
  c5:	c3                   	ret    

dma.o:     file format elf32-i386


Disassembly of section .text:

00000000 <dma_set_mode>:
#include <hal/dma.h>

void dma_set_mode(uint8_t channel, uint8_t mode){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
   6:	8b 55 08             	mov    0x8(%ebp),%edx
   9:	8b 45 0c             	mov    0xc(%ebp),%eax
   c:	88 55 e4             	mov    %dl,-0x1c(%ebp)
   f:	88 45 e0             	mov    %al,-0x20(%ebp)

	int dma = (channel < 4) ? 0 : 1;
  12:	80 7d e4 03          	cmpb   $0x3,-0x1c(%ebp)
  16:	0f 97 c0             	seta   %al
  19:	0f b6 c0             	movzbl %al,%eax
  1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int chan = (dma == 0) ? channel : channel - 4;
  1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  23:	75 06                	jne    2b <dma_set_mode+0x2b>
  25:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  29:	eb 07                	jmp    32 <dma_set_mode+0x32>
  2b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  2f:	83 e8 04             	sub    $0x4,%eax
  32:	89 45 f0             	mov    %eax,-0x10(%ebp)

	dma_mask_channel(channel);
  35:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  39:	83 ec 0c             	sub    $0xc,%esp
  3c:	50                   	push   %eax
  3d:	e8 fc ff ff ff       	call   3e <dma_set_mode+0x3e>
  42:	83 c4 10             	add    $0x10,%esp
	outportb((channel < 4) ? DMA0_MODE_REG : DMA1_MODE_REG, chan | mode);
  45:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  49:	0b 45 f0             	or     -0x10(%ebp),%eax
  4c:	80 7d e4 03          	cmpb   $0x3,-0x1c(%ebp)
  50:	77 07                	ja     59 <dma_set_mode+0x59>
  52:	ba 0b 00 00 00       	mov    $0xb,%edx
  57:	eb 05                	jmp    5e <dma_set_mode+0x5e>
  59:	ba d6 00 00 00       	mov    $0xd6,%edx
  5e:	83 ec 08             	sub    $0x8,%esp
  61:	50                   	push   %eax
  62:	52                   	push   %edx
  63:	e8 fc ff ff ff       	call   64 <dma_set_mode+0x64>
  68:	83 c4 10             	add    $0x10,%esp
	dma_unmask_all(dma);	
  6b:	83 ec 0c             	sub    $0xc,%esp
  6e:	ff 75 f4             	pushl  -0xc(%ebp)
  71:	e8 fc ff ff ff       	call   72 <dma_set_mode+0x72>
  76:	83 c4 10             	add    $0x10,%esp
}
  79:	90                   	nop
  7a:	c9                   	leave  
  7b:	c3                   	ret    

0000007c <dma_set_read>:

void dma_set_read(uint8_t channel){
  7c:	55                   	push   %ebp
  7d:	89 e5                	mov    %esp,%ebp
  7f:	83 ec 18             	sub    $0x18,%esp
  82:	8b 45 08             	mov    0x8(%ebp),%eax
  85:	88 45 f4             	mov    %al,-0xc(%ebp)

	dma_set_mode (channel,	DMA_MODE_READ_TRANSFER | DMA_MODE_TRANSFER_SINGLE);
  88:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  8c:	83 ec 08             	sub    $0x8,%esp
  8f:	6a 44                	push   $0x44
  91:	50                   	push   %eax
  92:	e8 fc ff ff ff       	call   93 <dma_set_read+0x17>
  97:	83 c4 10             	add    $0x10,%esp
}
  9a:	90                   	nop
  9b:	c9                   	leave  
  9c:	c3                   	ret    

0000009d <dma_set_write>:

void dma_set_write(uint8_t channel){
  9d:	55                   	push   %ebp
  9e:	89 e5                	mov    %esp,%ebp
  a0:	83 ec 18             	sub    $0x18,%esp
  a3:	8b 45 08             	mov    0x8(%ebp),%eax
  a6:	88 45 f4             	mov    %al,-0xc(%ebp)

	dma_set_mode (channel,
  a9:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  ad:	83 ec 08             	sub    $0x8,%esp
  b0:	6a 48                	push   $0x48
  b2:	50                   	push   %eax
  b3:	e8 fc ff ff ff       	call   b4 <dma_set_write+0x17>
  b8:	83 c4 10             	add    $0x10,%esp
		DMA_MODE_WRITE_TRANSFER | DMA_MODE_TRANSFER_SINGLE);
}
  bb:	90                   	nop
  bc:	c9                   	leave  
  bd:	c3                   	ret    

000000be <dma_set_address>:

void dma_set_address(uint8_t channel, uint8_t low, uint8_t high){
  be:	55                   	push   %ebp
  bf:	89 e5                	mov    %esp,%ebp
  c1:	83 ec 28             	sub    $0x28,%esp
  c4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  c7:	8b 55 0c             	mov    0xc(%ebp),%edx
  ca:	8b 45 10             	mov    0x10(%ebp),%eax
  cd:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  d0:	88 55 e0             	mov    %dl,-0x20(%ebp)
  d3:	88 45 dc             	mov    %al,-0x24(%ebp)

	if(channel > 8)
  d6:	80 7d e4 08          	cmpb   $0x8,-0x1c(%ebp)
  da:	0f 87 83 00 00 00    	ja     163 <dma_set_address+0xa5>
		return;

	uint16_t port = 0;
  e0:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)

	switch(channel){
  e6:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  ea:	83 f8 07             	cmp    $0x7,%eax
  ed:	77 77                	ja     166 <dma_set_address+0xa8>
  ef:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
  f6:	ff e0                	jmp    *%eax

		case 0:
			port = DMA0_CH0_ADDR_REG;
  f8:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
			break;
  fe:	eb 37                	jmp    137 <dma_set_address+0x79>
		case 1:
			port = DMA0_CH1_ADDR_REG;
 100:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
			break;
 106:	eb 2f                	jmp    137 <dma_set_address+0x79>
		case 2:
			port = DMA0_CH2_ADDR_REG;
 108:	66 c7 45 f6 04 00    	movw   $0x4,-0xa(%ebp)
			break;
 10e:	eb 27                	jmp    137 <dma_set_address+0x79>
		case 3:
			port = DMA0_CH3_ADDR_REG;
 110:	66 c7 45 f6 06 00    	movw   $0x6,-0xa(%ebp)
			break;
 116:	eb 1f                	jmp    137 <dma_set_address+0x79>
		case 4:
			port = DMA1_CH4_ADDR_REG;
 118:	66 c7 45 f6 c0 00    	movw   $0xc0,-0xa(%ebp)
			break;
 11e:	eb 17                	jmp    137 <dma_set_address+0x79>
		case 5:
			port = DMA1_CH5_ADDR_REG;
 120:	66 c7 45 f6 c4 00    	movw   $0xc4,-0xa(%ebp)
			break;
 126:	eb 0f                	jmp    137 <dma_set_address+0x79>
		case 6:
			port = DMA1_CH6_ADDR_REG;
 128:	66 c7 45 f6 c8 00    	movw   $0xc8,-0xa(%ebp)
			break;
 12e:	eb 07                	jmp    137 <dma_set_address+0x79>
		case 7:
			port = DMA1_CH7_ADDR_REG;
 130:	66 c7 45 f6 cc 00    	movw   $0xcc,-0xa(%ebp)
			break;
 136:	90                   	nop
		default:
			return; // Should never happen
	}

	outportb(port, low);
 137:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
 13b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 13f:	83 ec 08             	sub    $0x8,%esp
 142:	52                   	push   %edx
 143:	50                   	push   %eax
 144:	e8 fc ff ff ff       	call   145 <dma_set_address+0x87>
 149:	83 c4 10             	add    $0x10,%esp
	outportb(port, high);
 14c:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
 150:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 154:	83 ec 08             	sub    $0x8,%esp
 157:	52                   	push   %edx
 158:	50                   	push   %eax
 159:	e8 fc ff ff ff       	call   15a <dma_set_address+0x9c>
 15e:	83 c4 10             	add    $0x10,%esp
 161:	eb 04                	jmp    167 <dma_set_address+0xa9>
}

void dma_set_address(uint8_t channel, uint8_t low, uint8_t high){

	if(channel > 8)
		return;
 163:	90                   	nop
 164:	eb 01                	jmp    167 <dma_set_address+0xa9>
			break;
		case 7:
			port = DMA1_CH7_ADDR_REG;
			break;
		default:
			return; // Should never happen
 166:	90                   	nop
	}

	outportb(port, low);
	outportb(port, high);
}
 167:	c9                   	leave  
 168:	c3                   	ret    

00000169 <dma_set_count>:

void dma_set_count(uint8_t channel, uint8_t low, uint8_t high){
 169:	55                   	push   %ebp
 16a:	89 e5                	mov    %esp,%ebp
 16c:	83 ec 28             	sub    $0x28,%esp
 16f:	8b 4d 08             	mov    0x8(%ebp),%ecx
 172:	8b 55 0c             	mov    0xc(%ebp),%edx
 175:	8b 45 10             	mov    0x10(%ebp),%eax
 178:	88 4d e4             	mov    %cl,-0x1c(%ebp)
 17b:	88 55 e0             	mov    %dl,-0x20(%ebp)
 17e:	88 45 dc             	mov    %al,-0x24(%ebp)

	if(channel > 8)
 181:	80 7d e4 08          	cmpb   $0x8,-0x1c(%ebp)
 185:	0f 87 83 00 00 00    	ja     20e <dma_set_count+0xa5>
		return;

	uint16_t port = 0;
 18b:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)

	switch(channel){
 191:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 195:	83 f8 07             	cmp    $0x7,%eax
 198:	77 77                	ja     211 <dma_set_count+0xa8>
 19a:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
 1a1:	ff e0                	jmp    *%eax

		case 0:
			port = DMA0_CH0_COUNT_REG;
 1a3:	66 c7 45 f6 01 00    	movw   $0x1,-0xa(%ebp)
			break;
 1a9:	eb 37                	jmp    1e2 <dma_set_count+0x79>
		case 1:
			port = DMA0_CH1_COUNT_REG;
 1ab:	66 c7 45 f6 03 00    	movw   $0x3,-0xa(%ebp)
			break;
 1b1:	eb 2f                	jmp    1e2 <dma_set_count+0x79>
		case 2:
			port = DMA0_CH2_COUNT_REG;
 1b3:	66 c7 45 f6 05 00    	movw   $0x5,-0xa(%ebp)
			break;
 1b9:	eb 27                	jmp    1e2 <dma_set_count+0x79>
		case 3:
			port = DMA0_CH3_COUNT_REG;
 1bb:	66 c7 45 f6 07 00    	movw   $0x7,-0xa(%ebp)
			break;
 1c1:	eb 1f                	jmp    1e2 <dma_set_count+0x79>
		case 4:
			port = DMA1_CH4_COUNT_REG;
 1c3:	66 c7 45 f6 c2 00    	movw   $0xc2,-0xa(%ebp)
			break;
 1c9:	eb 17                	jmp    1e2 <dma_set_count+0x79>
		case 5:
			port = DMA1_CH5_COUNT_REG;
 1cb:	66 c7 45 f6 c6 00    	movw   $0xc6,-0xa(%ebp)
			break;
 1d1:	eb 0f                	jmp    1e2 <dma_set_count+0x79>
		case 6:
			port = DMA1_CH6_COUNT_REG;
 1d3:	66 c7 45 f6 ca 00    	movw   $0xca,-0xa(%ebp)
			break;
 1d9:	eb 07                	jmp    1e2 <dma_set_count+0x79>
		case 7:
			port = DMA1_CH7_COUNT_REG;
 1db:	66 c7 45 f6 ce 00    	movw   $0xce,-0xa(%ebp)
			break;
 1e1:	90                   	nop
		default:
			return; // Should never happen
	}

	outportb(port, low);
 1e2:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
 1e6:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 1ea:	83 ec 08             	sub    $0x8,%esp
 1ed:	52                   	push   %edx
 1ee:	50                   	push   %eax
 1ef:	e8 fc ff ff ff       	call   1f0 <dma_set_count+0x87>
 1f4:	83 c4 10             	add    $0x10,%esp
	outportb(port, high);	
 1f7:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
 1fb:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 1ff:	83 ec 08             	sub    $0x8,%esp
 202:	52                   	push   %edx
 203:	50                   	push   %eax
 204:	e8 fc ff ff ff       	call   205 <dma_set_count+0x9c>
 209:	83 c4 10             	add    $0x10,%esp
 20c:	eb 04                	jmp    212 <dma_set_count+0xa9>
}

void dma_set_count(uint8_t channel, uint8_t low, uint8_t high){

	if(channel > 8)
		return;
 20e:	90                   	nop
 20f:	eb 01                	jmp    212 <dma_set_count+0xa9>
			break;
		case 7:
			port = DMA1_CH7_COUNT_REG;
			break;
		default:
			return; // Should never happen
 211:	90                   	nop
	}

	outportb(port, low);
	outportb(port, high);	
}
 212:	c9                   	leave  
 213:	c3                   	ret    

00000214 <dma_mask_channel>:

void dma_mask_channel(uint8_t channel){
 214:	55                   	push   %ebp
 215:	89 e5                	mov    %esp,%ebp
 217:	83 ec 18             	sub    $0x18,%esp
 21a:	8b 45 08             	mov    0x8(%ebp),%eax
 21d:	88 45 f4             	mov    %al,-0xc(%ebp)

	if(channel < 5){
 220:	80 7d f4 04          	cmpb   $0x4,-0xc(%ebp)
 224:	77 22                	ja     248 <dma_mask_channel+0x34>

		outportb(DMA0_SINGLE_CHAN_MASK_REG, (1 << (channel-1)));
 226:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 22a:	83 e8 01             	sub    $0x1,%eax
 22d:	ba 01 00 00 00       	mov    $0x1,%edx
 232:	89 c1                	mov    %eax,%ecx
 234:	d3 e2                	shl    %cl,%edx
 236:	89 d0                	mov    %edx,%eax
 238:	83 ec 08             	sub    $0x8,%esp
 23b:	50                   	push   %eax
 23c:	6a 0a                	push   $0xa
 23e:	e8 fc ff ff ff       	call   23f <dma_mask_channel+0x2b>
 243:	83 c4 10             	add    $0x10,%esp
	} else {
		outportb(DMA1_SINGLE_CHAN_MASK_REG, (1 << (channel-5)));
	}
}
 246:	eb 23                	jmp    26b <dma_mask_channel+0x57>

	if(channel < 5){

		outportb(DMA0_SINGLE_CHAN_MASK_REG, (1 << (channel-1)));
	} else {
		outportb(DMA1_SINGLE_CHAN_MASK_REG, (1 << (channel-5)));
 248:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 24c:	83 e8 05             	sub    $0x5,%eax
 24f:	ba 01 00 00 00       	mov    $0x1,%edx
 254:	89 c1                	mov    %eax,%ecx
 256:	d3 e2                	shl    %cl,%edx
 258:	89 d0                	mov    %edx,%eax
 25a:	83 ec 08             	sub    $0x8,%esp
 25d:	50                   	push   %eax
 25e:	68 d4 00 00 00       	push   $0xd4
 263:	e8 fc ff ff ff       	call   264 <dma_mask_channel+0x50>
 268:	83 c4 10             	add    $0x10,%esp
	}
}
 26b:	90                   	nop
 26c:	c9                   	leave  
 26d:	c3                   	ret    

0000026e <dma_unmask_channel>:

void dma_unmask_channel(uint8_t channel){
 26e:	55                   	push   %ebp
 26f:	89 e5                	mov    %esp,%ebp
 271:	83 ec 18             	sub    $0x18,%esp
 274:	8b 45 08             	mov    0x8(%ebp),%eax
 277:	88 45 f4             	mov    %al,-0xc(%ebp)

	if(channel < 5){
 27a:	80 7d f4 04          	cmpb   $0x4,-0xc(%ebp)
 27e:	77 14                	ja     294 <dma_unmask_channel+0x26>

		outportb(DMA0_SINGLE_CHAN_MASK_REG, channel);
 280:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 284:	83 ec 08             	sub    $0x8,%esp
 287:	50                   	push   %eax
 288:	6a 0a                	push   $0xa
 28a:	e8 fc ff ff ff       	call   28b <dma_unmask_channel+0x1d>
 28f:	83 c4 10             	add    $0x10,%esp
	} else {
		outportb(DMA1_SINGLE_CHAN_MASK_REG, channel);
	}
}
 292:	eb 15                	jmp    2a9 <dma_unmask_channel+0x3b>

	if(channel < 5){

		outportb(DMA0_SINGLE_CHAN_MASK_REG, channel);
	} else {
		outportb(DMA1_SINGLE_CHAN_MASK_REG, channel);
 294:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 298:	83 ec 08             	sub    $0x8,%esp
 29b:	50                   	push   %eax
 29c:	68 d4 00 00 00       	push   $0xd4
 2a1:	e8 fc ff ff ff       	call   2a2 <dma_unmask_channel+0x34>
 2a6:	83 c4 10             	add    $0x10,%esp
	}
}
 2a9:	90                   	nop
 2aa:	c9                   	leave  
 2ab:	c3                   	ret    

000002ac <dma_reset_flipflop>:

void dma_reset_flipflop(int dma){
 2ac:	55                   	push   %ebp
 2ad:	89 e5                	mov    %esp,%ebp
 2af:	83 ec 08             	sub    $0x8,%esp

	if(dma < 2)
 2b2:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
 2b6:	7e 31                	jle    2e9 <dma_reset_flipflop+0x3d>
		return;

	if(dma == 0){
 2b8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 2bc:	75 14                	jne    2d2 <dma_reset_flipflop+0x26>

		outportb(DMA0_CLEARBYTE_FLIPFLOP_REG, 0xFF);
 2be:	83 ec 08             	sub    $0x8,%esp
 2c1:	68 ff 00 00 00       	push   $0xff
 2c6:	6a 0c                	push   $0xc
 2c8:	e8 fc ff ff ff       	call   2c9 <dma_reset_flipflop+0x1d>
 2cd:	83 c4 10             	add    $0x10,%esp
 2d0:	eb 18                	jmp    2ea <dma_reset_flipflop+0x3e>
	} else {

		outportb(DMA1_CLEARBYTE_FLIPFLOP_REG, 0xFF);
 2d2:	83 ec 08             	sub    $0x8,%esp
 2d5:	68 ff 00 00 00       	push   $0xff
 2da:	68 d8 00 00 00       	push   $0xd8
 2df:	e8 fc ff ff ff       	call   2e0 <dma_reset_flipflop+0x34>
 2e4:	83 c4 10             	add    $0x10,%esp
 2e7:	eb 01                	jmp    2ea <dma_reset_flipflop+0x3e>
}

void dma_reset_flipflop(int dma){

	if(dma < 2)
		return;
 2e9:	90                   	nop
		outportb(DMA0_CLEARBYTE_FLIPFLOP_REG, 0xFF);
	} else {

		outportb(DMA1_CLEARBYTE_FLIPFLOP_REG, 0xFF);
	}
}
 2ea:	c9                   	leave  
 2eb:	c3                   	ret    

000002ec <dma_reset>:

void dma_reset(int dma){
 2ec:	55                   	push   %ebp
 2ed:	89 e5                	mov    %esp,%ebp
 2ef:	83 ec 08             	sub    $0x8,%esp

	outportb(DMA0_TEMP_REG, 0xFF);
 2f2:	83 ec 08             	sub    $0x8,%esp
 2f5:	68 ff 00 00 00       	push   $0xff
 2fa:	6a 0d                	push   $0xd
 2fc:	e8 fc ff ff ff       	call   2fd <dma_reset+0x11>
 301:	83 c4 10             	add    $0x10,%esp
}
 304:	90                   	nop
 305:	c9                   	leave  
 306:	c3                   	ret    

00000307 <dma_set_external_page_register>:

void dma_set_external_page_register(uint8_t reg, uint8_t val){
 307:	55                   	push   %ebp
 308:	89 e5                	mov    %esp,%ebp
 30a:	83 ec 28             	sub    $0x28,%esp
 30d:	8b 55 08             	mov    0x8(%ebp),%edx
 310:	8b 45 0c             	mov    0xc(%ebp),%eax
 313:	88 55 e4             	mov    %dl,-0x1c(%ebp)
 316:	88 45 e0             	mov    %al,-0x20(%ebp)
	
	if (reg > 14)
 319:	80 7d e4 0e          	cmpb   $0xe,-0x1c(%ebp)
 31d:	77 5e                	ja     37d <dma_set_external_page_register+0x76>
		return;

	unsigned short port = 0;
 31f:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
	switch ( reg ) {
 325:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 329:	83 f8 07             	cmp    $0x7,%eax
 32c:	77 38                	ja     366 <dma_set_external_page_register+0x5f>
 32e:	8b 04 85 40 00 00 00 	mov    0x40(,%eax,4),%eax
 335:	ff e0                	jmp    *%eax

		case 1: {port = DMA_PAGE_CHAN1_ADDRBYTE2; break;}
 337:	66 c7 45 f6 83 00    	movw   $0x83,-0xa(%ebp)
 33d:	eb 27                	jmp    366 <dma_set_external_page_register+0x5f>
		case 2: {port = DMA_PAGE_CHAN2_ADDRBYTE2; break;}
 33f:	66 c7 45 f6 81 00    	movw   $0x81,-0xa(%ebp)
 345:	eb 1f                	jmp    366 <dma_set_external_page_register+0x5f>
		case 3: {port = DMA_PAGE_CHAN3_ADDRBYTE2; break;}
 347:	66 c7 45 f6 82 00    	movw   $0x82,-0xa(%ebp)
 34d:	eb 17                	jmp    366 <dma_set_external_page_register+0x5f>
		case 4: {return;}//! nothing should ever write to register 4
		case 5: {port = DMA_PAGE_CHAN5_ADDRBYTE2; break;}
 34f:	66 c7 45 f6 89 00    	movw   $0x89,-0xa(%ebp)
 355:	eb 0f                	jmp    366 <dma_set_external_page_register+0x5f>
		case 6: {port = DMA_PAGE_CHAN6_ADDRBYTE2; break;}
 357:	66 c7 45 f6 87 00    	movw   $0x87,-0xa(%ebp)
 35d:	eb 07                	jmp    366 <dma_set_external_page_register+0x5f>
		case 7: {port = DMA_PAGE_CHAN7_ADDRBYTE2; break;}
 35f:	66 c7 45 f6 88 00    	movw   $0x88,-0xa(%ebp)
 365:	90                   	nop
	}

	outportb(port, val);
 366:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
 36a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 36e:	83 ec 08             	sub    $0x8,%esp
 371:	52                   	push   %edx
 372:	50                   	push   %eax
 373:	e8 fc ff ff ff       	call   374 <dma_set_external_page_register+0x6d>
 378:	83 c4 10             	add    $0x10,%esp
 37b:	eb 04                	jmp    381 <dma_set_external_page_register+0x7a>
}

void dma_set_external_page_register(uint8_t reg, uint8_t val){
	
	if (reg > 14)
		return;
 37d:	90                   	nop
 37e:	eb 01                	jmp    381 <dma_set_external_page_register+0x7a>
	switch ( reg ) {

		case 1: {port = DMA_PAGE_CHAN1_ADDRBYTE2; break;}
		case 2: {port = DMA_PAGE_CHAN2_ADDRBYTE2; break;}
		case 3: {port = DMA_PAGE_CHAN3_ADDRBYTE2; break;}
		case 4: {return;}//! nothing should ever write to register 4
 380:	90                   	nop
		case 6: {port = DMA_PAGE_CHAN6_ADDRBYTE2; break;}
		case 7: {port = DMA_PAGE_CHAN7_ADDRBYTE2; break;}
	}

	outportb(port, val);
}
 381:	c9                   	leave  
 382:	c3                   	ret    

00000383 <dma_unmask_all>:

void dma_unmask_all(int dma){
 383:	55                   	push   %ebp
 384:	89 e5                	mov    %esp,%ebp
 386:	83 ec 08             	sub    $0x8,%esp

	outportb(DMA1_UNMASK_ALL_REG, 0xFF);
 389:	83 ec 08             	sub    $0x8,%esp
 38c:	68 ff 00 00 00       	push   $0xff
 391:	68 dc 00 00 00       	push   $0xdc
 396:	e8 fc ff ff ff       	call   397 <dma_unmask_all+0x14>
 39b:	83 c4 10             	add    $0x10,%esp
 39e:	90                   	nop
 39f:	c9                   	leave  
 3a0:	c3                   	ret    

exception.o:     file format elf32-i386


Disassembly of section .text:

00000000 <divide_by_zero_fault>:

void divide_by_zero_fault (
	unsigned int cs, 
    unsigned int eip, 
    unsigned int eflags
    ){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Divide by 0");
   6:	83 ec 0c             	sub    $0xc,%esp
   9:	68 00 00 00 00       	push   $0x0
   e:	e8 fc ff ff ff       	call   f <divide_by_zero_fault+0xf>
  13:	83 c4 10             	add    $0x10,%esp
	for(;;);
  16:	eb fe                	jmp    16 <divide_by_zero_fault+0x16>

00000018 <single_step_trap>:

void single_step_trap (
	unsigned int cs, 
	unsigned int eip, 
	unsigned int eflags
	){
  18:	55                   	push   %ebp
  19:	89 e5                	mov    %esp,%ebp
  1b:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Single step");
  1e:	83 ec 0c             	sub    $0xc,%esp
  21:	68 0c 00 00 00       	push   $0xc
  26:	e8 fc ff ff ff       	call   27 <single_step_trap+0xf>
  2b:	83 c4 10             	add    $0x10,%esp
	for(;;);
  2e:	eb fe                	jmp    2e <single_step_trap+0x16>

00000030 <nmi_trap>:

void nmi_trap (
	unsigned int cs, 
    unsigned int eip, 
    unsigned int eflags
    ){
  30:	55                   	push   %ebp
  31:	89 e5                	mov    %esp,%ebp
  33:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("NMI trap");
  36:	83 ec 0c             	sub    $0xc,%esp
  39:	68 18 00 00 00       	push   $0x18
  3e:	e8 fc ff ff ff       	call   3f <nmi_trap+0xf>
  43:	83 c4 10             	add    $0x10,%esp
	for(;;);
  46:	eb fe                	jmp    46 <nmi_trap+0x16>

00000048 <breakpoint_trap>:

void breakpoint_trap (
	unsigned int cs, 
    unsigned int eip,
    unsigned int eflags
    ){
  48:	55                   	push   %ebp
  49:	89 e5                	mov    %esp,%ebp
  4b:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Breakpoint trap");
  4e:	83 ec 0c             	sub    $0xc,%esp
  51:	68 21 00 00 00       	push   $0x21
  56:	e8 fc ff ff ff       	call   57 <breakpoint_trap+0xf>
  5b:	83 c4 10             	add    $0x10,%esp
	for(;;);
  5e:	eb fe                	jmp    5e <breakpoint_trap+0x16>

00000060 <overflow_trap>:

void overflow_trap (
	unsigned int cs, 
    unsigned int eip, 
    unsigned int eflags
    ){
  60:	55                   	push   %ebp
  61:	89 e5                	mov    %esp,%ebp
  63:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Overflow trap");
  66:	83 ec 0c             	sub    $0xc,%esp
  69:	68 31 00 00 00       	push   $0x31
  6e:	e8 fc ff ff ff       	call   6f <overflow_trap+0xf>
  73:	83 c4 10             	add    $0x10,%esp
	for(;;);
  76:	eb fe                	jmp    76 <overflow_trap+0x16>

00000078 <bounds_check_fault>:

void bounds_check_fault (
	unsigned int cs, 
    unsigned int eip, 
    unsigned int eflags
    ){
  78:	55                   	push   %ebp
  79:	89 e5                	mov    %esp,%ebp
  7b:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Bounds check fault");
  7e:	83 ec 0c             	sub    $0xc,%esp
  81:	68 3f 00 00 00       	push   $0x3f
  86:	e8 fc ff ff ff       	call   87 <bounds_check_fault+0xf>
  8b:	83 c4 10             	add    $0x10,%esp
	for(;;);
  8e:	eb fe                	jmp    8e <bounds_check_fault+0x16>

00000090 <invalid_opcode_fault>:

void invalid_opcode_fault (
	unsigned int cs, 
    unsigned int eip, 
    unsigned int eflags
    ){
  90:	55                   	push   %ebp
  91:	89 e5                	mov    %esp,%ebp
  93:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Invalid OP-code");
  96:	83 ec 0c             	sub    $0xc,%esp
  99:	68 52 00 00 00       	push   $0x52
  9e:	e8 fc ff ff ff       	call   9f <invalid_opcode_fault+0xf>
  a3:	83 c4 10             	add    $0x10,%esp
	for(;;);
  a6:	eb fe                	jmp    a6 <invalid_opcode_fault+0x16>

000000a8 <no_device_fault>:

void no_device_fault (
	unsigned int cs, 
    unsigned int eip, 
    unsigned int eflags
    ){
  a8:	55                   	push   %ebp
  a9:	89 e5                	mov    %esp,%ebp
  ab:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Device not found");
  ae:	83 ec 0c             	sub    $0xc,%esp
  b1:	68 62 00 00 00       	push   $0x62
  b6:	e8 fc ff ff ff       	call   b7 <no_device_fault+0xf>
  bb:	83 c4 10             	add    $0x10,%esp
	for(;;);
  be:	eb fe                	jmp    be <no_device_fault+0x16>

000000c0 <double_fault_abort>:
void double_fault_abort (
	unsigned int cs, 
	unsigned int err,
    unsigned int eip, 
    unsigned int eflags
    ){
  c0:	55                   	push   %ebp
  c1:	89 e5                	mov    %esp,%ebp
  c3:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Double fault");
  c6:	83 ec 0c             	sub    $0xc,%esp
  c9:	68 73 00 00 00       	push   $0x73
  ce:	e8 fc ff ff ff       	call   cf <double_fault_abort+0xf>
  d3:	83 c4 10             	add    $0x10,%esp
	for(;;);
  d6:	eb fe                	jmp    d6 <double_fault_abort+0x16>

000000d8 <invalid_tss_fault>:
void invalid_tss_fault (
	unsigned int cs, 
	unsigned int err,
    unsigned int eip, 
    unsigned int eflags
    ){
  d8:	55                   	push   %ebp
  d9:	89 e5                	mov    %esp,%ebp
  db:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Invalid TSS");
  de:	83 ec 0c             	sub    $0xc,%esp
  e1:	68 80 00 00 00       	push   $0x80
  e6:	e8 fc ff ff ff       	call   e7 <invalid_tss_fault+0xf>
  eb:	83 c4 10             	add    $0x10,%esp
	for(;;);
  ee:	eb fe                	jmp    ee <invalid_tss_fault+0x16>

000000f0 <no_segment_fault>:
void no_segment_fault (
	unsigned int cs, 
	unsigned int err,
    unsigned int eip, 
    unsigned int eflags
    ){
  f0:	55                   	push   %ebp
  f1:	89 e5                	mov    %esp,%ebp
  f3:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Invalid segment");
  f6:	83 ec 0c             	sub    $0xc,%esp
  f9:	68 8c 00 00 00       	push   $0x8c
  fe:	e8 fc ff ff ff       	call   ff <no_segment_fault+0xf>
 103:	83 c4 10             	add    $0x10,%esp
	for(;;);
 106:	eb fe                	jmp    106 <no_segment_fault+0x16>

00000108 <stack_fault>:
void stack_fault (
	unsigned int cs, 
	unsigned int err,
    unsigned int eip, 
    unsigned int eflags
    ){
 108:	55                   	push   %ebp
 109:	89 e5                	mov    %esp,%ebp
 10b:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Stack fault");
 10e:	83 ec 0c             	sub    $0xc,%esp
 111:	68 9c 00 00 00       	push   $0x9c
 116:	e8 fc ff ff ff       	call   117 <stack_fault+0xf>
 11b:	83 c4 10             	add    $0x10,%esp
	for(;;);
 11e:	eb fe                	jmp    11e <stack_fault+0x16>

00000120 <general_protection_fault>:
void general_protection_fault (
	unsigned int cs, 
	unsigned int err,
    unsigned int eip, 
    unsigned int eflags
    ){
 120:	55                   	push   %ebp
 121:	89 e5                	mov    %esp,%ebp
 123:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("General protection fault");
 126:	83 ec 0c             	sub    $0xc,%esp
 129:	68 a8 00 00 00       	push   $0xa8
 12e:	e8 fc ff ff ff       	call   12f <general_protection_fault+0xf>
 133:	83 c4 10             	add    $0x10,%esp
	for(;;);
 136:	eb fe                	jmp    136 <general_protection_fault+0x16>

00000138 <page_fault>:
void page_fault (
	unsigned int cs, 
	unsigned int err,
    unsigned int eip, 
    unsigned int eflags
    ){
 138:	55                   	push   %ebp
 139:	89 e5                	mov    %esp,%ebp
 13b:	83 ec 18             	sub    $0x18,%esp
	asm volatile ("cli");
 13e:	fa                   	cli    
	asm volatile ("sub $4, %ebp");
 13f:	83 ed 04             	sub    $0x4,%ebp

	int faultAddr;

	asm volatile ("mov %%cr2, %0" : "=r"(faultAddr));
 142:	0f 20 d0             	mov    %cr2,%eax
 145:	89 45 f4             	mov    %eax,-0xc(%ebp)

	kernel_panic("Page fault at %#0(6)p:%#0(10)p: referenced memory at %#0(10)p(flags: %#x)", 
 148:	83 ec 0c             	sub    $0xc,%esp
 14b:	ff 75 10             	pushl  0x10(%ebp)
 14e:	ff 75 f4             	pushl  -0xc(%ebp)
 151:	ff 75 0c             	pushl  0xc(%ebp)
 154:	ff 75 08             	pushl  0x8(%ebp)
 157:	68 c4 00 00 00       	push   $0xc4
 15c:	e8 fc ff ff ff       	call   15d <page_fault+0x25>
 161:	83 c4 20             	add    $0x20,%esp
		cs, err, faultAddr, eip);

	//asm volatile ("popal; leave; iret");
	
	asm volatile ("cli");
 164:	fa                   	cli    
	asm volatile ("hlt");
 165:	f4                   	hlt    
}
 166:	90                   	nop
 167:	c9                   	leave  
 168:	c3                   	ret    

00000169 <fpu_fault>:

void fpu_fault (
	unsigned int cs, 
    unsigned int eip, 
    unsigned int eflags
    ){
 169:	55                   	push   %ebp
 16a:	89 e5                	mov    %esp,%ebp
 16c:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("FPU fault");
 16f:	83 ec 0c             	sub    $0xc,%esp
 172:	68 0e 01 00 00       	push   $0x10e
 177:	e8 fc ff ff ff       	call   178 <fpu_fault+0xf>
 17c:	83 c4 10             	add    $0x10,%esp
	for(;;);
 17f:	eb fe                	jmp    17f <fpu_fault+0x16>

00000181 <alignment_check_fault>:
void alignment_check_fault (
	unsigned int cs, 
	unsigned int err,
    unsigned int eip, 
    unsigned int eflags
    ){
 181:	55                   	push   %ebp
 182:	89 e5                	mov    %esp,%ebp
 184:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Alignment check fault");
 187:	83 ec 0c             	sub    $0xc,%esp
 18a:	68 18 01 00 00       	push   $0x118
 18f:	e8 fc ff ff ff       	call   190 <alignment_check_fault+0xf>
 194:	83 c4 10             	add    $0x10,%esp
	for(;;);
 197:	eb fe                	jmp    197 <alignment_check_fault+0x16>

00000199 <machine_check_abort>:

void machine_check_abort (
	unsigned int cs, 
    unsigned int eip, 
    unsigned int eflags
    ){
 199:	55                   	push   %ebp
 19a:	89 e5                	mov    %esp,%ebp
 19c:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("Machine check abort");
 19f:	83 ec 0c             	sub    $0xc,%esp
 1a2:	68 2e 01 00 00       	push   $0x12e
 1a7:	e8 fc ff ff ff       	call   1a8 <machine_check_abort+0xf>
 1ac:	83 c4 10             	add    $0x10,%esp
	for(;;);
 1af:	eb fe                	jmp    1af <machine_check_abort+0x16>

000001b1 <simd_fpu_fault>:

void simd_fpu_fault (
	unsigned int cs, 
    unsigned int eip, 
    unsigned int eflags
    ){
 1b1:	55                   	push   %ebp
 1b2:	89 e5                	mov    %esp,%ebp
 1b4:	83 ec 08             	sub    $0x8,%esp
	kernel_panic("SIMD FPU fault");
 1b7:	83 ec 0c             	sub    $0xc,%esp
 1ba:	68 42 01 00 00       	push   $0x142
 1bf:	e8 fc ff ff ff       	call   1c0 <simd_fpu_fault+0xf>
 1c4:	83 c4 10             	add    $0x10,%esp
	for(;;);
 1c7:	eb fe                	jmp    1c7 <simd_fpu_fault+0x16>

floppy.o:     file format elf32-i386


Disassembly of section .text:

00000000 <dma_initialize_floppy>:
// =====================================
// Private functions
// =====================================

int dma_initialize_floppy(const uint8_t* buffer, const uint32_t length)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 18             	sub    $0x18,%esp
	{
		uint8_t byte[4];//Lo[0], Mid[1], Hi[2]
		unsigned long l;
	}a, c;

	a.l = (unsigned)buffer;
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c.l = (unsigned)length - 1;
   c:	8b 45 0c             	mov    0xc(%ebp),%eax
   f:	83 e8 01             	sub    $0x1,%eax
  12:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//Check for buffer issues
	if ((a.l >> 24) || (c.l >> 16) || (((a.l & 0xffff) + c.l) >> 16)) 
  15:	8b 45 f4             	mov    -0xc(%ebp),%eax
  18:	c1 e8 18             	shr    $0x18,%eax
  1b:	85 c0                	test   %eax,%eax
  1d:	75 1c                	jne    3b <dma_initialize_floppy+0x3b>
  1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  22:	c1 e8 10             	shr    $0x10,%eax
  25:	85 c0                	test   %eax,%eax
  27:	75 12                	jne    3b <dma_initialize_floppy+0x3b>
  29:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2c:	0f b7 d0             	movzwl %ax,%edx
  2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  32:	01 d0                	add    %edx,%eax
  34:	c1 e8 10             	shr    $0x10,%eax
  37:	85 c0                	test   %eax,%eax
  39:	74 1a                	je     55 <dma_initialize_floppy+0x55>
	{
		printf("[FDC]DMA buffer error\n");
  3b:	83 ec 0c             	sub    $0xc,%esp
  3e:	68 0c 00 00 00       	push   $0xc
  43:	e8 fc ff ff ff       	call   44 <dma_initialize_floppy+0x44>
  48:	83 c4 10             	add    $0x10,%esp
		return 0;
  4b:	b8 00 00 00 00       	mov    $0x0,%eax
  50:	e9 9d 00 00 00       	jmp    f2 <dma_initialize_floppy+0xf2>
	}

	dma_reset(1);
  55:	83 ec 0c             	sub    $0xc,%esp
  58:	6a 01                	push   $0x1
  5a:	e8 fc ff ff ff       	call   5b <dma_initialize_floppy+0x5b>
  5f:	83 c4 10             	add    $0x10,%esp
	dma_mask_channel(FDC_DMA_CHANNEL);//Mask channel 2
  62:	b8 02 00 00 00       	mov    $0x2,%eax
  67:	83 ec 0c             	sub    $0xc,%esp
  6a:	50                   	push   %eax
  6b:	e8 fc ff ff ff       	call   6c <dma_initialize_floppy+0x6c>
  70:	83 c4 10             	add    $0x10,%esp
	dma_reset_flipflop(1);//Flipflop reset on DMA 1
  73:	83 ec 0c             	sub    $0xc,%esp
  76:	6a 01                	push   $0x1
  78:	e8 fc ff ff ff       	call   79 <dma_initialize_floppy+0x79>
  7d:	83 c4 10             	add    $0x10,%esp

	dma_set_address(FDC_DMA_CHANNEL, a.byte[0], a.byte[1]);//Buffer address
  80:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
  84:	0f b6 d0             	movzbl %al,%edx
  87:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  8b:	0f b6 c0             	movzbl %al,%eax
  8e:	b9 02 00 00 00       	mov    $0x2,%ecx
  93:	83 ec 04             	sub    $0x4,%esp
  96:	52                   	push   %edx
  97:	50                   	push   %eax
  98:	51                   	push   %ecx
  99:	e8 fc ff ff ff       	call   9a <dma_initialize_floppy+0x9a>
  9e:	83 c4 10             	add    $0x10,%esp
	dma_reset_flipflop(1);//Flipflop reset on DMA 1
  a1:	83 ec 0c             	sub    $0xc,%esp
  a4:	6a 01                	push   $0x1
  a6:	e8 fc ff ff ff       	call   a7 <dma_initialize_floppy+0xa7>
  ab:	83 c4 10             	add    $0x10,%esp

	dma_set_count(FDC_DMA_CHANNEL, c.byte[0], c.byte[1]);//Set count
  ae:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
  b2:	0f b6 d0             	movzbl %al,%edx
  b5:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  b9:	0f b6 c0             	movzbl %al,%eax
  bc:	b9 02 00 00 00       	mov    $0x2,%ecx
  c1:	83 ec 04             	sub    $0x4,%esp
  c4:	52                   	push   %edx
  c5:	50                   	push   %eax
  c6:	51                   	push   %ecx
  c7:	e8 fc ff ff ff       	call   c8 <dma_initialize_floppy+0xc8>
  cc:	83 c4 10             	add    $0x10,%esp
	dma_set_read(FDC_DMA_CHANNEL);
  cf:	b8 02 00 00 00       	mov    $0x2,%eax
  d4:	83 ec 0c             	sub    $0xc,%esp
  d7:	50                   	push   %eax
  d8:	e8 fc ff ff ff       	call   d9 <dma_initialize_floppy+0xd9>
  dd:	83 c4 10             	add    $0x10,%esp

	dma_unmask_all(1);//Unmask channel 2
  e0:	83 ec 0c             	sub    $0xc,%esp
  e3:	6a 01                	push   $0x1
  e5:	e8 fc ff ff ff       	call   e6 <dma_initialize_floppy+0xe6>
  ea:	83 c4 10             	add    $0x10,%esp

	return 1;
  ed:	b8 01 00 00 00       	mov    $0x1,%eax
}
  f2:	c9                   	leave  
  f3:	c3                   	ret    

000000f4 <floppy_disk_read_status>:

const uint8_t floppy_disk_read_status()
{
  f4:	55                   	push   %ebp
  f5:	89 e5                	mov    %esp,%ebp
  f7:	83 ec 08             	sub    $0x8,%esp
	// Return main status register
	return inportb(FLOPPY_DISK_MSR);
  fa:	83 ec 0c             	sub    $0xc,%esp
  fd:	68 f4 03 00 00       	push   $0x3f4
 102:	e8 fc ff ff ff       	call   103 <floppy_disk_read_status+0xf>
 107:	83 c4 10             	add    $0x10,%esp
}
 10a:	c9                   	leave  
 10b:	c3                   	ret    

0000010c <floppy_disk_write_dor>:

void floppy_disk_write_dor(const uint8_t val)
{
 10c:	55                   	push   %ebp
 10d:	89 e5                	mov    %esp,%ebp
 10f:	83 ec 18             	sub    $0x18,%esp
 112:	8b 45 08             	mov    0x8(%ebp),%eax
 115:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Write to the DOR
	outportb(FLOPPY_DISK_DOR, val);
 118:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 11c:	83 ec 08             	sub    $0x8,%esp
 11f:	50                   	push   %eax
 120:	68 f2 03 00 00       	push   $0x3f2
 125:	e8 fc ff ff ff       	call   126 <floppy_disk_write_dor+0x1a>
 12a:	83 c4 10             	add    $0x10,%esp
}
 12d:	90                   	nop
 12e:	c9                   	leave  
 12f:	c3                   	ret    

00000130 <floppy_disk_send_command>:

void floppy_disk_send_command(const uint8_t cmd)
{
 130:	55                   	push   %ebp
 131:	89 e5                	mov    %esp,%ebp
 133:	83 ec 28             	sub    $0x28,%esp
 136:	8b 45 08             	mov    0x8(%ebp),%eax
 139:	88 45 e4             	mov    %al,-0x1c(%ebp)
	// Wait until data register is ready

	printf("[FDC]Trying to send command %0#(4)x... ", cmd);
 13c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 140:	83 ec 08             	sub    $0x8,%esp
 143:	50                   	push   %eax
 144:	68 24 00 00 00       	push   $0x24
 149:	e8 fc ff ff ff       	call   14a <floppy_disk_send_command+0x1a>
 14e:	83 c4 10             	add    $0x10,%esp

	for (int i = 0; i < 500;++i)
 151:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 158:	eb 39                	jmp    193 <floppy_disk_send_command+0x63>
	{
		if (floppy_disk_read_status() & FLOPPY_DISK_MSR_MASK_DATAREG)
 15a:	e8 fc ff ff ff       	call   15b <floppy_disk_send_command+0x2b>
 15f:	84 c0                	test   %al,%al
 161:	79 2c                	jns    18f <floppy_disk_send_command+0x5f>
		{
			printf("Done!\n", cmd);
 163:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 167:	83 ec 08             	sub    $0x8,%esp
 16a:	50                   	push   %eax
 16b:	68 4c 00 00 00       	push   $0x4c
 170:	e8 fc ff ff ff       	call   171 <floppy_disk_send_command+0x41>
 175:	83 c4 10             	add    $0x10,%esp
			return outportb(FLOPPY_DISK_FIFO, cmd);
 178:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 17c:	83 ec 08             	sub    $0x8,%esp
 17f:	50                   	push   %eax
 180:	68 f5 03 00 00       	push   $0x3f5
 185:	e8 fc ff ff ff       	call   186 <floppy_disk_send_command+0x56>
 18a:	83 c4 10             	add    $0x10,%esp
 18d:	eb 1d                	jmp    1ac <floppy_disk_send_command+0x7c>
{
	// Wait until data register is ready

	printf("[FDC]Trying to send command %0#(4)x... ", cmd);

	for (int i = 0; i < 500;++i)
 18f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 193:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
 19a:	7e be                	jle    15a <floppy_disk_send_command+0x2a>
		{
			printf("Done!\n", cmd);
			return outportb(FLOPPY_DISK_FIFO, cmd);
		}
	}
	printf("Failed!\n");
 19c:	83 ec 0c             	sub    $0xc,%esp
 19f:	68 53 00 00 00       	push   $0x53
 1a4:	e8 fc ff ff ff       	call   1a5 <floppy_disk_send_command+0x75>
 1a9:	83 c4 10             	add    $0x10,%esp
}
 1ac:	c9                   	leave  
 1ad:	c3                   	ret    

000001ae <floppy_disk_read_data>:

const uint8_t floppy_disk_read_data()
{
 1ae:	55                   	push   %ebp
 1af:	89 e5                	mov    %esp,%ebp
 1b1:	83 ec 18             	sub    $0x18,%esp
	// Wait until data register is ready

	for (int i = 0; i < 500;++i)
 1b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 1bb:	eb 1f                	jmp    1dc <floppy_disk_read_data+0x2e>
	{
		if (floppy_disk_read_status() & FLOPPY_DISK_MSR_MASK_DATAREG)
 1bd:	e8 fc ff ff ff       	call   1be <floppy_disk_read_data+0x10>
 1c2:	84 c0                	test   %al,%al
 1c4:	79 12                	jns    1d8 <floppy_disk_read_data+0x2a>
		{
			return inportb(FLOPPY_DISK_FIFO);
 1c6:	83 ec 0c             	sub    $0xc,%esp
 1c9:	68 f5 03 00 00       	push   $0x3f5
 1ce:	e8 fc ff ff ff       	call   1cf <floppy_disk_read_data+0x21>
 1d3:	83 c4 10             	add    $0x10,%esp
 1d6:	eb 0d                	jmp    1e5 <floppy_disk_read_data+0x37>

const uint8_t floppy_disk_read_data()
{
	// Wait until data register is ready

	for (int i = 0; i < 500;++i)
 1d8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 1dc:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
 1e3:	7e d8                	jle    1bd <floppy_disk_read_data+0xf>
		if (floppy_disk_read_status() & FLOPPY_DISK_MSR_MASK_DATAREG)
		{
			return inportb(FLOPPY_DISK_FIFO);
		}
	}
}
 1e5:	c9                   	leave  
 1e6:	c3                   	ret    

000001e7 <floppy_disk_write_ccr>:

void floppy_disk_write_ccr(const uint8_t val)
{
 1e7:	55                   	push   %ebp
 1e8:	89 e5                	mov    %esp,%ebp
 1ea:	83 ec 18             	sub    $0x18,%esp
 1ed:	8b 45 08             	mov    0x8(%ebp),%eax
 1f0:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Write to configuration control register

	outportb(FLOPPY_DISK_CTRL, val);
 1f3:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 1f7:	83 ec 08             	sub    $0x8,%esp
 1fa:	50                   	push   %eax
 1fb:	68 f7 03 00 00       	push   $0x3f7
 200:	e8 fc ff ff ff       	call   201 <floppy_disk_write_ccr+0x1a>
 205:	83 c4 10             	add    $0x10,%esp
}
 208:	90                   	nop
 209:	c9                   	leave  
 20a:	c3                   	ret    

0000020b <floppy_disk_wait_irq>:

void floppy_disk_wait_irq()
{
 20b:	55                   	push   %ebp
 20c:	89 e5                	mov    %esp,%ebp
 20e:	83 ec 08             	sub    $0x8,%esp
	printf("Waiting...\n");
 211:	83 ec 0c             	sub    $0xc,%esp
 214:	68 5c 00 00 00       	push   $0x5c
 219:	e8 fc ff ff ff       	call   21a <floppy_disk_wait_irq+0xf>
 21e:	83 c4 10             	add    $0x10,%esp
	while (_FloppyDiskIRQ == 0);
 221:	90                   	nop
 222:	0f b6 05 01 00 00 00 	movzbl 0x1,%eax
 229:	84 c0                	test   %al,%al
 22b:	74 f5                	je     222 <floppy_disk_wait_irq+0x17>
	_FloppyDiskIRQ = 0;
 22d:	c6 05 01 00 00 00 00 	movb   $0x0,0x1
}
 234:	90                   	nop
 235:	c9                   	leave  
 236:	c3                   	ret    

00000237 <i86_floppy_irq>:

void i86_floppy_irq()
{
 237:	55                   	push   %ebp
 238:	89 e5                	mov    %esp,%ebp
 23a:	83 ec 08             	sub    $0x8,%esp
	asm volatile ("add %esp, 12");
 23d:	01 25 0c 00 00 00    	add    %esp,0xc
	asm volatile ("pushal");
 243:	60                   	pusha  
	asm volatile ("cli");
 244:	fa                   	cli    

	printf("[FDC]IRQ fired\n");
 245:	83 ec 0c             	sub    $0xc,%esp
 248:	68 68 00 00 00       	push   $0x68
 24d:	e8 fc ff ff ff       	call   24e <i86_floppy_irq+0x17>
 252:	83 c4 10             	add    $0x10,%esp

	//! irq fired
	_FloppyDiskIRQ = 1;
 255:	c6 05 01 00 00 00 01 	movb   $0x1,0x1

	//! tell hal we are done
	interruptdone(FLOPPY_IRQ);
 25c:	b8 06 00 00 00       	mov    $0x6,%eax
 261:	83 ec 0c             	sub    $0xc,%esp
 264:	50                   	push   %eax
 265:	e8 fc ff ff ff       	call   266 <i86_floppy_irq+0x2f>
 26a:	83 c4 10             	add    $0x10,%esp

	asm volatile ("sti");
 26d:	fb                   	sti    
	asm volatile ("popal; leave; iret");
 26e:	61                   	popa   
 26f:	c9                   	leave  
 270:	cf                   	iret   
}
 271:	90                   	nop
 272:	c9                   	leave  
 273:	c3                   	ret    

00000274 <floppy_disk_check_int>:

void floppy_disk_check_int(uint32_t* st0, uint32_t* cyl)
{
 274:	55                   	push   %ebp
 275:	89 e5                	mov    %esp,%ebp
 277:	83 ec 08             	sub    $0x8,%esp
	floppy_disk_send_command(FDC_CMD_CHECK_INT);
 27a:	83 ec 0c             	sub    $0xc,%esp
 27d:	6a 08                	push   $0x8
 27f:	e8 fc ff ff ff       	call   280 <floppy_disk_check_int+0xc>
 284:	83 c4 10             	add    $0x10,%esp

	*st0 = floppy_disk_read_data();
 287:	e8 fc ff ff ff       	call   288 <floppy_disk_check_int+0x14>
 28c:	0f b6 d0             	movzbl %al,%edx
 28f:	8b 45 08             	mov    0x8(%ebp),%eax
 292:	89 10                	mov    %edx,(%eax)
	*cyl = floppy_disk_read_data();
 294:	e8 fc ff ff ff       	call   295 <floppy_disk_check_int+0x21>
 299:	0f b6 d0             	movzbl %al,%edx
 29c:	8b 45 0c             	mov    0xc(%ebp),%eax
 29f:	89 10                	mov    %edx,(%eax)
}
 2a1:	90                   	nop
 2a2:	c9                   	leave  
 2a3:	c3                   	ret    

000002a4 <floppy_disk_set_motor>:

void floppy_disk_set_motor(int b)
{
 2a4:	55                   	push   %ebp
 2a5:	89 e5                	mov    %esp,%ebp
 2a7:	83 ec 18             	sub    $0x18,%esp
	// Sanity check

	if (_CurrentDrive > 3)
 2aa:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 2b1:	3c 03                	cmp    $0x3,%al
 2b3:	0f 87 9b 00 00 00    	ja     354 <floppy_disk_set_motor+0xb0>
	{
		return;
	}

	uint8_t motor = 0;
 2b9:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

	// Get motor from drive
	switch (_CurrentDrive)
 2bd:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 2c4:	0f b6 c0             	movzbl %al,%eax
 2c7:	83 f8 01             	cmp    $0x1,%eax
 2ca:	74 1d                	je     2e9 <floppy_disk_set_motor+0x45>
 2cc:	83 f8 01             	cmp    $0x1,%eax
 2cf:	7f 06                	jg     2d7 <floppy_disk_set_motor+0x33>
 2d1:	85 c0                	test   %eax,%eax
 2d3:	74 0e                	je     2e3 <floppy_disk_set_motor+0x3f>
 2d5:	eb 23                	jmp    2fa <floppy_disk_set_motor+0x56>
 2d7:	83 f8 02             	cmp    $0x2,%eax
 2da:	74 13                	je     2ef <floppy_disk_set_motor+0x4b>
 2dc:	83 f8 03             	cmp    $0x3,%eax
 2df:	74 14                	je     2f5 <floppy_disk_set_motor+0x51>
 2e1:	eb 17                	jmp    2fa <floppy_disk_set_motor+0x56>
	{
	case 0:
		motor = FLOPPY_DISK_DOR_MASK_DRIVE0_MOTOR;
 2e3:	c6 45 f7 10          	movb   $0x10,-0x9(%ebp)
		break;
 2e7:	eb 11                	jmp    2fa <floppy_disk_set_motor+0x56>
	case 1:
		motor = FLOPPY_DISK_DOR_MASK_DRIVE1_MOTOR;
 2e9:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
		break;
 2ed:	eb 0b                	jmp    2fa <floppy_disk_set_motor+0x56>
	case 2:
		motor = FLOPPY_DISK_DOR_MASK_DRIVE2_MOTOR;
 2ef:	c6 45 f7 40          	movb   $0x40,-0x9(%ebp)
		break;
 2f3:	eb 05                	jmp    2fa <floppy_disk_set_motor+0x56>
	case 3:
		motor = FLOPPY_DISK_DOR_MASK_DRIVE3_MOTOR;
 2f5:	c6 45 f7 80          	movb   $0x80,-0x9(%ebp)
		break;
 2f9:	90                   	nop
	}

	// Turn on or off motor
	if (b)
 2fa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 2fe:	74 2b                	je     32b <floppy_disk_set_motor+0x87>
	{
		floppy_disk_write_dor(_CurrentDrive | motor | FLOPPY_DISK_DOR_MASK_RESET | FLOPPY_DISK_DOR_MASK_DMA);
 300:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 307:	0a 45 f7             	or     -0x9(%ebp),%al
 30a:	83 c8 0c             	or     $0xc,%eax
 30d:	0f b6 c0             	movzbl %al,%eax
 310:	83 ec 0c             	sub    $0xc,%esp
 313:	50                   	push   %eax
 314:	e8 fc ff ff ff       	call   315 <floppy_disk_set_motor+0x71>
 319:	83 c4 10             	add    $0x10,%esp
		sleep(50);
 31c:	83 ec 0c             	sub    $0xc,%esp
 31f:	6a 32                	push   $0x32
 321:	e8 fc ff ff ff       	call   322 <floppy_disk_set_motor+0x7e>
 326:	83 c4 10             	add    $0x10,%esp
 329:	eb 1a                	jmp    345 <floppy_disk_set_motor+0xa1>
	}
	else
	{
		floppy_disk_write_dor(FLOPPY_DISK_DOR_MASK_RESET | FLOPPY_DISK_DOR_MASK_DMA);
 32b:	83 ec 0c             	sub    $0xc,%esp
 32e:	6a 0c                	push   $0xc
 330:	e8 fc ff ff ff       	call   331 <floppy_disk_set_motor+0x8d>
 335:	83 c4 10             	add    $0x10,%esp
		sleep(50);
 338:	83 ec 0c             	sub    $0xc,%esp
 33b:	6a 32                	push   $0x32
 33d:	e8 fc ff ff ff       	call   33e <floppy_disk_set_motor+0x9a>
 342:	83 c4 10             	add    $0x10,%esp
	}

	sleep(20);
 345:	83 ec 0c             	sub    $0xc,%esp
 348:	6a 14                	push   $0x14
 34a:	e8 fc ff ff ff       	call   34b <floppy_disk_set_motor+0xa7>
 34f:	83 c4 10             	add    $0x10,%esp
 352:	eb 01                	jmp    355 <floppy_disk_set_motor+0xb1>
{
	// Sanity check

	if (_CurrentDrive > 3)
	{
		return;
 354:	90                   	nop
		floppy_disk_write_dor(FLOPPY_DISK_DOR_MASK_RESET | FLOPPY_DISK_DOR_MASK_DMA);
		sleep(50);
	}

	sleep(20);
}
 355:	c9                   	leave  
 356:	c3                   	ret    

00000357 <floppy_disk_configure_drive>:

void floppy_disk_configure_drive(const uint32_t stepr, const uint32_t loadt, const uint32_t unloadt, int dma)
{
 357:	55                   	push   %ebp
 358:	89 e5                	mov    %esp,%ebp
 35a:	83 ec 18             	sub    $0x18,%esp
	uint8_t data = 0;
 35d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

	floppy_disk_send_command(FDC_CMD_SPECIFY);
 361:	83 ec 0c             	sub    $0xc,%esp
 364:	6a 03                	push   $0x3
 366:	e8 fc ff ff ff       	call   367 <floppy_disk_configure_drive+0x10>
 36b:	83 c4 10             	add    $0x10,%esp

	data = ((stepr & 0x0F) << 4) | (unloadt & 0x0F);
 36e:	8b 45 08             	mov    0x8(%ebp),%eax
 371:	c1 e0 04             	shl    $0x4,%eax
 374:	89 c2                	mov    %eax,%edx
 376:	8b 45 10             	mov    0x10(%ebp),%eax
 379:	83 e0 0f             	and    $0xf,%eax
 37c:	09 d0                	or     %edx,%eax
 37e:	88 45 f7             	mov    %al,-0x9(%ebp)
	floppy_disk_send_command(data);
 381:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
 385:	83 ec 0c             	sub    $0xc,%esp
 388:	50                   	push   %eax
 389:	e8 fc ff ff ff       	call   38a <floppy_disk_configure_drive+0x33>
 38e:	83 c4 10             	add    $0x10,%esp

	data = (loadt) << 1 | (dma) ? 1 : 0;
 391:	8b 45 0c             	mov    0xc(%ebp),%eax
 394:	8d 14 00             	lea    (%eax,%eax,1),%edx
 397:	8b 45 14             	mov    0x14(%ebp),%eax
 39a:	09 d0                	or     %edx,%eax
 39c:	85 c0                	test   %eax,%eax
 39e:	0f 95 c0             	setne  %al
 3a1:	88 45 f7             	mov    %al,-0x9(%ebp)
	floppy_disk_send_command(data);
 3a4:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
 3a8:	83 ec 0c             	sub    $0xc,%esp
 3ab:	50                   	push   %eax
 3ac:	e8 fc ff ff ff       	call   3ad <floppy_disk_configure_drive+0x56>
 3b1:	83 c4 10             	add    $0x10,%esp
}
 3b4:	90                   	nop
 3b5:	c9                   	leave  
 3b6:	c3                   	ret    

000003b7 <floppy_disk_calibrate>:

const FLOPPY_DISK_ERROR floppy_disk_calibrate(const uint32_t drive)
{
 3b7:	55                   	push   %ebp
 3b8:	89 e5                	mov    %esp,%ebp
 3ba:	83 ec 18             	sub    $0x18,%esp
	uint32_t st0;
	uint32_t cyl;

	// Sanity check

	if (drive >= 4)
 3bd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
 3c1:	76 0a                	jbe    3cd <floppy_disk_calibrate+0x16>
	{
		return FLOPPY_INVALID_DRIVE;
 3c3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 3c8:	e9 84 00 00 00       	jmp    451 <floppy_disk_calibrate+0x9a>
	}

	// Turn on motor

	floppy_disk_set_motor(1);
 3cd:	83 ec 0c             	sub    $0xc,%esp
 3d0:	6a 01                	push   $0x1
 3d2:	e8 fc ff ff ff       	call   3d3 <floppy_disk_calibrate+0x1c>
 3d7:	83 c4 10             	add    $0x10,%esp

	for (int i = 0; i < 10; ++i)
 3da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 3e1:	eb 56                	jmp    439 <floppy_disk_calibrate+0x82>
	{
		floppy_disk_send_command(FDC_CMD_CALIBRATE);
 3e3:	83 ec 0c             	sub    $0xc,%esp
 3e6:	6a 07                	push   $0x7
 3e8:	e8 fc ff ff ff       	call   3e9 <floppy_disk_calibrate+0x32>
 3ed:	83 c4 10             	add    $0x10,%esp
		floppy_disk_send_command(drive);
 3f0:	8b 45 08             	mov    0x8(%ebp),%eax
 3f3:	0f b6 c0             	movzbl %al,%eax
 3f6:	83 ec 0c             	sub    $0xc,%esp
 3f9:	50                   	push   %eax
 3fa:	e8 fc ff ff ff       	call   3fb <floppy_disk_calibrate+0x44>
 3ff:	83 c4 10             	add    $0x10,%esp
		floppy_disk_wait_irq();
 402:	e8 fc ff ff ff       	call   403 <floppy_disk_calibrate+0x4c>
		floppy_disk_check_int(&st0, &cyl);
 407:	83 ec 08             	sub    $0x8,%esp
 40a:	8d 45 ec             	lea    -0x14(%ebp),%eax
 40d:	50                   	push   %eax
 40e:	8d 45 f0             	lea    -0x10(%ebp),%eax
 411:	50                   	push   %eax
 412:	e8 fc ff ff ff       	call   413 <floppy_disk_calibrate+0x5c>
 417:	83 c4 10             	add    $0x10,%esp

		// Check if cylinder 0 was found
		if (!cyl)
 41a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 41d:	85 c0                	test   %eax,%eax
 41f:	75 14                	jne    435 <floppy_disk_calibrate+0x7e>
		{
			floppy_disk_set_motor(0);
 421:	83 ec 0c             	sub    $0xc,%esp
 424:	6a 00                	push   $0x0
 426:	e8 fc ff ff ff       	call   427 <floppy_disk_calibrate+0x70>
 42b:	83 c4 10             	add    $0x10,%esp
			return FLOPPY_GOOD;
 42e:	b8 00 00 00 00       	mov    $0x0,%eax
 433:	eb 1c                	jmp    451 <floppy_disk_calibrate+0x9a>

	// Turn on motor

	floppy_disk_set_motor(1);

	for (int i = 0; i < 10; ++i)
 435:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 439:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
 43d:	7e a4                	jle    3e3 <floppy_disk_calibrate+0x2c>
			floppy_disk_set_motor(0);
			return FLOPPY_GOOD;
		}
	}

	floppy_disk_set_motor(0);
 43f:	83 ec 0c             	sub    $0xc,%esp
 442:	6a 00                	push   $0x0
 444:	e8 fc ff ff ff       	call   445 <floppy_disk_calibrate+0x8e>
 449:	83 c4 10             	add    $0x10,%esp
	return FLOPPY_BAD;
 44c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 451:	c9                   	leave  
 452:	c3                   	ret    

00000453 <floppy_disk_disable_controller>:

void floppy_disk_disable_controller()
{
 453:	55                   	push   %ebp
 454:	89 e5                	mov    %esp,%ebp
 456:	83 ec 08             	sub    $0x8,%esp
	floppy_disk_write_dor(0);
 459:	83 ec 0c             	sub    $0xc,%esp
 45c:	6a 00                	push   $0x0
 45e:	e8 fc ff ff ff       	call   45f <floppy_disk_disable_controller+0xc>
 463:	83 c4 10             	add    $0x10,%esp
}
 466:	90                   	nop
 467:	c9                   	leave  
 468:	c3                   	ret    

00000469 <floppy_disk_enable_controller>:

void floppy_disk_enable_controller()
{
 469:	55                   	push   %ebp
 46a:	89 e5                	mov    %esp,%ebp
 46c:	83 ec 08             	sub    $0x8,%esp
	floppy_disk_write_dor(FLOPPY_DISK_DOR_MASK_RESET | FLOPPY_DISK_DOR_MASK_DMA);
 46f:	83 ec 0c             	sub    $0xc,%esp
 472:	6a 0c                	push   $0xc
 474:	e8 fc ff ff ff       	call   475 <floppy_disk_enable_controller+0xc>
 479:	83 c4 10             	add    $0x10,%esp
}
 47c:	90                   	nop
 47d:	c9                   	leave  
 47e:	c3                   	ret    

0000047f <floppy_disk_reset>:

void floppy_disk_reset()
{
 47f:	55                   	push   %ebp
 480:	89 e5                	mov    %esp,%ebp
 482:	83 ec 18             	sub    $0x18,%esp
	uint32_t st0;
	uint32_t cyl;

	floppy_disk_disable_controller();
 485:	e8 fc ff ff ff       	call   486 <floppy_disk_reset+0x7>

	floppy_disk_enable_controller();
 48a:	e8 fc ff ff ff       	call   48b <floppy_disk_reset+0xc>

	floppy_disk_wait_irq();
 48f:	e8 fc ff ff ff       	call   490 <floppy_disk_reset+0x11>

	// Transfer speed 500 kb/s

	floppy_disk_write_ccr(0);
 494:	83 ec 0c             	sub    $0xc,%esp
 497:	6a 00                	push   $0x0
 499:	e8 fc ff ff ff       	call   49a <floppy_disk_reset+0x1b>
 49e:	83 c4 10             	add    $0x10,%esp

	// Send CHECK INT/SENSE INTERRUPT command to all drives

	for (int i = 0; i < 4; ++i)
 4a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 4a8:	eb 17                	jmp    4c1 <floppy_disk_reset+0x42>
	{
		floppy_disk_check_int(&st0, &cyl);
 4aa:	83 ec 08             	sub    $0x8,%esp
 4ad:	8d 45 ec             	lea    -0x14(%ebp),%eax
 4b0:	50                   	push   %eax
 4b1:	8d 45 f0             	lea    -0x10(%ebp),%eax
 4b4:	50                   	push   %eax
 4b5:	e8 fc ff ff ff       	call   4b6 <floppy_disk_reset+0x37>
 4ba:	83 c4 10             	add    $0x10,%esp

	floppy_disk_write_ccr(0);

	// Send CHECK INT/SENSE INTERRUPT command to all drives

	for (int i = 0; i < 4; ++i)
 4bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 4c1:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
 4c5:	7e e3                	jle    4aa <floppy_disk_reset+0x2b>
		floppy_disk_check_int(&st0, &cyl);
	}

	// Transfer speed 500 kb/s

	floppy_disk_write_ccr(0);
 4c7:	83 ec 0c             	sub    $0xc,%esp
 4ca:	6a 00                	push   $0x0
 4cc:	e8 fc ff ff ff       	call   4cd <floppy_disk_reset+0x4e>
 4d1:	83 c4 10             	add    $0x10,%esp
	// Pass mechanincal info.
	// Steprate = 3ms
	// load time = 16ms
	// unload time = 240ms
	// Use DMA
	floppy_disk_configure_drive(3, 16, 240, 1);
 4d4:	6a 01                	push   $0x1
 4d6:	68 f0 00 00 00       	push   $0xf0
 4db:	6a 10                	push   $0x10
 4dd:	6a 03                	push   $0x3
 4df:	e8 fc ff ff ff       	call   4e0 <floppy_disk_reset+0x61>
 4e4:	83 c4 10             	add    $0x10,%esp

	// Calibrate disk
	floppy_disk_calibrate(_CurrentDrive);
 4e7:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 4ee:	0f b6 c0             	movzbl %al,%eax
 4f1:	83 ec 0c             	sub    $0xc,%esp
 4f4:	50                   	push   %eax
 4f5:	e8 fc ff ff ff       	call   4f6 <floppy_disk_reset+0x77>
 4fa:	83 c4 10             	add    $0x10,%esp
}
 4fd:	90                   	nop
 4fe:	c9                   	leave  
 4ff:	c3                   	ret    

00000500 <floppy_disk_read_sector_imp>:

void floppy_disk_read_sector_imp(const uint8_t head, const uint8_t track, const uint8_t sector)
{
 500:	55                   	push   %ebp
 501:	89 e5                	mov    %esp,%ebp
 503:	83 ec 28             	sub    $0x28,%esp
 506:	8b 4d 08             	mov    0x8(%ebp),%ecx
 509:	8b 55 0c             	mov    0xc(%ebp),%edx
 50c:	8b 45 10             	mov    0x10(%ebp),%eax
 50f:	88 4d e4             	mov    %cl,-0x1c(%ebp)
 512:	88 55 e0             	mov    %dl,-0x20(%ebp)
 515:	88 45 dc             	mov    %al,-0x24(%ebp)
	uint32_t st0;
	uint32_t cyl;

	// Set DMA to read
	dma_initialize_floppy((uint8_t*)DMA_BUFFER, 512);
 518:	a1 00 00 00 00       	mov    0x0,%eax
 51d:	83 ec 08             	sub    $0x8,%esp
 520:	68 00 02 00 00       	push   $0x200
 525:	50                   	push   %eax
 526:	e8 fc ff ff ff       	call   527 <floppy_disk_read_sector_imp+0x27>
 52b:	83 c4 10             	add    $0x10,%esp
	dma_set_read(FDC_DMA_CHANNEL);
 52e:	b8 02 00 00 00       	mov    $0x2,%eax
 533:	83 ec 0c             	sub    $0xc,%esp
 536:	50                   	push   %eax
 537:	e8 fc ff ff ff       	call   538 <floppy_disk_read_sector_imp+0x38>
 53c:	83 c4 10             	add    $0x10,%esp

	_FloppyDiskIRQ = 0;
 53f:	c6 05 01 00 00 00 00 	movb   $0x0,0x1


	// Read in a sector
	floppy_disk_send_command(
 546:	83 ec 0c             	sub    $0xc,%esp
 549:	68 e6 00 00 00       	push   $0xe6
 54e:	e8 fc ff ff ff       	call   54f <floppy_disk_read_sector_imp+0x4f>
 553:	83 c4 10             	add    $0x10,%esp
		FDC_CMD_READ_SECT| 
		FDC_CMD_EXT_MULTITRACK |
		FDC_CMD_EXT_SKIP |
		FDC_CMD_EXT_DENSITY);

	floppy_disk_send_command((head << 2) | _CurrentDrive);
 556:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 55a:	c1 e0 02             	shl    $0x2,%eax
 55d:	89 c2                	mov    %eax,%edx
 55f:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 566:	09 d0                	or     %edx,%eax
 568:	0f b6 c0             	movzbl %al,%eax
 56b:	83 ec 0c             	sub    $0xc,%esp
 56e:	50                   	push   %eax
 56f:	e8 fc ff ff ff       	call   570 <floppy_disk_read_sector_imp+0x70>
 574:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(track);
 577:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
 57b:	83 ec 0c             	sub    $0xc,%esp
 57e:	50                   	push   %eax
 57f:	e8 fc ff ff ff       	call   580 <floppy_disk_read_sector_imp+0x80>
 584:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(head);
 587:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 58b:	83 ec 0c             	sub    $0xc,%esp
 58e:	50                   	push   %eax
 58f:	e8 fc ff ff ff       	call   590 <floppy_disk_read_sector_imp+0x90>
 594:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(sector);
 597:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
 59b:	83 ec 0c             	sub    $0xc,%esp
 59e:	50                   	push   %eax
 59f:	e8 fc ff ff ff       	call   5a0 <floppy_disk_read_sector_imp+0xa0>
 5a4:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(FLOPPY_DISK_DTL_512);
 5a7:	83 ec 0c             	sub    $0xc,%esp
 5aa:	6a 02                	push   $0x2
 5ac:	e8 fc ff ff ff       	call   5ad <floppy_disk_read_sector_imp+0xad>
 5b1:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(((sector + 1) >= FLOPPY_SECTORS_PER_TRACK) ? FLOPPY_SECTORS_PER_TRACK : sector + 1);
 5b4:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
 5b8:	83 c0 01             	add    $0x1,%eax
 5bb:	ba 12 00 00 00       	mov    $0x12,%edx
 5c0:	39 d0                	cmp    %edx,%eax
 5c2:	0f 4f c2             	cmovg  %edx,%eax
 5c5:	0f b6 c0             	movzbl %al,%eax
 5c8:	83 ec 0c             	sub    $0xc,%esp
 5cb:	50                   	push   %eax
 5cc:	e8 fc ff ff ff       	call   5cd <floppy_disk_read_sector_imp+0xcd>
 5d1:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(FLOPPY_DISK_GAP3_LENGTH_3_5);
 5d4:	83 ec 0c             	sub    $0xc,%esp
 5d7:	6a 1b                	push   $0x1b
 5d9:	e8 fc ff ff ff       	call   5da <floppy_disk_read_sector_imp+0xda>
 5de:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(0xFF); // End of command
 5e1:	83 ec 0c             	sub    $0xc,%esp
 5e4:	68 ff 00 00 00       	push   $0xff
 5e9:	e8 fc ff ff ff       	call   5ea <floppy_disk_read_sector_imp+0xea>
 5ee:	83 c4 10             	add    $0x10,%esp

	printf("Waiting for READ irq fire\n");
 5f1:	83 ec 0c             	sub    $0xc,%esp
 5f4:	68 78 00 00 00       	push   $0x78
 5f9:	e8 fc ff ff ff       	call   5fa <floppy_disk_read_sector_imp+0xfa>
 5fe:	83 c4 10             	add    $0x10,%esp

	floppy_disk_wait_irq();
 601:	e8 fc ff ff ff       	call   602 <floppy_disk_read_sector_imp+0x102>

	printf("Got READ irq\n");
 606:	83 ec 0c             	sub    $0xc,%esp
 609:	68 93 00 00 00       	push   $0x93
 60e:	e8 fc ff ff ff       	call   60f <floppy_disk_read_sector_imp+0x10f>
 613:	83 c4 10             	add    $0x10,%esp
	//Return byte 5 : Sector number
	//Return byte 6 : Sector size

	rw_return_t res;

	res.st0 = floppy_disk_read_data();
 616:	e8 fc ff ff ff       	call   617 <floppy_disk_read_sector_imp+0x117>
 61b:	88 45 e9             	mov    %al,-0x17(%ebp)
	res.st1 = floppy_disk_read_data();
 61e:	e8 fc ff ff ff       	call   61f <floppy_disk_read_sector_imp+0x11f>
 623:	88 45 ea             	mov    %al,-0x16(%ebp)
	res.st2 = floppy_disk_read_data();
 626:	e8 fc ff ff ff       	call   627 <floppy_disk_read_sector_imp+0x127>
 62b:	88 45 eb             	mov    %al,-0x15(%ebp)
	res.currentCylinder = floppy_disk_read_data();
 62e:	e8 fc ff ff ff       	call   62f <floppy_disk_read_sector_imp+0x12f>
 633:	88 45 ec             	mov    %al,-0x14(%ebp)
	res.currentHead = floppy_disk_read_data();
 636:	e8 fc ff ff ff       	call   637 <floppy_disk_read_sector_imp+0x137>
 63b:	88 45 ed             	mov    %al,-0x13(%ebp)
	res.sectorNumber = floppy_disk_read_data();
 63e:	e8 fc ff ff ff       	call   63f <floppy_disk_read_sector_imp+0x13f>
 643:	88 45 ee             	mov    %al,-0x12(%ebp)
	res.sectorSize = floppy_disk_read_data();
 646:	e8 fc ff ff ff       	call   647 <floppy_disk_read_sector_imp+0x147>
 64b:	88 45 ef             	mov    %al,-0x11(%ebp)

	// Let FDC know we handled interrupt.
	floppy_disk_check_int(&st0, &cyl);
 64e:	83 ec 08             	sub    $0x8,%esp
 651:	8d 45 f0             	lea    -0x10(%ebp),%eax
 654:	50                   	push   %eax
 655:	8d 45 f4             	lea    -0xc(%ebp),%eax
 658:	50                   	push   %eax
 659:	e8 fc ff ff ff       	call   65a <floppy_disk_read_sector_imp+0x15a>
 65e:	83 c4 10             	add    $0x10,%esp

	static uint32_t readCount = 0;

	//monitor_printf("\n%i",++readCount);
}
 661:	90                   	nop
 662:	c9                   	leave  
 663:	c3                   	ret    

00000664 <floppy_disk_write_sector_imp>:

void floppy_disk_write_sector_imp(const uint8_t head, const uint8_t track, const uint8_t sector)
{
 664:	55                   	push   %ebp
 665:	89 e5                	mov    %esp,%ebp
 667:	83 ec 28             	sub    $0x28,%esp
 66a:	8b 4d 08             	mov    0x8(%ebp),%ecx
 66d:	8b 55 0c             	mov    0xc(%ebp),%edx
 670:	8b 45 10             	mov    0x10(%ebp),%eax
 673:	88 4d e4             	mov    %cl,-0x1c(%ebp)
 676:	88 55 e0             	mov    %dl,-0x20(%ebp)
 679:	88 45 dc             	mov    %al,-0x24(%ebp)
	uint32_t st0;
	uint32_t cyl;

	// Set DMA to write
	dma_initialize_floppy((uint8_t*)DMA_BUFFER, 512);
 67c:	a1 00 00 00 00       	mov    0x0,%eax
 681:	83 ec 08             	sub    $0x8,%esp
 684:	68 00 02 00 00       	push   $0x200
 689:	50                   	push   %eax
 68a:	e8 fc ff ff ff       	call   68b <floppy_disk_write_sector_imp+0x27>
 68f:	83 c4 10             	add    $0x10,%esp
	dma_set_write(FDC_DMA_CHANNEL);
 692:	b8 02 00 00 00       	mov    $0x2,%eax
 697:	83 ec 0c             	sub    $0xc,%esp
 69a:	50                   	push   %eax
 69b:	e8 fc ff ff ff       	call   69c <floppy_disk_write_sector_imp+0x38>
 6a0:	83 c4 10             	add    $0x10,%esp

	// Read in a sector
	floppy_disk_send_command(
 6a3:	83 ec 0c             	sub    $0xc,%esp
 6a6:	68 e5 00 00 00       	push   $0xe5
 6ab:	e8 fc ff ff ff       	call   6ac <floppy_disk_write_sector_imp+0x48>
 6b0:	83 c4 10             	add    $0x10,%esp
		FDC_CMD_WRITE_SECT |
		FDC_CMD_EXT_MULTITRACK |
		FDC_CMD_EXT_SKIP |
		FDC_CMD_EXT_DENSITY);
	floppy_disk_send_command((head << 2) | _CurrentDrive);
 6b3:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 6b7:	c1 e0 02             	shl    $0x2,%eax
 6ba:	89 c2                	mov    %eax,%edx
 6bc:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 6c3:	09 d0                	or     %edx,%eax
 6c5:	0f b6 c0             	movzbl %al,%eax
 6c8:	83 ec 0c             	sub    $0xc,%esp
 6cb:	50                   	push   %eax
 6cc:	e8 fc ff ff ff       	call   6cd <floppy_disk_write_sector_imp+0x69>
 6d1:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(track);
 6d4:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
 6d8:	83 ec 0c             	sub    $0xc,%esp
 6db:	50                   	push   %eax
 6dc:	e8 fc ff ff ff       	call   6dd <floppy_disk_write_sector_imp+0x79>
 6e1:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(head);
 6e4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 6e8:	83 ec 0c             	sub    $0xc,%esp
 6eb:	50                   	push   %eax
 6ec:	e8 fc ff ff ff       	call   6ed <floppy_disk_write_sector_imp+0x89>
 6f1:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(sector);
 6f4:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
 6f8:	83 ec 0c             	sub    $0xc,%esp
 6fb:	50                   	push   %eax
 6fc:	e8 fc ff ff ff       	call   6fd <floppy_disk_write_sector_imp+0x99>
 701:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(FLOPPY_DISK_DTL_512);
 704:	83 ec 0c             	sub    $0xc,%esp
 707:	6a 02                	push   $0x2
 709:	e8 fc ff ff ff       	call   70a <floppy_disk_write_sector_imp+0xa6>
 70e:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(((sector + 1) >= FLOPPY_SECTORS_PER_TRACK) ? FLOPPY_SECTORS_PER_TRACK : sector + 1);
 711:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
 715:	83 c0 01             	add    $0x1,%eax
 718:	ba 12 00 00 00       	mov    $0x12,%edx
 71d:	39 d0                	cmp    %edx,%eax
 71f:	0f 4f c2             	cmovg  %edx,%eax
 722:	0f b6 c0             	movzbl %al,%eax
 725:	83 ec 0c             	sub    $0xc,%esp
 728:	50                   	push   %eax
 729:	e8 fc ff ff ff       	call   72a <floppy_disk_write_sector_imp+0xc6>
 72e:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(FLOPPY_DISK_GAP3_LENGTH_3_5);
 731:	83 ec 0c             	sub    $0xc,%esp
 734:	6a 1b                	push   $0x1b
 736:	e8 fc ff ff ff       	call   737 <floppy_disk_write_sector_imp+0xd3>
 73b:	83 c4 10             	add    $0x10,%esp
	floppy_disk_send_command(0xFF); // End of command
 73e:	83 ec 0c             	sub    $0xc,%esp
 741:	68 ff 00 00 00       	push   $0xff
 746:	e8 fc ff ff ff       	call   747 <floppy_disk_write_sector_imp+0xe3>
 74b:	83 c4 10             	add    $0x10,%esp

	floppy_disk_wait_irq();
 74e:	e8 fc ff ff ff       	call   74f <floppy_disk_write_sector_imp+0xeb>
	//Return byte 5 : Sector number
	//Return byte 6 : Sector size

	rw_return_t res;

	res.st0 = floppy_disk_read_data();
 753:	e8 fc ff ff ff       	call   754 <floppy_disk_write_sector_imp+0xf0>
 758:	88 45 e9             	mov    %al,-0x17(%ebp)
	res.st1 = floppy_disk_read_data();
 75b:	e8 fc ff ff ff       	call   75c <floppy_disk_write_sector_imp+0xf8>
 760:	88 45 ea             	mov    %al,-0x16(%ebp)
	res.st2 = floppy_disk_read_data();
 763:	e8 fc ff ff ff       	call   764 <floppy_disk_write_sector_imp+0x100>
 768:	88 45 eb             	mov    %al,-0x15(%ebp)
	res.currentCylinder = floppy_disk_read_data();
 76b:	e8 fc ff ff ff       	call   76c <floppy_disk_write_sector_imp+0x108>
 770:	88 45 ec             	mov    %al,-0x14(%ebp)
	res.currentHead = floppy_disk_read_data();
 773:	e8 fc ff ff ff       	call   774 <floppy_disk_write_sector_imp+0x110>
 778:	88 45 ed             	mov    %al,-0x13(%ebp)
	res.sectorNumber = floppy_disk_read_data();
 77b:	e8 fc ff ff ff       	call   77c <floppy_disk_write_sector_imp+0x118>
 780:	88 45 ee             	mov    %al,-0x12(%ebp)
	res.sectorSize = floppy_disk_read_data();
 783:	e8 fc ff ff ff       	call   784 <floppy_disk_write_sector_imp+0x120>
 788:	88 45 ef             	mov    %al,-0x11(%ebp)

	// Let FDC know we handled interrupt.
	floppy_disk_check_int(&st0, &cyl);
 78b:	83 ec 08             	sub    $0x8,%esp
 78e:	8d 45 f0             	lea    -0x10(%ebp),%eax
 791:	50                   	push   %eax
 792:	8d 45 f4             	lea    -0xc(%ebp),%eax
 795:	50                   	push   %eax
 796:	e8 fc ff ff ff       	call   797 <floppy_disk_write_sector_imp+0x133>
 79b:	83 c4 10             	add    $0x10,%esp
}
 79e:	90                   	nop
 79f:	c9                   	leave  
 7a0:	c3                   	ret    

000007a1 <floppy_disk_seek>:

const FLOPPY_DISK_ERROR floppy_disk_seek(const uint32_t cyl, const uint32_t head)
{
 7a1:	55                   	push   %ebp
 7a2:	89 e5                	mov    %esp,%ebp
 7a4:	83 ec 18             	sub    $0x18,%esp
	uint32_t st0;
	uint32_t cyl0;

	// Sanity check

	if (_CurrentDrive >= 4)
 7a7:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 7ae:	3c 03                	cmp    $0x3,%al
 7b0:	76 0a                	jbe    7bc <floppy_disk_seek+0x1b>
	{
		return FLOPPY_INVALID_DRIVE;
 7b2:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 7b7:	e9 ae 00 00 00       	jmp    86a <floppy_disk_seek+0xc9>
	}

	for (int i = 0; i < 10; ++i)
 7bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 7c3:	e9 93 00 00 00       	jmp    85b <floppy_disk_seek+0xba>
	{
		_FloppyDiskIRQ = 0;
 7c8:	c6 05 01 00 00 00 00 	movb   $0x0,0x1


		floppy_disk_send_command(FDC_CMD_SEEK);
 7cf:	83 ec 0c             	sub    $0xc,%esp
 7d2:	6a 0f                	push   $0xf
 7d4:	e8 fc ff ff ff       	call   7d5 <floppy_disk_seek+0x34>
 7d9:	83 c4 10             	add    $0x10,%esp
		floppy_disk_send_command((head) << 2 | _CurrentDrive);
 7dc:	8b 45 0c             	mov    0xc(%ebp),%eax
 7df:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 7e6:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 7ed:	09 d0                	or     %edx,%eax
 7ef:	0f b6 c0             	movzbl %al,%eax
 7f2:	83 ec 0c             	sub    $0xc,%esp
 7f5:	50                   	push   %eax
 7f6:	e8 fc ff ff ff       	call   7f7 <floppy_disk_seek+0x56>
 7fb:	83 c4 10             	add    $0x10,%esp
		floppy_disk_send_command(cyl);
 7fe:	8b 45 08             	mov    0x8(%ebp),%eax
 801:	0f b6 c0             	movzbl %al,%eax
 804:	83 ec 0c             	sub    $0xc,%esp
 807:	50                   	push   %eax
 808:	e8 fc ff ff ff       	call   809 <floppy_disk_seek+0x68>
 80d:	83 c4 10             	add    $0x10,%esp



		printf("Waiting for SEEK irq fire\n");
 810:	83 ec 0c             	sub    $0xc,%esp
 813:	68 a1 00 00 00       	push   $0xa1
 818:	e8 fc ff ff ff       	call   819 <floppy_disk_seek+0x78>
 81d:	83 c4 10             	add    $0x10,%esp

		// Wait for results
		floppy_disk_wait_irq();
 820:	e8 fc ff ff ff       	call   821 <floppy_disk_seek+0x80>

		printf("Got SEEK irq\n");
 825:	83 ec 0c             	sub    $0xc,%esp
 828:	68 bc 00 00 00       	push   $0xbc
 82d:	e8 fc ff ff ff       	call   82e <floppy_disk_seek+0x8d>
 832:	83 c4 10             	add    $0x10,%esp

		floppy_disk_check_int(&st0, &cyl0);
 835:	83 ec 08             	sub    $0x8,%esp
 838:	8d 45 ec             	lea    -0x14(%ebp),%eax
 83b:	50                   	push   %eax
 83c:	8d 45 f0             	lea    -0x10(%ebp),%eax
 83f:	50                   	push   %eax
 840:	e8 fc ff ff ff       	call   841 <floppy_disk_seek+0xa0>
 845:	83 c4 10             	add    $0x10,%esp

		// Have we found the cylinder?
		if (cyl == cyl0)
 848:	8b 45 ec             	mov    -0x14(%ebp),%eax
 84b:	39 45 08             	cmp    %eax,0x8(%ebp)
 84e:	75 07                	jne    857 <floppy_disk_seek+0xb6>
		{
			return FLOPPY_GOOD;
 850:	b8 00 00 00 00       	mov    $0x0,%eax
 855:	eb 13                	jmp    86a <floppy_disk_seek+0xc9>
	if (_CurrentDrive >= 4)
	{
		return FLOPPY_INVALID_DRIVE;
	}

	for (int i = 0; i < 10; ++i)
 857:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 85b:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
 85f:	0f 8e 63 ff ff ff    	jle    7c8 <floppy_disk_seek+0x27>
		if (cyl == cyl0)
		{
			return FLOPPY_GOOD;
		}
	}
	return FLOPPY_BAD;
 865:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 86a:	c9                   	leave  
 86b:	c3                   	ret    

0000086c <floppy_disk_set_dma>:
// =====================================
// Public functions
// =====================================

void floppy_disk_set_dma(const int addr) 
{
 86c:	55                   	push   %ebp
 86d:	89 e5                	mov    %esp,%ebp
	DMA_BUFFER = addr;
 86f:	8b 45 08             	mov    0x8(%ebp),%eax
 872:	a3 00 00 00 00       	mov    %eax,0x0
}
 877:	90                   	nop
 878:	5d                   	pop    %ebp
 879:	c3                   	ret    

0000087a <floppy_disk_install>:

void floppy_disk_install(const int irq)
{
 87a:	55                   	push   %ebp
 87b:	89 e5                	mov    %esp,%ebp
 87d:	83 ec 08             	sub    $0x8,%esp
	// Install IRQ handler
	setvect(irq, i86_floppy_irq);
 880:	83 ec 08             	sub    $0x8,%esp
 883:	68 00 00 00 00       	push   $0x0
 888:	ff 75 08             	pushl  0x8(%ebp)
 88b:	e8 fc ff ff ff       	call   88c <floppy_disk_install+0x12>
 890:	83 c4 10             	add    $0x10,%esp

	// Reset floppy disk
	floppy_disk_reset();
 893:	e8 fc ff ff ff       	call   894 <floppy_disk_install+0x1a>

	// Set drive information
	floppy_disk_configure_drive(13, 1, 0xF, 1);
 898:	6a 01                	push   $0x1
 89a:	6a 0f                	push   $0xf
 89c:	6a 01                	push   $0x1
 89e:	6a 0d                	push   $0xd
 8a0:	e8 fc ff ff ff       	call   8a1 <floppy_disk_install+0x27>
 8a5:	83 c4 10             	add    $0x10,%esp
}
 8a8:	90                   	nop
 8a9:	c9                   	leave  
 8aa:	c3                   	ret    

000008ab <floppy_disk_set_working_drive>:

void floppy_disk_set_working_drive(const uint8_t drive)
{
 8ab:	55                   	push   %ebp
 8ac:	89 e5                	mov    %esp,%ebp
 8ae:	83 ec 04             	sub    $0x4,%esp
 8b1:	8b 45 08             	mov    0x8(%ebp),%eax
 8b4:	88 45 fc             	mov    %al,-0x4(%ebp)
	if (drive < 4)
 8b7:	80 7d fc 03          	cmpb   $0x3,-0x4(%ebp)
 8bb:	77 09                	ja     8c6 <floppy_disk_set_working_drive+0x1b>
	{
		_CurrentDrive = drive;
 8bd:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 8c1:	a2 00 00 00 00       	mov    %al,0x0
	}
}
 8c6:	90                   	nop
 8c7:	c9                   	leave  
 8c8:	c3                   	ret    

000008c9 <floppy_disk_get_working_drive>:

const uint8_t floppy_disk_get_working_drive()
{
 8c9:	55                   	push   %ebp
 8ca:	89 e5                	mov    %esp,%ebp
	return _CurrentDrive;
 8cc:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
}
 8d3:	5d                   	pop    %ebp
 8d4:	c3                   	ret    

000008d5 <floppy_disk_read_sector>:

const uint8_t* floppy_disk_read_sector(const int sectorLBA)
{
 8d5:	55                   	push   %ebp
 8d6:	89 e5                	mov    %esp,%ebp
 8d8:	83 ec 18             	sub    $0x18,%esp
	// Sanity check

	if (_CurrentDrive >= 4)
 8db:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 8e2:	3c 03                	cmp    $0x3,%al
 8e4:	76 0a                	jbe    8f0 <floppy_disk_read_sector+0x1b>
	{
		return 0;
 8e6:	b8 00 00 00 00       	mov    $0x0,%eax
 8eb:	e9 8b 00 00 00       	jmp    97b <floppy_disk_read_sector+0xa6>
	}

	// Convert LBA sector to CHS
	int head = 0;
 8f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int track = 0;
 8f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int sector = 1;
 8fe:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	floppy_disk_lba_to_chs(sectorLBA, &head, &track, &sector);
 905:	8d 45 ec             	lea    -0x14(%ebp),%eax
 908:	50                   	push   %eax
 909:	8d 45 f0             	lea    -0x10(%ebp),%eax
 90c:	50                   	push   %eax
 90d:	8d 45 f4             	lea    -0xc(%ebp),%eax
 910:	50                   	push   %eax
 911:	ff 75 08             	pushl  0x8(%ebp)
 914:	e8 fc ff ff ff       	call   915 <floppy_disk_read_sector+0x40>
 919:	83 c4 10             	add    $0x10,%esp


	//Turn on motor and seek track
	floppy_disk_set_motor(1);
 91c:	83 ec 0c             	sub    $0xc,%esp
 91f:	6a 01                	push   $0x1
 921:	e8 fc ff ff ff       	call   922 <floppy_disk_read_sector+0x4d>
 926:	83 c4 10             	add    $0x10,%esp
	if (floppy_disk_seek(track, head) != 0)
 929:	8b 45 f4             	mov    -0xc(%ebp),%eax
 92c:	89 c2                	mov    %eax,%edx
 92e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 931:	83 ec 08             	sub    $0x8,%esp
 934:	52                   	push   %edx
 935:	50                   	push   %eax
 936:	e8 fc ff ff ff       	call   937 <floppy_disk_read_sector+0x62>
 93b:	83 c4 10             	add    $0x10,%esp
 93e:	85 c0                	test   %eax,%eax
 940:	74 07                	je     949 <floppy_disk_read_sector+0x74>
	{
		return 0;
 942:	b8 00 00 00 00       	mov    $0x0,%eax
 947:	eb 32                	jmp    97b <floppy_disk_read_sector+0xa6>
	}

	// Read sector and turn motor off
	floppy_disk_read_sector_imp(head, track, sector);
 949:	8b 45 ec             	mov    -0x14(%ebp),%eax
 94c:	0f b6 c8             	movzbl %al,%ecx
 94f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 952:	0f b6 d0             	movzbl %al,%edx
 955:	8b 45 f4             	mov    -0xc(%ebp),%eax
 958:	0f b6 c0             	movzbl %al,%eax
 95b:	83 ec 04             	sub    $0x4,%esp
 95e:	51                   	push   %ecx
 95f:	52                   	push   %edx
 960:	50                   	push   %eax
 961:	e8 fc ff ff ff       	call   962 <floppy_disk_read_sector+0x8d>
 966:	83 c4 10             	add    $0x10,%esp
	floppy_disk_set_motor(0);
 969:	83 ec 0c             	sub    $0xc,%esp
 96c:	6a 00                	push   $0x0
 96e:	e8 fc ff ff ff       	call   96f <floppy_disk_read_sector+0x9a>
 973:	83 c4 10             	add    $0x10,%esp

	// Return ptr to dma buffer (maybe we should malloc a buffer and place it 
	// there)
	return (const uint8_t*)DMA_BUFFER;
 976:	a1 00 00 00 00       	mov    0x0,%eax
}
 97b:	c9                   	leave  
 97c:	c3                   	ret    

0000097d <floppy_disk_write_sector>:

void floppy_disk_write_sector(const uint8_t* buffer, const int sectorLBA)
{
 97d:	55                   	push   %ebp
 97e:	89 e5                	mov    %esp,%ebp
 980:	83 ec 18             	sub    $0x18,%esp
	// Sanity check
	if (_CurrentDrive >= 4)
 983:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 98a:	3c 03                	cmp    $0x3,%al
 98c:	0f 87 9b 00 00 00    	ja     a2d <floppy_disk_write_sector+0xb0>
	{
		return;
	}

	// Copy data to dma
	memcpy((void*)DMA_BUFFER, buffer, 512);
 992:	a1 00 00 00 00       	mov    0x0,%eax
 997:	83 ec 04             	sub    $0x4,%esp
 99a:	68 00 02 00 00       	push   $0x200
 99f:	ff 75 08             	pushl  0x8(%ebp)
 9a2:	50                   	push   %eax
 9a3:	e8 fc ff ff ff       	call   9a4 <floppy_disk_write_sector+0x27>
 9a8:	83 c4 10             	add    $0x10,%esp

	// Convert LBA sector to CHS
	int head = 0;
 9ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int track = 0;
 9b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int sector = 1;
 9b9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	floppy_disk_lba_to_chs(sectorLBA, &head, &track, &sector);
 9c0:	8d 45 ec             	lea    -0x14(%ebp),%eax
 9c3:	50                   	push   %eax
 9c4:	8d 45 f0             	lea    -0x10(%ebp),%eax
 9c7:	50                   	push   %eax
 9c8:	8d 45 f4             	lea    -0xc(%ebp),%eax
 9cb:	50                   	push   %eax
 9cc:	ff 75 0c             	pushl  0xc(%ebp)
 9cf:	e8 fc ff ff ff       	call   9d0 <floppy_disk_write_sector+0x53>
 9d4:	83 c4 10             	add    $0x10,%esp


	//Turn on motor and seek track
	floppy_disk_set_motor(1);
 9d7:	83 ec 0c             	sub    $0xc,%esp
 9da:	6a 01                	push   $0x1
 9dc:	e8 fc ff ff ff       	call   9dd <floppy_disk_write_sector+0x60>
 9e1:	83 c4 10             	add    $0x10,%esp
	if (floppy_disk_seek(track, head) != 0)
 9e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 9e7:	89 c2                	mov    %eax,%edx
 9e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 9ec:	83 ec 08             	sub    $0x8,%esp
 9ef:	52                   	push   %edx
 9f0:	50                   	push   %eax
 9f1:	e8 fc ff ff ff       	call   9f2 <floppy_disk_write_sector+0x75>
 9f6:	83 c4 10             	add    $0x10,%esp
 9f9:	85 c0                	test   %eax,%eax
 9fb:	75 33                	jne    a30 <floppy_disk_write_sector+0xb3>
	{
		return;
	}

	// Write sector and turn motor off
	floppy_disk_write_sector_imp(head, track, sector);
 9fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 a00:	0f b6 c8             	movzbl %al,%ecx
 a03:	8b 45 f0             	mov    -0x10(%ebp),%eax
 a06:	0f b6 d0             	movzbl %al,%edx
 a09:	8b 45 f4             	mov    -0xc(%ebp),%eax
 a0c:	0f b6 c0             	movzbl %al,%eax
 a0f:	83 ec 04             	sub    $0x4,%esp
 a12:	51                   	push   %ecx
 a13:	52                   	push   %edx
 a14:	50                   	push   %eax
 a15:	e8 fc ff ff ff       	call   a16 <floppy_disk_write_sector+0x99>
 a1a:	83 c4 10             	add    $0x10,%esp
	floppy_disk_set_motor(0);
 a1d:	83 ec 0c             	sub    $0xc,%esp
 a20:	6a 00                	push   $0x0
 a22:	e8 fc ff ff ff       	call   a23 <floppy_disk_write_sector+0xa6>
 a27:	83 c4 10             	add    $0x10,%esp

	return;
 a2a:	90                   	nop
 a2b:	eb 04                	jmp    a31 <floppy_disk_write_sector+0xb4>
void floppy_disk_write_sector(const uint8_t* buffer, const int sectorLBA)
{
	// Sanity check
	if (_CurrentDrive >= 4)
	{
		return;
 a2d:	90                   	nop
 a2e:	eb 01                	jmp    a31 <floppy_disk_write_sector+0xb4>

	//Turn on motor and seek track
	floppy_disk_set_motor(1);
	if (floppy_disk_seek(track, head) != 0)
	{
		return;
 a30:	90                   	nop
	// Write sector and turn motor off
	floppy_disk_write_sector_imp(head, track, sector);
	floppy_disk_set_motor(0);

	return;
}
 a31:	c9                   	leave  
 a32:	c3                   	ret    

00000a33 <floppy_disk_lba_to_chs>:

void floppy_disk_lba_to_chs(const int lba, int* head, int* track, int* sector)
{
 a33:	55                   	push   %ebp
 a34:	89 e5                	mov    %esp,%ebp
	*head = (lba % (FLOPPY_SECTORS_PER_TRACK * 2)) / (FLOPPY_SECTORS_PER_TRACK);
 a36:	b8 12 00 00 00       	mov    $0x12,%eax
 a3b:	8d 0c 00             	lea    (%eax,%eax,1),%ecx
 a3e:	8b 45 08             	mov    0x8(%ebp),%eax
 a41:	99                   	cltd   
 a42:	f7 f9                	idiv   %ecx
 a44:	89 d0                	mov    %edx,%eax
 a46:	b9 12 00 00 00       	mov    $0x12,%ecx
 a4b:	99                   	cltd   
 a4c:	f7 f9                	idiv   %ecx
 a4e:	89 c2                	mov    %eax,%edx
 a50:	8b 45 0c             	mov    0xc(%ebp),%eax
 a53:	89 10                	mov    %edx,(%eax)
	*track = lba / (FLOPPY_SECTORS_PER_TRACK * 2);
 a55:	b8 12 00 00 00       	mov    $0x12,%eax
 a5a:	8d 0c 00             	lea    (%eax,%eax,1),%ecx
 a5d:	8b 45 08             	mov    0x8(%ebp),%eax
 a60:	99                   	cltd   
 a61:	f7 f9                	idiv   %ecx
 a63:	89 c2                	mov    %eax,%edx
 a65:	8b 45 10             	mov    0x10(%ebp),%eax
 a68:	89 10                	mov    %edx,(%eax)
	*sector = lba % FLOPPY_SECTORS_PER_TRACK + 1;
 a6a:	b9 12 00 00 00       	mov    $0x12,%ecx
 a6f:	8b 45 08             	mov    0x8(%ebp),%eax
 a72:	99                   	cltd   
 a73:	f7 f9                	idiv   %ecx
 a75:	89 d0                	mov    %edx,%eax
 a77:	8d 50 01             	lea    0x1(%eax),%edx
 a7a:	8b 45 14             	mov    0x14(%ebp),%eax
 a7d:	89 10                	mov    %edx,(%eax)
 a7f:	90                   	nop
 a80:	5d                   	pop    %ebp
 a81:	c3                   	ret    

flush.o:     file format elf32-i386


Disassembly of section .text:

00000000 <gdt_flush>:
   0:	8b 44 24 04          	mov    0x4(%esp),%eax
   4:	0f 01 10             	lgdtl  (%eax)

00000007 <gdt_flush.flush>:
   7:	c3                   	ret    

00000008 <idt_flush>:
   8:	8b 44 24 04          	mov    0x4(%esp),%eax
   c:	0f 01 18             	lidtl  (%eax)
   f:	c3                   	ret    

gdt.o:     file format elf32-i386


Disassembly of section .text:

00000000 <gdt_set_descriptor>:
void gdt_set_descriptor(
	uint32_t i, 
	uint64_t base, 
	uint64_t limit, 
	uint8_t access, 
	uint8_t gran){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
   6:	8b 55 1c             	mov    0x1c(%ebp),%edx
   9:	8b 45 20             	mov    0x20(%ebp),%eax
   c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   f:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  12:	8b 4d 10             	mov    0x10(%ebp),%ecx
  15:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  18:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1b:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1e:	8b 4d 18             	mov    0x18(%ebp),%ecx
  21:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  24:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  27:	88 45 e0             	mov    %al,-0x20(%ebp)

	if(i > MAX_DESCRIPTORS)
  2a:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
  2e:	0f 87 bb 00 00 00    	ja     ef <gdt_set_descriptor+0xef>
		return;

	// Set memory to 0
	memset((void*)&_gdt[i],0,sizeof(gdt_descriptor));
  34:	8b 45 08             	mov    0x8(%ebp),%eax
  37:	c1 e0 03             	shl    $0x3,%eax
  3a:	05 00 00 00 00       	add    $0x0,%eax
  3f:	83 ec 04             	sub    $0x4,%esp
  42:	6a 08                	push   $0x8
  44:	6a 00                	push   $0x0
  46:	50                   	push   %eax
  47:	e8 fc ff ff ff       	call   48 <gdt_set_descriptor+0x48>
  4c:	83 c4 10             	add    $0x10,%esp

	// set limit and base addresses
	_gdt[i].baseLo	= (uint16_t)(base & 0xffff);
  4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  52:	89 c2                	mov    %eax,%edx
  54:	8b 45 08             	mov    0x8(%ebp),%eax
  57:	66 89 14 c5 02 00 00 	mov    %dx,0x2(,%eax,8)
  5e:	00 
	_gdt[i].baseMid	= (uint8_t)((base >> 16) & 0xff);
  5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  62:	8b 55 f4             	mov    -0xc(%ebp),%edx
  65:	0f ac d0 10          	shrd   $0x10,%edx,%eax
  69:	c1 ea 10             	shr    $0x10,%edx
  6c:	89 c2                	mov    %eax,%edx
  6e:	8b 45 08             	mov    0x8(%ebp),%eax
  71:	88 14 c5 04 00 00 00 	mov    %dl,0x4(,%eax,8)
	_gdt[i].baseHi	= (uint8_t)((base >> 24) & 0xff);
  78:	8b 45 f0             	mov    -0x10(%ebp),%eax
  7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  7e:	0f ac d0 18          	shrd   $0x18,%edx,%eax
  82:	c1 ea 18             	shr    $0x18,%edx
  85:	89 c2                	mov    %eax,%edx
  87:	8b 45 08             	mov    0x8(%ebp),%eax
  8a:	88 14 c5 07 00 00 00 	mov    %dl,0x7(,%eax,8)
	_gdt[i].limit	= (uint16_t)(limit & 0xffff);
  91:	8b 45 e8             	mov    -0x18(%ebp),%eax
  94:	89 c2                	mov    %eax,%edx
  96:	8b 45 08             	mov    0x8(%ebp),%eax
  99:	66 89 14 c5 00 00 00 	mov    %dx,0x0(,%eax,8)
  a0:	00 

	// set flags and granularity bytes
	_gdt[i].flags = access;
  a1:	8b 45 08             	mov    0x8(%ebp),%eax
  a4:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
  a8:	88 14 c5 05 00 00 00 	mov    %dl,0x5(,%eax,8)
	_gdt[i].granularity = (uint8_t)((limit >> 16) & 0x0f);
  af:	8b 45 e8             	mov    -0x18(%ebp),%eax
  b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
  b5:	0f ac d0 10          	shrd   $0x10,%edx,%eax
  b9:	c1 ea 10             	shr    $0x10,%edx
  bc:	83 e0 0f             	and    $0xf,%eax
  bf:	89 c2                	mov    %eax,%edx
  c1:	8b 45 08             	mov    0x8(%ebp),%eax
  c4:	88 14 c5 06 00 00 00 	mov    %dl,0x6(,%eax,8)
	_gdt[i].granularity |= gran & 0xf0;
  cb:	8b 45 08             	mov    0x8(%ebp),%eax
  ce:	0f b6 04 c5 06 00 00 	movzbl 0x6(,%eax,8),%eax
  d5:	00 
  d6:	89 c2                	mov    %eax,%edx
  d8:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  dc:	83 e0 f0             	and    $0xfffffff0,%eax
  df:	09 d0                	or     %edx,%eax
  e1:	89 c2                	mov    %eax,%edx
  e3:	8b 45 08             	mov    0x8(%ebp),%eax
  e6:	88 14 c5 06 00 00 00 	mov    %dl,0x6(,%eax,8)
  ed:	eb 01                	jmp    f0 <gdt_set_descriptor+0xf0>
	uint64_t limit, 
	uint8_t access, 
	uint8_t gran){

	if(i > MAX_DESCRIPTORS)
		return;
  ef:	90                   	nop

	// set flags and granularity bytes
	_gdt[i].flags = access;
	_gdt[i].granularity = (uint8_t)((limit >> 16) & 0x0f);
	_gdt[i].granularity |= gran & 0xf0;
}
  f0:	c9                   	leave  
  f1:	c3                   	ret    

000000f2 <i86_gdt_get_descriptor>:

gdt_descriptor* i86_gdt_get_descriptor(int i){
  f2:	55                   	push   %ebp
  f3:	89 e5                	mov    %esp,%ebp
	if(i > MAX_DESCRIPTORS)
  f5:	8b 45 08             	mov    0x8(%ebp),%eax
  f8:	83 f8 03             	cmp    $0x3,%eax
  fb:	76 07                	jbe    104 <i86_gdt_get_descriptor+0x12>
		return 0;
  fd:	b8 00 00 00 00       	mov    $0x0,%eax
 102:	eb 0b                	jmp    10f <i86_gdt_get_descriptor+0x1d>

	return &_gdt[i];
 104:	8b 45 08             	mov    0x8(%ebp),%eax
 107:	c1 e0 03             	shl    $0x3,%eax
 10a:	05 00 00 00 00       	add    $0x0,%eax
}
 10f:	5d                   	pop    %ebp
 110:	c3                   	ret    

00000111 <i86_gdt_initialize>:

int i86_gdt_initialize(){
 111:	55                   	push   %ebp
 112:	89 e5                	mov    %esp,%ebp
 114:	83 ec 08             	sub    $0x8,%esp

	// set up gdtr
	_gdtr.m_limit = (uint16_t)((sizeof(gdt_descriptor) * MAX_DESCRIPTORS)-1);
 117:	66 c7 05 00 00 00 00 	movw   $0x17,0x0
 11e:	17 00 
	_gdtr.m_base = (uint32_t)&_gdt[0];
 120:	b8 00 00 00 00       	mov    $0x0,%eax
 125:	a3 02 00 00 00       	mov    %eax,0x2

	// set null descriptor
	gdt_set_descriptor(0, 0, 0, 0, 0);
 12a:	83 ec 04             	sub    $0x4,%esp
 12d:	6a 00                	push   $0x0
 12f:	6a 00                	push   $0x0
 131:	6a 00                	push   $0x0
 133:	6a 00                	push   $0x0
 135:	6a 00                	push   $0x0
 137:	6a 00                	push   $0x0
 139:	6a 00                	push   $0x0
 13b:	e8 fc ff ff ff       	call   13c <i86_gdt_initialize+0x2b>
 140:	83 c4 20             	add    $0x20,%esp

	// set default code descriptor
	gdt_set_descriptor (1,0,0xffffffff,
 143:	83 ec 04             	sub    $0x4,%esp
 146:	68 cf 00 00 00       	push   $0xcf
 14b:	68 9a 00 00 00       	push   $0x9a
 150:	6a 00                	push   $0x0
 152:	6a ff                	push   $0xffffffff
 154:	6a 00                	push   $0x0
 156:	6a 00                	push   $0x0
 158:	6a 01                	push   $0x1
 15a:	e8 fc ff ff ff       	call   15b <i86_gdt_initialize+0x4a>
 15f:	83 c4 20             	add    $0x20,%esp
		I86_GDT_GRAN_32BIT | 
		I86_GDT_GRAN_LIMITHI
		);

	// set default data descriptor
	gdt_set_descriptor (2,0,0xffffffff,
 162:	83 ec 04             	sub    $0x4,%esp
 165:	68 cf 00 00 00       	push   $0xcf
 16a:	68 92 00 00 00       	push   $0x92
 16f:	6a 00                	push   $0x0
 171:	6a ff                	push   $0xffffffff
 173:	6a 00                	push   $0x0
 175:	6a 00                	push   $0x0
 177:	6a 02                	push   $0x2
 179:	e8 fc ff ff ff       	call   17a <i86_gdt_initialize+0x69>
 17e:	83 c4 20             	add    $0x20,%esp
		I86_GDT_GRAN_32BIT | 
		I86_GDT_GRAN_LIMITHI
		);

	// install gdtr
	gdt_flush ((uint32_t)&_gdtr);
 181:	b8 00 00 00 00       	mov    $0x0,%eax
 186:	83 ec 0c             	sub    $0xc,%esp
 189:	50                   	push   %eax
 18a:	e8 fc ff ff ff       	call   18b <i86_gdt_initialize+0x7a>
 18f:	83 c4 10             	add    $0x10,%esp

	return 0;
 192:	b8 00 00 00 00       	mov    $0x0,%eax
 197:	c9                   	leave  
 198:	c3                   	ret    

getch.o:     file format elf32-i386


Disassembly of section .text:

00000000 <getch>:
#include <lib/stdio.h>

KEYCODE	getch () {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 18             	sub    $0x18,%esp

	KEYCODE key = KEY_UNKNOWN;
   6:	c7 45 f4 12 40 00 00 	movl   $0x4012,-0xc(%ebp)

	//! wait for a keypress
	while (key==KEY_UNKNOWN)
   d:	eb 08                	jmp    17 <getch+0x17>
		key = keyboard_get_last_key ();
   f:	e8 fc ff ff ff       	call   10 <getch+0x10>
  14:	89 45 f4             	mov    %eax,-0xc(%ebp)
KEYCODE	getch () {

	KEYCODE key = KEY_UNKNOWN;

	//! wait for a keypress
	while (key==KEY_UNKNOWN)
  17:	81 7d f4 12 40 00 00 	cmpl   $0x4012,-0xc(%ebp)
  1e:	74 ef                	je     f <getch+0xf>
		key = keyboard_get_last_key ();

	//! discard last keypress (we handled it) and return
	keyboard_discard_last_key ();
  20:	e8 fc ff ff ff       	call   21 <getch+0x21>

	return key;
  25:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28:	c9                   	leave  
  29:	c3                   	ret    

getCursor.o:     file format elf32-i386


Disassembly of section .text:

00000000 <getCursor>:
#include <lib/stdio.h>
#include <monitor/monitor.h>

void getCursor(uint32_t* x, uint32_t* y){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	monitor_getCursor(x, y);
   6:	83 ec 08             	sub    $0x8,%esp
   9:	ff 75 0c             	pushl  0xc(%ebp)
   c:	ff 75 08             	pushl  0x8(%ebp)
   f:	e8 fc ff ff ff       	call   10 <getCursor+0x10>
  14:	83 c4 10             	add    $0x10,%esp
  17:	90                   	nop
  18:	c9                   	leave  
  19:	c3                   	ret    

hal.o:     file format elf32-i386


Disassembly of section .text:

00000000 <hal_initialize>:
#include <hal/pic.h>
#include <hal/pit.h>

#include <lib/stdio.h>

int hal_initialize(){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	i86_cpu_initialize();
   6:	e8 fc ff ff ff       	call   7 <hal_initialize+0x7>
	i86_pic_initialize(0x20, 0x28);
   b:	83 ec 08             	sub    $0x8,%esp
   e:	6a 28                	push   $0x28
  10:	6a 20                	push   $0x20
  12:	e8 fc ff ff ff       	call   13 <hal_initialize+0x13>
  17:	83 c4 10             	add    $0x10,%esp
	i86_pit_initialize();
  1a:	e8 fc ff ff ff       	call   1b <hal_initialize+0x1b>
	i86_pit_start_counter (100,I86_PIT_OCW_COUNTER_0, I86_PIT_OCW_MODE_SQUAREWAVEGEN);
  1f:	83 ec 04             	sub    $0x4,%esp
  22:	6a 06                	push   $0x6
  24:	6a 00                	push   $0x0
  26:	6a 64                	push   $0x64
  28:	e8 fc ff ff ff       	call   29 <hal_initialize+0x29>
  2d:	83 c4 10             	add    $0x10,%esp

	enable();
  30:	e8 fc ff ff ff       	call   31 <hal_initialize+0x31>

	return 0;
  35:	b8 00 00 00 00       	mov    $0x0,%eax
}
  3a:	c9                   	leave  
  3b:	c3                   	ret    

0000003c <hal_shutdown>:

int hal_shutdown(){
  3c:	55                   	push   %ebp
  3d:	89 e5                	mov    %esp,%ebp
  3f:	83 ec 08             	sub    $0x8,%esp
	i86_cpu_shutdown();
  42:	e8 fc ff ff ff       	call   43 <hal_shutdown+0x7>
	return 0;
  47:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4c:	c9                   	leave  
  4d:	c3                   	ret    

0000004e <interruptdone>:

void interruptdone(uint32_t intno){
  4e:	55                   	push   %ebp
  4f:	89 e5                	mov    %esp,%ebp
  51:	83 ec 08             	sub    $0x8,%esp
	// insure its a valid hardware irq
	if (intno > 16)
  54:	83 7d 08 10          	cmpl   $0x10,0x8(%ebp)
  58:	77 26                	ja     80 <interruptdone+0x32>
		return;

	// test if we need to send end-of-interrupt to second pic
	if (intno >= 8)
  5a:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  5e:	76 0f                	jbe    6f <interruptdone+0x21>
		i86_pic_send_command (I86_PIC_OCW2_MASK_EOI, 1);
  60:	83 ec 08             	sub    $0x8,%esp
  63:	6a 01                	push   $0x1
  65:	6a 20                	push   $0x20
  67:	e8 fc ff ff ff       	call   68 <interruptdone+0x1a>
  6c:	83 c4 10             	add    $0x10,%esp

	// always send end-of-interrupt to primary pic
	i86_pic_send_command (I86_PIC_OCW2_MASK_EOI, 0);
  6f:	83 ec 08             	sub    $0x8,%esp
  72:	6a 00                	push   $0x0
  74:	6a 20                	push   $0x20
  76:	e8 fc ff ff ff       	call   77 <interruptdone+0x29>
  7b:	83 c4 10             	add    $0x10,%esp
  7e:	eb 01                	jmp    81 <interruptdone+0x33>
}

void interruptdone(uint32_t intno){
	// insure its a valid hardware irq
	if (intno > 16)
		return;
  80:	90                   	nop
	if (intno >= 8)
		i86_pic_send_command (I86_PIC_OCW2_MASK_EOI, 1);

	// always send end-of-interrupt to primary pic
	i86_pic_send_command (I86_PIC_OCW2_MASK_EOI, 0);
}
  81:	c9                   	leave  
  82:	c3                   	ret    

00000083 <sound>:

void sound(uint32_t frequency){
  83:	55                   	push   %ebp
  84:	89 e5                	mov    %esp,%ebp
  86:	83 ec 08             	sub    $0x8,%esp
	outportb (0x61, 3 | (unsigned char)(frequency<<2) );
  89:	8b 45 08             	mov    0x8(%ebp),%eax
  8c:	c1 e0 02             	shl    $0x2,%eax
  8f:	83 c8 03             	or     $0x3,%eax
  92:	0f b6 c0             	movzbl %al,%eax
  95:	83 ec 08             	sub    $0x8,%esp
  98:	50                   	push   %eax
  99:	6a 61                	push   $0x61
  9b:	e8 fc ff ff ff       	call   9c <sound+0x19>
  a0:	83 c4 10             	add    $0x10,%esp
}
  a3:	90                   	nop
  a4:	c9                   	leave  
  a5:	c3                   	ret    

000000a6 <inportb>:


uint8_t inportb(uint16_t port){
  a6:	55                   	push   %ebp
  a7:	89 e5                	mov    %esp,%ebp
  a9:	83 ec 14             	sub    $0x14,%esp
  ac:	8b 45 08             	mov    0x8(%ebp),%eax
  af:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	uint8_t ret;
    asm volatile ( "in %1, %0"
  b3:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
  b7:	89 c2                	mov    %eax,%edx
  b9:	ec                   	in     (%dx),%al
  ba:	88 45 ff             	mov    %al,-0x1(%ebp)
                   : "=a"(ret)
                   : "Nd"(port) );
    return ret;
  bd:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
  c1:	c9                   	leave  
  c2:	c3                   	ret    

000000c3 <outportb>:

void outportb(uint16_t port, uint8_t value){
  c3:	55                   	push   %ebp
  c4:	89 e5                	mov    %esp,%ebp
  c6:	83 ec 08             	sub    $0x8,%esp
  c9:	8b 55 08             	mov    0x8(%ebp),%edx
  cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  cf:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
  d3:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile ( "out %0, %1" : : "a"(value), "Nd"(port) );
  d6:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  da:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
  de:	ee                   	out    %al,(%dx)
}
  df:	90                   	nop
  e0:	c9                   	leave  
  e1:	c3                   	ret    

000000e2 <inportw>:

uint16_t inportw(uint16_t port){
  e2:	55                   	push   %ebp
  e3:	89 e5                	mov    %esp,%ebp
  e5:	83 ec 14             	sub    $0x14,%esp
  e8:	8b 45 08             	mov    0x8(%ebp),%eax
  eb:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	uint16_t ret;
    asm volatile ( "in %1, %0"
  ef:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
  f3:	89 c2                	mov    %eax,%edx
  f5:	66 ed                	in     (%dx),%ax
  f7:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
                   : "=a"(ret)
                   : "Nd"(port) );
    return ret;
  fb:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
  ff:	c9                   	leave  
 100:	c3                   	ret    

00000101 <outportw>:

void outportw(uint16_t port, uint16_t value){
 101:	55                   	push   %ebp
 102:	89 e5                	mov    %esp,%ebp
 104:	83 ec 08             	sub    $0x8,%esp
 107:	8b 55 08             	mov    0x8(%ebp),%edx
 10a:	8b 45 0c             	mov    0xc(%ebp),%eax
 10d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
 111:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
	asm volatile ( "out %0, %1" : : "a"(value), "Nd"(port) );
 115:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
 119:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
 11d:	66 ef                	out    %ax,(%dx)
}
 11f:	90                   	nop
 120:	c9                   	leave  
 121:	c3                   	ret    

00000122 <inportl>:

uint32_t inportl(uint16_t port){
 122:	55                   	push   %ebp
 123:	89 e5                	mov    %esp,%ebp
 125:	83 ec 14             	sub    $0x14,%esp
 128:	8b 45 08             	mov    0x8(%ebp),%eax
 12b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	uint32_t ret;
    asm volatile ( "in %1, %0"
 12f:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
 133:	89 c2                	mov    %eax,%edx
 135:	ed                   	in     (%dx),%eax
 136:	89 45 fc             	mov    %eax,-0x4(%ebp)
                   : "=a"(ret)
                   : "Nd"(port) );
    return ret;
 139:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 13c:	c9                   	leave  
 13d:	c3                   	ret    

0000013e <outportl>:

void outportl(uint16_t port, uint32_t value){
 13e:	55                   	push   %ebp
 13f:	89 e5                	mov    %esp,%ebp
 141:	83 ec 04             	sub    $0x4,%esp
 144:	8b 45 08             	mov    0x8(%ebp),%eax
 147:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	asm volatile ( "out %0, %1" : : "a"(value), "Nd"(port) );
 14b:	8b 45 0c             	mov    0xc(%ebp),%eax
 14e:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
 152:	ef                   	out    %eax,(%dx)
}
 153:	90                   	nop
 154:	c9                   	leave  
 155:	c3                   	ret    

00000156 <enable>:

void enable(){
 156:	55                   	push   %ebp
 157:	89 e5                	mov    %esp,%ebp
	asm volatile("sti");
 159:	fb                   	sti    
}
 15a:	90                   	nop
 15b:	5d                   	pop    %ebp
 15c:	c3                   	ret    

0000015d <disable>:

void disable(){
 15d:	55                   	push   %ebp
 15e:	89 e5                	mov    %esp,%ebp
	asm volatile("cli");
 160:	fa                   	cli    
}
 161:	90                   	nop
 162:	5d                   	pop    %ebp
 163:	c3                   	ret    

00000164 <setvect>:

void setvect(int intno, irq_vect vect){
 164:	55                   	push   %ebp
 165:	89 e5                	mov    %esp,%ebp
 167:	83 ec 08             	sub    $0x8,%esp
	i86_install_ir (intno, I86_IDT_DESC_PRESENT | I86_IDT_DESC_BIT32,
 16a:	8b 45 08             	mov    0x8(%ebp),%eax
 16d:	ff 75 0c             	pushl  0xc(%ebp)
 170:	6a 08                	push   $0x8
 172:	68 8e 00 00 00       	push   $0x8e
 177:	50                   	push   %eax
 178:	e8 fc ff ff ff       	call   179 <setvect+0x15>
 17d:	83 c4 10             	add    $0x10,%esp
		0x8, vect);
}
 180:	90                   	nop
 181:	c9                   	leave  
 182:	c3                   	ret    

00000183 <getvect>:

void (*getvect(int intno))(){
 183:	55                   	push   %ebp
 184:	89 e5                	mov    %esp,%ebp
 186:	83 ec 18             	sub    $0x18,%esp
	// get the descriptor from the idt
	idt_descriptor* desc = i86_get_ir (intno);
 189:	8b 45 08             	mov    0x8(%ebp),%eax
 18c:	83 ec 0c             	sub    $0xc,%esp
 18f:	50                   	push   %eax
 190:	e8 fc ff ff ff       	call   191 <getvect+0xe>
 195:	83 c4 10             	add    $0x10,%esp
 198:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!desc)
 19b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 19f:	75 07                	jne    1a8 <getvect+0x25>
		return 0;
 1a1:	b8 00 00 00 00       	mov    $0x0,%eax
 1a6:	eb 24                	jmp    1cc <getvect+0x49>

	// get address of interrupt handler
	uint32_t addr = desc->baseLo | (desc->baseHi << 16);
 1a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1ab:	0f b7 00             	movzwl (%eax),%eax
 1ae:	0f b7 d0             	movzwl %ax,%edx
 1b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1b4:	0f b7 40 06          	movzwl 0x6(%eax),%eax
 1b8:	0f b7 c0             	movzwl %ax,%eax
 1bb:	c1 e0 10             	shl    $0x10,%eax
 1be:	09 d0                	or     %edx,%eax
 1c0:	89 45 f0             	mov    %eax,-0x10(%ebp)

	// return interrupt handler
	I86_IRQ_HANDLER irq = (I86_IRQ_HANDLER)addr;
 1c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 1c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return irq;
 1c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 1cc:	c9                   	leave  
 1cd:	c3                   	ret    

000001ce <get_cpu_vendor>:

const char* get_cpu_vendor(){
 1ce:	55                   	push   %ebp
 1cf:	89 e5                	mov    %esp,%ebp
 1d1:	83 ec 08             	sub    $0x8,%esp
	return i86_cpu_get_vendor();
 1d4:	e8 fc ff ff ff       	call   1d5 <get_cpu_vendor+0x7>
}
 1d9:	c9                   	leave  
 1da:	c3                   	ret    

000001db <get_tick_count>:

int get_tick_count(){
 1db:	55                   	push   %ebp
 1dc:	89 e5                	mov    %esp,%ebp
 1de:	83 ec 08             	sub    $0x8,%esp
	return i86_pit_get_tick_count();
 1e1:	e8 fc ff ff ff       	call   1e2 <get_tick_count+0x7>
 1e6:	c9                   	leave  
 1e7:	c3                   	ret    

idt.o:     file format elf32-i386


Disassembly of section .text:

00000000 <i86_default_handler>:
idt_descriptor _idt[I86_MAX_INTERRUPTS];
idtr _idtr;

static void i86_default_handler();

static void i86_default_handler(){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	puts("[I86 HAL] i86 default handler: Unhandled exception");
   6:	83 ec 0c             	sub    $0xc,%esp
   9:	68 00 00 00 00       	push   $0x0
   e:	e8 fc ff ff ff       	call   f <i86_default_handler+0xf>
  13:	83 c4 10             	add    $0x10,%esp

	for(;;);
  16:	eb fe                	jmp    16 <i86_default_handler+0x16>

00000018 <i86_get_ir>:
}

idt_descriptor* i86_get_ir(uint32_t i){
  18:	55                   	push   %ebp
  19:	89 e5                	mov    %esp,%ebp
	if(i > I86_MAX_INTERRUPTS)
  1b:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
  22:	76 07                	jbe    2b <i86_get_ir+0x13>
		return 0;
  24:	b8 00 00 00 00       	mov    $0x0,%eax
  29:	eb 0b                	jmp    36 <i86_get_ir+0x1e>

	return &_idt[i];
  2b:	8b 45 08             	mov    0x8(%ebp),%eax
  2e:	c1 e0 03             	shl    $0x3,%eax
  31:	05 00 00 00 00       	add    $0x0,%eax
}
  36:	5d                   	pop    %ebp
  37:	c3                   	ret    

00000038 <i86_install_ir>:

int i86_install_ir(uint32_t i, uint16_t flags, uint16_t sel, I86_IRQ_HANDLER irq){
  38:	55                   	push   %ebp
  39:	89 e5                	mov    %esp,%ebp
  3b:	83 ec 18             	sub    $0x18,%esp
  3e:	8b 55 0c             	mov    0xc(%ebp),%edx
  41:	8b 45 10             	mov    0x10(%ebp),%eax
  44:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
  48:	66 89 45 e8          	mov    %ax,-0x18(%ebp)

	if(i > I86_MAX_INTERRUPTS)
  4c:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
  53:	76 07                	jbe    5c <i86_install_ir+0x24>
		return 0;
  55:	b8 00 00 00 00       	mov    $0x0,%eax
  5a:	eb 70                	jmp    cc <i86_install_ir+0x94>

	if(!irq)
  5c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  60:	75 07                	jne    69 <i86_install_ir+0x31>
		return 0;
  62:	b8 00 00 00 00       	mov    $0x0,%eax
  67:	eb 63                	jmp    cc <i86_install_ir+0x94>

	uint64_t uiBase = (uint64_t)&(*irq);
  69:	8b 45 14             	mov    0x14(%ebp),%eax
  6c:	99                   	cltd   
  6d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  70:	89 55 fc             	mov    %edx,-0x4(%ebp)

	_idt[i].baseLo		=	(uint16_t)(uiBase & 0xffff);
  73:	8b 45 f8             	mov    -0x8(%ebp),%eax
  76:	89 c2                	mov    %eax,%edx
  78:	8b 45 08             	mov    0x8(%ebp),%eax
  7b:	66 89 14 c5 00 00 00 	mov    %dx,0x0(,%eax,8)
  82:	00 
	_idt[i].baseHi		=	(uint16_t)((uiBase >> 16) & 0xffff);
  83:	8b 45 f8             	mov    -0x8(%ebp),%eax
  86:	8b 55 fc             	mov    -0x4(%ebp),%edx
  89:	0f ac d0 10          	shrd   $0x10,%edx,%eax
  8d:	c1 ea 10             	shr    $0x10,%edx
  90:	89 c2                	mov    %eax,%edx
  92:	8b 45 08             	mov    0x8(%ebp),%eax
  95:	66 89 14 c5 06 00 00 	mov    %dx,0x6(,%eax,8)
  9c:	00 
	_idt[i].reserved	=	0;
  9d:	8b 45 08             	mov    0x8(%ebp),%eax
  a0:	c6 04 c5 04 00 00 00 	movb   $0x0,0x4(,%eax,8)
  a7:	00 
	_idt[i].flags		=	(uint8_t)(flags);
  a8:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
  ac:	89 c2                	mov    %eax,%edx
  ae:	8b 45 08             	mov    0x8(%ebp),%eax
  b1:	88 14 c5 05 00 00 00 	mov    %dl,0x5(,%eax,8)
	_idt[i].sel			=	sel;
  b8:	8b 45 08             	mov    0x8(%ebp),%eax
  bb:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
  bf:	66 89 14 c5 02 00 00 	mov    %dx,0x2(,%eax,8)
  c6:	00 

	return 0;
  c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  cc:	c9                   	leave  
  cd:	c3                   	ret    

000000ce <i86_idt_initialize>:

int i86_idt_initialize (uint16_t codeSel) {
  ce:	55                   	push   %ebp
  cf:	89 e5                	mov    %esp,%ebp
  d1:	83 ec 28             	sub    $0x28,%esp
  d4:	8b 45 08             	mov    0x8(%ebp),%eax
  d7:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)

	// set up idtr for processor
	_idtr.limit = sizeof (idt_descriptor) * I86_MAX_INTERRUPTS -1;
  db:	66 c7 05 00 00 00 00 	movw   $0x7ff,0x0
  e2:	ff 07 
	_idtr.base	= (uint32_t)&_idt[0];
  e4:	b8 00 00 00 00       	mov    $0x0,%eax
  e9:	a3 02 00 00 00       	mov    %eax,0x2

	// null out the idt
	memset ((void*)&_idt[0], 0, sizeof (idt_descriptor) * I86_MAX_INTERRUPTS-1);
  ee:	83 ec 04             	sub    $0x4,%esp
  f1:	68 ff 07 00 00       	push   $0x7ff
  f6:	6a 00                	push   $0x0
  f8:	68 00 00 00 00       	push   $0x0
  fd:	e8 fc ff ff ff       	call   fe <i86_idt_initialize+0x30>
 102:	83 c4 10             	add    $0x10,%esp

	// register default handlers
	for (int i=0; i<I86_MAX_INTERRUPTS; i++)
 105:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 10c:	eb 1f                	jmp    12d <i86_idt_initialize+0x5f>
		i86_install_ir (
 10e:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
 112:	8b 45 f4             	mov    -0xc(%ebp),%eax
 115:	68 00 00 00 00       	push   $0x0
 11a:	52                   	push   %edx
 11b:	68 8e 00 00 00       	push   $0x8e
 120:	50                   	push   %eax
 121:	e8 fc ff ff ff       	call   122 <i86_idt_initialize+0x54>
 126:	83 c4 10             	add    $0x10,%esp

	// null out the idt
	memset ((void*)&_idt[0], 0, sizeof (idt_descriptor) * I86_MAX_INTERRUPTS-1);

	// register default handlers
	for (int i=0; i<I86_MAX_INTERRUPTS; i++)
 129:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 12d:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
 134:	7e d8                	jle    10e <i86_idt_initialize+0x40>
			codeSel, 

			(I86_IRQ_HANDLER)i86_default_handler);

	// install our idt
	idt_flush ((uint32_t) &_idtr);
 136:	b8 00 00 00 00       	mov    $0x0,%eax
 13b:	83 ec 0c             	sub    $0xc,%esp
 13e:	50                   	push   %eax
 13f:	e8 fc ff ff ff       	call   140 <i86_idt_initialize+0x72>
 144:	83 c4 10             	add    $0x10,%esp

	return 0;
 147:	b8 00 00 00 00       	mov    $0x0,%eax
 14c:	c9                   	leave  
 14d:	c3                   	ret    

int32.o:     file format elf32-i386


Disassembly of section .text:

00000000 <_int32>:
   0:	fa                   	cli    
   1:	60                   	pusha  
   2:	be 19 00 00 00       	mov    $0x19,%esi
   7:	bf 00 7c 00 00       	mov    $0x7c00,%edi
   c:	b9 33 01 00 00       	mov    $0x133,%ecx
  11:	fc                   	cld    
  12:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  14:	e9 fc 7b 00 00       	jmp    7c15 <int32_end+0x7ac9>

00000019 <reloc>:
  19:	89 25 ef 7c 00 00    	mov    %esp,0x7cef
  1f:	0f 01 0d f3 7c 00 00 	sidtl  0x7cf3
  26:	0f 01 05 f9 7c 00 00 	sgdtl  0x7cf9
  2d:	0f 01 15 2d 7d 00 00 	lgdtl  0x7d2d
  34:	8d 74 24 24          	lea    0x24(%esp),%esi
  38:	ad                   	lods   %ds:(%esi),%eax
  39:	a2 6f 7c 00 00       	mov    %al,0x7c6f
  3e:	8b 36                	mov    (%esi),%esi
  40:	bf e6 7b 00 00       	mov    $0x7be6,%edi
  45:	b9 1a 00 00 00       	mov    $0x1a,%ecx
  4a:	89 fc                	mov    %edi,%esp
  4c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  4e:	66 ea 3b 7c 18 00    	ljmpw  $0x18,$0x7c3b

00000054 <p_mode16>:
  54:	b8 20 00 8e d8       	mov    $0xd88e0020,%eax
  59:	8e c0                	mov    %eax,%es
  5b:	8e e0                	mov    %eax,%fs
  5d:	8e e8                	mov    %eax,%gs
  5f:	8e d0                	mov    %eax,%ss
  61:	0f 20 c0             	mov    %cr0,%eax
  64:	24 fe                	and    $0xfe,%al
  66:	0f 22 c0             	mov    %eax,%cr0
  69:	ea 55 7c 00 00 31 c0 	ljmp   $0xc031,$0x7c55

0000006e <r_mode16>:
  6e:	31 c0                	xor    %eax,%eax
  70:	8e d8                	mov    %eax,%ds
  72:	8e d0                	mov    %eax,%ss
  74:	0f 01 1e             	lidtl  (%esi)
  77:	ff                   	(bad)  
  78:	7c bb                	jl     35 <reloc+0x1c>
  7a:	70 08                	jo     84 <r_mode16+0x16>
  7c:	e8 68 00 61 0f       	call   f6100e9 <int32_end+0xf60ff9d>
  81:	a9 0f a1 07 1f       	test   $0x1f07a10f,%eax
  86:	fb                   	sti    
  87:	cd 00                	int    $0x0

00000088 <ib>:
  88:	00 fa                	add    %bh,%dl
  8a:	31 e4                	xor    %esp,%esp
  8c:	8e d4                	mov    %esp,%ss
  8e:	bc 00 7c 9c 1e       	mov    $0x1e9c7c00,%esp
  93:	06                   	push   %es
  94:	0f a0                	push   %fs
  96:	0f a8                	push   %gs
  98:	60                   	pusha  
  99:	bb 28 20 e8 48       	mov    $0x48e82028,%ebx
  9e:	00 0f                	add    %cl,(%edi)
  a0:	20 c0                	and    %al,%al
  a2:	66 40                	inc    %ax
  a4:	0f 22 c0             	mov    %eax,%cr0
  a7:	66 ea 96 7c 00 00    	ljmpw  $0x0,$0x7c96
  ad:	08 00                	or     %al,(%eax)

000000af <p_mode32>:
  af:	66 b8 10 00          	mov    $0x10,%ax
  b3:	8e d8                	mov    %eax,%ds
  b5:	8e c0                	mov    %eax,%es
  b7:	8e e0                	mov    %eax,%fs
  b9:	8e e8                	mov    %eax,%gs
  bb:	8e d0                	mov    %eax,%ss
  bd:	0f 01 15 f9 7c 00 00 	lgdtl  0x7cf9
  c4:	0f 01 1d f3 7c 00 00 	lidtl  0x7cf3
  cb:	8b 25 ef 7c 00 00    	mov    0x7cef,%esp
  d1:	be e6 7b 00 00       	mov    $0x7be6,%esi
  d6:	8d 7c 24 28          	lea    0x28(%esp),%edi
  da:	8b 3f                	mov    (%edi),%edi
  dc:	b9 1a 00 00 00       	mov    $0x1a,%ecx
  e1:	fc                   	cld    
  e2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  e4:	61                   	popa   
  e5:	fb                   	sti    
  e6:	c3                   	ret    

000000e7 <resetpic>:
  e7:	66 50                	push   %ax
  e9:	b0 11                	mov    $0x11,%al
  eb:	e6 20                	out    %al,$0x20
  ed:	e6 a0                	out    %al,$0xa0
  ef:	88 f8                	mov    %bh,%al
  f1:	e6 21                	out    %al,$0x21
  f3:	88 d8                	mov    %bl,%al
  f5:	e6 a1                	out    %al,$0xa1
  f7:	b0 04                	mov    $0x4,%al
  f9:	e6 21                	out    %al,$0x21
  fb:	d0 e8                	shr    %al
  fd:	e6 a1                	out    %al,$0xa1
  ff:	d0 e8                	shr    %al
 101:	e6 21                	out    %al,$0x21
 103:	e6 a1                	out    %al,$0xa1
 105:	66 58                	pop    %ax
 107:	c3                   	ret    

00000108 <stack32_ptr>:
 108:	00 00                	add    %al,(%eax)
	...

0000010c <idt32_ptr>:
 10c:	00 00                	add    %al,(%eax)
 10e:	00 00                	add    %al,(%eax)
	...

00000112 <gdt32_ptr>:
 112:	00 00                	add    %al,(%eax)
 114:	00 00                	add    %al,(%eax)
	...

00000118 <idt16_ptr>:
 118:	ff 03                	incl   (%ebx)
 11a:	00 00                	add    %al,(%eax)
	...

0000011e <gdt16_base>:
	...

00000126 <gdt16_base.code32>:
 126:	ff                   	(bad)  
 127:	ff 00                	incl   (%eax)
 129:	00 00                	add    %al,(%eax)
 12b:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf

0000012e <gdt16_base.data32>:
 12e:	ff                   	(bad)  
 12f:	ff 00                	incl   (%eax)
 131:	00 00                	add    %al,(%eax)
 133:	92                   	xchg   %eax,%edx
 134:	cf                   	iret   
	...

00000136 <gdt16_base.code16>:
 136:	ff                   	(bad)  
 137:	ff 00                	incl   (%eax)
 139:	00 00                	add    %al,(%eax)
 13b:	9a 0f 00 ff ff 00 00 	lcall  $0x0,$0xffff000f

0000013e <gdt16_base.data16>:
 13e:	ff                   	(bad)  
 13f:	ff 00                	incl   (%eax)
 141:	00 00                	add    %al,(%eax)
 143:	92                   	xchg   %eax,%edx
 144:	0f 00 27             	verr   (%edi)

00000146 <gdt16_ptr>:
 146:	27                   	daa    
 147:	00 1e                	add    %bl,(%esi)
 149:	01 00                	add    %eax,(%eax)
	...

itoa.o:     file format elf32-i386


Disassembly of section .text:

00000000 <itoa>:
#include <lib/string.h>

char bchars[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

void itoa(uint32_t i, uint32_t base, char* buf){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 30             	sub    $0x30,%esp
	int pos = 0;
   6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int opos = 0;
   d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	int top = 0;
  14:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	char tbuf[32] = {0};
  1b:	b9 00 00 00 00       	mov    $0x0,%ecx
  20:	b8 20 00 00 00       	mov    $0x20,%eax
  25:	83 e0 fc             	and    $0xfffffffc,%eax
  28:	89 c2                	mov    %eax,%edx
  2a:	b8 00 00 00 00       	mov    $0x0,%eax
  2f:	89 4c 05 d4          	mov    %ecx,-0x2c(%ebp,%eax,1)
  33:	83 c0 04             	add    $0x4,%eax
  36:	39 d0                	cmp    %edx,%eax
  38:	72 f5                	jb     2f <itoa+0x2f>

	// Sanity check (we do only handle base up to 16)
	if(i == 0 || base > 16){
  3a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  3e:	74 06                	je     46 <itoa+0x46>
  40:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
  44:	76 41                	jbe    87 <itoa+0x87>
		buf[0] = '0';
  46:	8b 45 10             	mov    0x10(%ebp),%eax
  49:	c6 00 30             	movb   $0x30,(%eax)
		buf[1] = '\0';
  4c:	8b 45 10             	mov    0x10(%ebp),%eax
  4f:	83 c0 01             	add    $0x1,%eax
  52:	c6 00 00             	movb   $0x0,(%eax)
  55:	eb 7b                	jmp    d2 <itoa+0xd2>
		return;
	}

	while(i != 0){
		tbuf[pos] = bchars[i % base];
  57:	8b 45 08             	mov    0x8(%ebp),%eax
  5a:	ba 00 00 00 00       	mov    $0x0,%edx
  5f:	f7 75 0c             	divl   0xc(%ebp)
  62:	89 d0                	mov    %edx,%eax
  64:	0f b6 80 00 00 00 00 	movzbl 0x0(%eax),%eax
  6b:	8d 4d d4             	lea    -0x2c(%ebp),%ecx
  6e:	8b 55 fc             	mov    -0x4(%ebp),%edx
  71:	01 ca                	add    %ecx,%edx
  73:	88 02                	mov    %al,(%edx)
		pos++;
  75:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
		i /= base;
  79:	8b 45 08             	mov    0x8(%ebp),%eax
  7c:	ba 00 00 00 00       	mov    $0x0,%edx
  81:	f7 75 0c             	divl   0xc(%ebp)
  84:	89 45 08             	mov    %eax,0x8(%ebp)
		buf[0] = '0';
		buf[1] = '\0';
		return;
	}

	while(i != 0){
  87:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8b:	75 ca                	jne    57 <itoa+0x57>
		tbuf[pos] = bchars[i % base];
		pos++;
		i /= base;
	}

	top = pos--;
  8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  90:	8d 50 ff             	lea    -0x1(%eax),%edx
  93:	89 55 fc             	mov    %edx,-0x4(%ebp)
  96:	89 45 f4             	mov    %eax,-0xc(%ebp)

	for(opos = 0; opos<top; pos--, opos++){
  99:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  a0:	eb 1d                	jmp    bf <itoa+0xbf>
		buf[opos] = tbuf[pos];
  a2:	8b 55 f8             	mov    -0x8(%ebp),%edx
  a5:	8b 45 10             	mov    0x10(%ebp),%eax
  a8:	01 c2                	add    %eax,%edx
  aa:	8d 4d d4             	lea    -0x2c(%ebp),%ecx
  ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
  b0:	01 c8                	add    %ecx,%eax
  b2:	0f b6 00             	movzbl (%eax),%eax
  b5:	88 02                	mov    %al,(%edx)
		i /= base;
	}

	top = pos--;

	for(opos = 0; opos<top; pos--, opos++){
  b7:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  bb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  c2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  c5:	7c db                	jl     a2 <itoa+0xa2>
		buf[opos] = tbuf[pos];
	}

	buf[opos] = 0;
  c7:	8b 55 f8             	mov    -0x8(%ebp),%edx
  ca:	8b 45 10             	mov    0x10(%ebp),%eax
  cd:	01 d0                	add    %edx,%eax
  cf:	c6 00 00             	movb   $0x0,(%eax)

  d2:	c9                   	leave  
  d3:	c3                   	ret    

itoa_s.o:     file format elf32-i386


Disassembly of section .text:

00000000 <itoa_s>:
#include <lib/string.h>

void itoa_s(int32_t i, uint32_t base, char* buf){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	if(base > 16)
   6:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
   a:	77 2c                	ja     38 <itoa_s+0x38>
		return;

	if(i < 0){
   c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10:	79 0f                	jns    21 <itoa_s+0x21>
		*buf++ = '-';
  12:	8b 45 10             	mov    0x10(%ebp),%eax
  15:	8d 50 01             	lea    0x1(%eax),%edx
  18:	89 55 10             	mov    %edx,0x10(%ebp)
  1b:	c6 00 2d             	movb   $0x2d,(%eax)
		i*=-1;
  1e:	f7 5d 08             	negl   0x8(%ebp)
	}
	itoa(i, base, buf);
  21:	8b 45 08             	mov    0x8(%ebp),%eax
  24:	83 ec 04             	sub    $0x4,%esp
  27:	ff 75 10             	pushl  0x10(%ebp)
  2a:	ff 75 0c             	pushl  0xc(%ebp)
  2d:	50                   	push   %eax
  2e:	e8 fc ff ff ff       	call   2f <itoa_s+0x2f>
  33:	83 c4 10             	add    $0x10,%esp
  36:	eb 01                	jmp    39 <itoa_s+0x39>
#include <lib/string.h>

void itoa_s(int32_t i, uint32_t base, char* buf){
	if(base > 16)
		return;
  38:	90                   	nop
	if(i < 0){
		*buf++ = '-';
		i*=-1;
	}
	itoa(i, base, buf);
  39:	c9                   	leave  
  3a:	c3                   	ret    

kernel_heap.o:     file format elf32-i386


Disassembly of section .text:

00000000 <alignUp>:
int heap_grow(size_t size, uint8_t* heapEnd, int continuous);

void* kmalloc_imp(size_t size, uint32_t alignment, const char* comment);

uint32_t alignUp(uint32_t val, uint32_t alignment)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
	// Sanity Check
	if (!alignment)
   3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   7:	75 05                	jne    e <alignUp+0xe>
	{
		return val;
   9:	8b 45 08             	mov    0x8(%ebp),%eax
   c:	eb 13                	jmp    21 <alignUp+0x21>
	}

	--alignment;
   e:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)

	return (val + alignment) & ~alignment;
  12:	8b 55 08             	mov    0x8(%ebp),%edx
  15:	8b 45 0c             	mov    0xc(%ebp),%eax
  18:	01 c2                	add    %eax,%edx
  1a:	8b 45 0c             	mov    0xc(%ebp),%eax
  1d:	f7 d0                	not    %eax
  1f:	21 d0                	and    %edx,%eax
}
  21:	5d                   	pop    %ebp
  22:	c3                   	ret    

00000023 <alignDown>:

uint32_t alignDown(uint32_t val, uint32_t alignment)
{
  23:	55                   	push   %ebp
  24:	89 e5                	mov    %esp,%ebp
	// Sanity Check
	if (!alignment)
  26:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  2a:	75 05                	jne    31 <alignDown+0xe>
	{
		return val;
  2c:	8b 45 08             	mov    0x8(%ebp),%eax
  2f:	eb 08                	jmp    39 <alignDown+0x16>
	}

	return val & ~(alignment - 1);
  31:	8b 45 0c             	mov    0xc(%ebp),%eax
  34:	f7 d8                	neg    %eax
  36:	23 45 08             	and    0x8(%ebp),%eax
}
  39:	5d                   	pop    %ebp
  3a:	c3                   	ret    

0000003b <pmalloc>:

void* pmalloc(size_t size, uint32_t alignment)
{
  3b:	55                   	push   %ebp
  3c:	89 e5                	mov    %esp,%ebp
  3e:	83 ec 10             	sub    $0x10,%esp
	static uint8_t* nextPlacement = (uint8_t*)PLACEMENT_BEGIN;

	size = alignUp(size, 4);
  41:	6a 04                	push   $0x4
  43:	ff 75 08             	pushl  0x8(%ebp)
  46:	e8 fc ff ff ff       	call   47 <pmalloc+0xc>
  4b:	83 c4 08             	add    $0x8,%esp
  4e:	89 45 08             	mov    %eax,0x8(%ebp)

	uint8_t* currPlacement = (uint8_t*)alignUp((uint32_t)nextPlacement, alignment);
  51:	a1 08 00 00 00       	mov    0x8,%eax
  56:	ff 75 0c             	pushl  0xc(%ebp)
  59:	50                   	push   %eax
  5a:	e8 fc ff ff ff       	call   5b <pmalloc+0x20>
  5f:	83 c4 08             	add    $0x8,%esp
  62:	89 45 fc             	mov    %eax,-0x4(%ebp)

	if (((uint32_t)currPlacement + size) > PLACEMENT_END)
  65:	8b 55 fc             	mov    -0x4(%ebp),%edx
  68:	8b 45 08             	mov    0x8(%ebp),%eax
  6b:	01 d0                	add    %edx,%eax
  6d:	3d 00 00 20 d0       	cmp    $0xd0200000,%eax
  72:	76 07                	jbe    7b <pmalloc+0x40>
	{
		return 0;
  74:	b8 00 00 00 00       	mov    $0x0,%eax
  79:	eb 10                	jmp    8b <pmalloc+0x50>
	}

	nextPlacement = currPlacement + size;
  7b:	8b 55 fc             	mov    -0x4(%ebp),%edx
  7e:	8b 45 08             	mov    0x8(%ebp),%eax
  81:	01 d0                	add    %edx,%eax
  83:	a3 08 00 00 00       	mov    %eax,0x8

	return currPlacement;
  88:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  8b:	c9                   	leave  
  8c:	c3                   	ret    

0000008d <heap_grow>:

int heap_grow(size_t size, uint8_t* heapEnd, int continuous)
{
  8d:	55                   	push   %ebp
  8e:	89 e5                	mov    %esp,%ebp
  90:	53                   	push   %ebx
  91:	83 ec 14             	sub    $0x14,%esp
	printf("\n[heap_grow] Size:%i, Heap End: %#p, Continuous: %i", size, heapEnd, continuous);
  94:	ff 75 10             	pushl  0x10(%ebp)
  97:	ff 75 0c             	pushl  0xc(%ebp)
  9a:	ff 75 08             	pushl  0x8(%ebp)
  9d:	68 04 00 00 00       	push   $0x4
  a2:	e8 fc ff ff ff       	call   a3 <heap_grow+0x16>
  a7:	83 c4 10             	add    $0x10,%esp

	if ((regionCount > 0) && regions[regionCount - 1].reserved && (regionCount >= regionMaxCount))
  aa:	a1 04 00 00 00       	mov    0x4,%eax
  af:	85 c0                	test   %eax,%eax
  b1:	74 4c                	je     ff <heap_grow+0x72>
  b3:	8b 15 00 00 00 00    	mov    0x0,%edx
  b9:	a1 04 00 00 00       	mov    0x4,%eax
  be:	01 c0                	add    %eax,%eax
  c0:	89 c1                	mov    %eax,%ecx
  c2:	c1 e1 04             	shl    $0x4,%ecx
  c5:	29 c1                	sub    %eax,%ecx
  c7:	89 c8                	mov    %ecx,%eax
  c9:	83 e8 1e             	sub    $0x1e,%eax
  cc:	01 d0                	add    %edx,%eax
  ce:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  d2:	84 c0                	test   %al,%al
  d4:	74 29                	je     ff <heap_grow+0x72>
  d6:	8b 15 04 00 00 00    	mov    0x4,%edx
  dc:	a1 08 00 00 00       	mov    0x8,%eax
  e1:	39 c2                	cmp    %eax,%edx
  e3:	72 1a                	jb     ff <heap_grow+0x72>
	{
		printf("\nError1");
  e5:	83 ec 0c             	sub    $0xc,%esp
  e8:	68 38 00 00 00       	push   $0x38
  ed:	e8 fc ff ff ff       	call   ee <heap_grow+0x61>
  f2:	83 c4 10             	add    $0x10,%esp
		return 0;
  f5:	b8 00 00 00 00       	mov    $0x0,%eax
  fa:	e9 13 02 00 00       	jmp    312 <heap_grow+0x285>
	}

	uint32_t offset = 0;
  ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (offset < size)
 106:	eb 3f                	jmp    147 <heap_grow+0xba>
	{
		physical_addr addr = pmmngr_alloc_block();
 108:	e8 fc ff ff ff       	call   109 <heap_grow+0x7c>
 10d:	89 45 f0             	mov    %eax,-0x10(%ebp)

		printf("\nPhys. Addr: %#0(10)p", addr);
 110:	83 ec 08             	sub    $0x8,%esp
 113:	ff 75 f0             	pushl  -0x10(%ebp)
 116:	68 40 00 00 00       	push   $0x40
 11b:	e8 fc ff ff ff       	call   11c <heap_grow+0x8f>
 120:	83 c4 10             	add    $0x10,%esp

		vmmngr_mapPhysicalAddress(vmmngr_get_directory(), (uint32_t)heapEnd + offset, (uint32_t)addr, I86_PTE_PRESENT | I86_PTE_WRITABLE);
 123:	8b 55 0c             	mov    0xc(%ebp),%edx
 126:	8b 45 f4             	mov    -0xc(%ebp),%eax
 129:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
 12c:	e8 fc ff ff ff       	call   12d <heap_grow+0xa0>
 131:	6a 03                	push   $0x3
 133:	ff 75 f0             	pushl  -0x10(%ebp)
 136:	53                   	push   %ebx
 137:	50                   	push   %eax
 138:	e8 fc ff ff ff       	call   139 <heap_grow+0xac>
 13d:	83 c4 10             	add    $0x10,%esp

		//printf("\nMapping %#p", heapEnd + offset);

		offset += PAGE_SIZE;
 140:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
		return 0;
	}

	uint32_t offset = 0;

	while (offset < size)
 147:	8b 45 f4             	mov    -0xc(%ebp),%eax
 14a:	3b 45 08             	cmp    0x8(%ebp),%eax
 14d:	72 b9                	jb     108 <heap_grow+0x7b>
		//printf("\nMapping %#p", heapEnd + offset);

		offset += PAGE_SIZE;
	}

	printf("\nSize: %i", size);
 14f:	83 ec 08             	sub    $0x8,%esp
 152:	ff 75 08             	pushl  0x8(%ebp)
 155:	68 56 00 00 00       	push   $0x56
 15a:	e8 fc ff ff ff       	call   15b <heap_grow+0xce>
 15f:	83 c4 10             	add    $0x10,%esp

	if ((regionCount > 0) && !regions[regionCount - 1].reserved)
 162:	a1 04 00 00 00       	mov    0x4,%eax
 167:	85 c0                	test   %eax,%eax
 169:	74 67                	je     1d2 <heap_grow+0x145>
 16b:	8b 15 00 00 00 00    	mov    0x0,%edx
 171:	a1 04 00 00 00       	mov    0x4,%eax
 176:	01 c0                	add    %eax,%eax
 178:	89 c1                	mov    %eax,%ecx
 17a:	c1 e1 04             	shl    $0x4,%ecx
 17d:	29 c1                	sub    %eax,%ecx
 17f:	89 c8                	mov    %ecx,%eax
 181:	83 e8 1e             	sub    $0x1e,%eax
 184:	01 d0                	add    %edx,%eax
 186:	0f b6 40 08          	movzbl 0x8(%eax),%eax
 18a:	84 c0                	test   %al,%al
 18c:	75 44                	jne    1d2 <heap_grow+0x145>
	{
		regions[regionCount - 1].size += size;
 18e:	8b 15 00 00 00 00    	mov    0x0,%edx
 194:	a1 04 00 00 00       	mov    0x4,%eax
 199:	01 c0                	add    %eax,%eax
 19b:	89 c1                	mov    %eax,%ecx
 19d:	c1 e1 04             	shl    $0x4,%ecx
 1a0:	29 c1                	sub    %eax,%ecx
 1a2:	89 c8                	mov    %ecx,%eax
 1a4:	83 e8 1e             	sub    $0x1e,%eax
 1a7:	01 c2                	add    %eax,%edx
 1a9:	8b 0d 00 00 00 00    	mov    0x0,%ecx
 1af:	a1 04 00 00 00       	mov    0x4,%eax
 1b4:	01 c0                	add    %eax,%eax
 1b6:	89 c3                	mov    %eax,%ebx
 1b8:	c1 e3 04             	shl    $0x4,%ebx
 1bb:	29 c3                	sub    %eax,%ebx
 1bd:	89 d8                	mov    %ebx,%eax
 1bf:	83 e8 1e             	sub    $0x1e,%eax
 1c2:	01 c8                	add    %ecx,%eax
 1c4:	8b 08                	mov    (%eax),%ecx
 1c6:	8b 45 08             	mov    0x8(%ebp),%eax
 1c9:	01 c8                	add    %ecx,%eax
 1cb:	89 02                	mov    %eax,(%edx)
 1cd:	e9 2b 01 00 00       	jmp    2fd <heap_grow+0x270>
	}
	else
	{

		printf("\nSize: %i", size);
 1d2:	83 ec 08             	sub    $0x8,%esp
 1d5:	ff 75 08             	pushl  0x8(%ebp)
 1d8:	68 56 00 00 00       	push   $0x56
 1dd:	e8 fc ff ff ff       	call   1de <heap_grow+0x151>
 1e2:	83 c4 10             	add    $0x10,%esp

		printf("\n Region address: %#p", regions);
 1e5:	a1 00 00 00 00       	mov    0x0,%eax
 1ea:	83 ec 08             	sub    $0x8,%esp
 1ed:	50                   	push   %eax
 1ee:	68 60 00 00 00       	push   $0x60
 1f3:	e8 fc ff ff ff       	call   1f4 <heap_grow+0x167>
 1f8:	83 c4 10             	add    $0x10,%esp

		regions[regionCount].reserved = 0;
 1fb:	8b 15 00 00 00 00    	mov    0x0,%edx
 201:	a1 04 00 00 00       	mov    0x4,%eax
 206:	01 c0                	add    %eax,%eax
 208:	89 c1                	mov    %eax,%ecx
 20a:	c1 e1 04             	shl    $0x4,%ecx
 20d:	29 c1                	sub    %eax,%ecx
 20f:	89 c8                	mov    %ecx,%eax
 211:	01 d0                	add    %edx,%eax
 213:	c6 40 08 00          	movb   $0x0,0x8(%eax)
		regions[regionCount].size = size;
 217:	8b 15 00 00 00 00    	mov    0x0,%edx
 21d:	a1 04 00 00 00       	mov    0x4,%eax
 222:	01 c0                	add    %eax,%eax
 224:	89 c1                	mov    %eax,%ecx
 226:	c1 e1 04             	shl    $0x4,%ecx
 229:	29 c1                	sub    %eax,%ecx
 22b:	89 c8                	mov    %ecx,%eax
 22d:	01 c2                	add    %eax,%edx
 22f:	8b 45 08             	mov    0x8(%ebp),%eax
 232:	89 02                	mov    %eax,(%edx)
		regions[regionCount].number = 0;
 234:	8b 15 00 00 00 00    	mov    0x0,%edx
 23a:	a1 04 00 00 00       	mov    0x4,%eax
 23f:	01 c0                	add    %eax,%eax
 241:	89 c1                	mov    %eax,%ecx
 243:	c1 e1 04             	shl    $0x4,%ecx
 246:	29 c1                	sub    %eax,%ecx
 248:	89 c8                	mov    %ecx,%eax
 24a:	01 d0                	add    %edx,%eax
 24c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

		printf("\nNew Region: %i", regionCount);
 253:	a1 04 00 00 00       	mov    0x4,%eax
 258:	83 ec 08             	sub    $0x8,%esp
 25b:	50                   	push   %eax
 25c:	68 76 00 00 00       	push   $0x76
 261:	e8 fc ff ff ff       	call   262 <heap_grow+0x1d5>
 266:	83 c4 10             	add    $0x10,%esp
		printf("\nRegion reserved: %i",(uint32_t) regions[regionCount].reserved);
 269:	8b 15 00 00 00 00    	mov    0x0,%edx
 26f:	a1 04 00 00 00       	mov    0x4,%eax
 274:	01 c0                	add    %eax,%eax
 276:	89 c1                	mov    %eax,%ecx
 278:	c1 e1 04             	shl    $0x4,%ecx
 27b:	29 c1                	sub    %eax,%ecx
 27d:	89 c8                	mov    %ecx,%eax
 27f:	01 d0                	add    %edx,%eax
 281:	0f b6 40 08          	movzbl 0x8(%eax),%eax
 285:	0f b6 c0             	movzbl %al,%eax
 288:	83 ec 08             	sub    $0x8,%esp
 28b:	50                   	push   %eax
 28c:	68 86 00 00 00       	push   $0x86
 291:	e8 fc ff ff ff       	call   292 <heap_grow+0x205>
 296:	83 c4 10             	add    $0x10,%esp
		printf("\nRegion Size: %i", (uint32_t) regions[regionCount].size);
 299:	8b 15 00 00 00 00    	mov    0x0,%edx
 29f:	a1 04 00 00 00       	mov    0x4,%eax
 2a4:	01 c0                	add    %eax,%eax
 2a6:	89 c1                	mov    %eax,%ecx
 2a8:	c1 e1 04             	shl    $0x4,%ecx
 2ab:	29 c1                	sub    %eax,%ecx
 2ad:	89 c8                	mov    %ecx,%eax
 2af:	01 d0                	add    %edx,%eax
 2b1:	8b 00                	mov    (%eax),%eax
 2b3:	83 ec 08             	sub    $0x8,%esp
 2b6:	50                   	push   %eax
 2b7:	68 9b 00 00 00       	push   $0x9b
 2bc:	e8 fc ff ff ff       	call   2bd <heap_grow+0x230>
 2c1:	83 c4 10             	add    $0x10,%esp
		printf("\nRegion Number: %i", (uint32_t) regions[regionCount].number);
 2c4:	8b 15 00 00 00 00    	mov    0x0,%edx
 2ca:	a1 04 00 00 00       	mov    0x4,%eax
 2cf:	01 c0                	add    %eax,%eax
 2d1:	89 c1                	mov    %eax,%ecx
 2d3:	c1 e1 04             	shl    $0x4,%ecx
 2d6:	29 c1                	sub    %eax,%ecx
 2d8:	89 c8                	mov    %ecx,%eax
 2da:	01 d0                	add    %edx,%eax
 2dc:	8b 40 04             	mov    0x4(%eax),%eax
 2df:	83 ec 08             	sub    $0x8,%esp
 2e2:	50                   	push   %eax
 2e3:	68 ac 00 00 00       	push   $0xac
 2e8:	e8 fc ff ff ff       	call   2e9 <heap_grow+0x25c>
 2ed:	83 c4 10             	add    $0x10,%esp

		++regionCount;
 2f0:	a1 04 00 00 00       	mov    0x4,%eax
 2f5:	83 c0 01             	add    $0x1,%eax
 2f8:	a3 04 00 00 00       	mov    %eax,0x4
	}

	heapSize += size;
 2fd:	8b 15 10 00 00 00    	mov    0x10,%edx
 303:	8b 45 08             	mov    0x8(%ebp),%eax
 306:	01 d0                	add    %edx,%eax
 308:	a3 10 00 00 00       	mov    %eax,0x10
	return 1;
 30d:	b8 01 00 00 00       	mov    $0x1,%eax
}
 312:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 315:	c9                   	leave  
 316:	c3                   	ret    

00000317 <heap_get_current_end>:

void* heap_get_current_end()
{
 317:	55                   	push   %ebp
 318:	89 e5                	mov    %esp,%ebp
	return (void*)(HEAP_START + heapSize);
 31a:	8b 15 04 00 00 00    	mov    0x4,%edx
 320:	a1 10 00 00 00       	mov    0x10,%eax
 325:	01 d0                	add    %edx,%eax
}
 327:	5d                   	pop    %ebp
 328:	c3                   	ret    

00000329 <init_kernel_heap>:

void init_kernel_heap()
{
 329:	55                   	push   %ebp
 32a:	89 e5                	mov    %esp,%ebp
 32c:	53                   	push   %ebx
 32d:	83 ec 14             	sub    $0x14,%esp
	// Map placement area

	uint32_t i = PLACEMENT_BEGIN;
 330:	c7 45 f4 00 00 00 d0 	movl   $0xd0000000,-0xc(%ebp)

	for (i; i < PLACEMENT_END; i += PAGE_SIZE)
 337:	eb 22                	jmp    35b <init_kernel_heap+0x32>
	{
		vmmngr_mapPhysicalAddress(vmmngr_get_directory(), i, (uint32_t)pmmngr_alloc_block(), I86_PTE_PRESENT | I86_PTE_WRITABLE);
 339:	e8 fc ff ff ff       	call   33a <init_kernel_heap+0x11>
 33e:	89 c3                	mov    %eax,%ebx
 340:	e8 fc ff ff ff       	call   341 <init_kernel_heap+0x18>
 345:	6a 03                	push   $0x3
 347:	53                   	push   %ebx
 348:	ff 75 f4             	pushl  -0xc(%ebp)
 34b:	50                   	push   %eax
 34c:	e8 fc ff ff ff       	call   34d <init_kernel_heap+0x24>
 351:	83 c4 10             	add    $0x10,%esp
{
	// Map placement area

	uint32_t i = PLACEMENT_BEGIN;

	for (i; i < PLACEMENT_END; i += PAGE_SIZE)
 354:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
 35b:	81 7d f4 ff ff 1f d0 	cmpl   $0xd01fffff,-0xc(%ebp)
 362:	76 d5                	jbe    339 <init_kernel_heap+0x10>
	{
		vmmngr_mapPhysicalAddress(vmmngr_get_directory(), i, (uint32_t)pmmngr_alloc_block(), I86_PTE_PRESENT | I86_PTE_WRITABLE);
	}

	printf("Placement mapping done.\n");
 364:	83 ec 0c             	sub    $0xc,%esp
 367:	68 bf 00 00 00       	push   $0xbf
 36c:	e8 fc ff ff ff       	call   36d <init_kernel_heap+0x44>
 371:	83 c4 10             	add    $0x10,%esp

	regions = (region_t*)pmalloc(0, 0);
 374:	83 ec 08             	sub    $0x8,%esp
 377:	6a 00                	push   $0x0
 379:	6a 00                	push   $0x0
 37b:	e8 fc ff ff ff       	call   37c <init_kernel_heap+0x53>
 380:	83 c4 10             	add    $0x10,%esp
 383:	a3 00 00 00 00       	mov    %eax,0x0

	regionCount = 0;
 388:	c7 05 04 00 00 00 00 	movl   $0x0,0x4
 38f:	00 00 00 
	regionMaxCount = (PLACEMENT_END - (uint32_t)regions) / sizeof(region_t);
 392:	a1 00 00 00 00       	mov    0x0,%eax
 397:	ba 00 00 20 d0       	mov    $0xd0200000,%edx
 39c:	29 c2                	sub    %eax,%edx
 39e:	89 d0                	mov    %edx,%eax
 3a0:	ba 89 88 88 88       	mov    $0x88888889,%edx
 3a5:	f7 e2                	mul    %edx
 3a7:	89 d0                	mov    %edx,%eax
 3a9:	c1 e8 04             	shr    $0x4,%eax
 3ac:	a3 08 00 00 00       	mov    %eax,0x8
}
 3b1:	90                   	nop
 3b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 3b5:	c9                   	leave  
 3b6:	c3                   	ret    

000003b7 <kmalloc_imp>:

void* kmalloc_imp(size_t size, uint32_t alignment, const char* comment)
{
 3b7:	55                   	push   %ebp
 3b8:	89 e5                	mov    %esp,%ebp
 3ba:	56                   	push   %esi
 3bb:	53                   	push   %ebx
 3bc:	83 ec 40             	sub    $0x40,%esp
	printf("\n[kmalloc] Size:%i, Alignment: %i, Comment: %s", size, alignment, comment);
 3bf:	ff 75 10             	pushl  0x10(%ebp)
 3c2:	ff 75 0c             	pushl  0xc(%ebp)
 3c5:	ff 75 08             	pushl  0x8(%ebp)
 3c8:	68 d8 00 00 00       	push   $0xd8
 3cd:	e8 fc ff ff ff       	call   3ce <kmalloc_imp+0x17>
 3d2:	83 c4 10             	add    $0x10,%esp

	static uint32_t consecutiveNumber = 0;

	size_t within = 0xFFFFFFFF;
 3d5:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)

	if (alignment & HEAP_WITHIN_PAGE)
 3dc:	8b 45 0c             	mov    0xc(%ebp),%eax
 3df:	25 00 00 00 01       	and    $0x1000000,%eax
 3e4:	85 c0                	test   %eax,%eax
 3e6:	74 09                	je     3f1 <kmalloc_imp+0x3a>
	{
		within = PAGE_SIZE;
 3e8:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
 3ef:	eb 13                	jmp    404 <kmalloc_imp+0x4d>
	}
	else if (alignment & HEAP_WITHIN_64K)
 3f1:	8b 45 0c             	mov    0xc(%ebp),%eax
 3f4:	25 00 00 00 02       	and    $0x2000000,%eax
 3f9:	85 c0                	test   %eax,%eax
 3fb:	74 07                	je     404 <kmalloc_imp+0x4d>
	{
		within = 0x10000;
 3fd:	c7 45 f4 00 00 01 00 	movl   $0x10000,-0xc(%ebp)
	}

	int continuous = (alignment & HEAP_CONTINUOUS) ? 1 : 0;
 404:	8b 45 0c             	mov    0xc(%ebp),%eax
 407:	c1 e8 1f             	shr    $0x1f,%eax
 40a:	0f b6 c0             	movzbl %al,%eax
 40d:	89 45 dc             	mov    %eax,-0x24(%ebp)

	alignment &= HEAP_ALIGNMENT_MASK;
 410:	81 65 0c ff ff ff 00 	andl   $0xffffff,0xc(%ebp)

	// Check if heap is set up.

	if (regions == 0)
 417:	a1 00 00 00 00       	mov    0x0,%eax
 41c:	85 c0                	test   %eax,%eax
 41e:	75 26                	jne    446 <kmalloc_imp+0x8f>
	{
		printf("\nError2");
 420:	83 ec 0c             	sub    $0xc,%esp
 423:	68 07 01 00 00       	push   $0x107
 428:	e8 fc ff ff ff       	call   429 <kmalloc_imp+0x72>
 42d:	83 c4 10             	add    $0x10,%esp
		return (pmalloc(size, alignment));
 430:	83 ec 08             	sub    $0x8,%esp
 433:	ff 75 0c             	pushl  0xc(%ebp)
 436:	ff 75 08             	pushl  0x8(%ebp)
 439:	e8 fc ff ff ff       	call   43a <kmalloc_imp+0x83>
 43e:	83 c4 10             	add    $0x10,%esp
 441:	e9 f5 05 00 00       	jmp    a3b <kmalloc_imp+0x684>
	}

	size = alignUp(size, 0);
 446:	83 ec 08             	sub    $0x8,%esp
 449:	6a 00                	push   $0x0
 44b:	ff 75 08             	pushl  0x8(%ebp)
 44e:	e8 fc ff ff ff       	call   44f <kmalloc_imp+0x98>
 453:	83 c4 10             	add    $0x10,%esp
 456:	89 45 08             	mov    %eax,0x8(%ebp)

	int foundFree = 0;
 459:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	uint8_t* regionAddress = (uint8_t*)firstFreeAddr;
 460:	a1 00 00 00 00       	mov    0x0,%eax
 465:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for (uint32_t i = firstFreeRegion; i < regionCount;++i)
 468:	a1 0c 00 00 00       	mov    0xc,%eax
 46d:	89 45 e8             	mov    %eax,-0x18(%ebp)
 470:	e9 16 05 00 00       	jmp    98b <kmalloc_imp+0x5d4>
	{
		printf("\nRegion Loop: %i", i);
 475:	83 ec 08             	sub    $0x8,%esp
 478:	ff 75 e8             	pushl  -0x18(%ebp)
 47b:	68 0f 01 00 00       	push   $0x10f
 480:	e8 fc ff ff ff       	call   481 <kmalloc_imp+0xca>
 485:	83 c4 10             	add    $0x10,%esp
		if (regions[i].reserved)
 488:	8b 15 00 00 00 00    	mov    0x0,%edx
 48e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 491:	01 c0                	add    %eax,%eax
 493:	89 c1                	mov    %eax,%ecx
 495:	c1 e1 04             	shl    $0x4,%ecx
 498:	29 c1                	sub    %eax,%ecx
 49a:	89 c8                	mov    %ecx,%eax
 49c:	01 d0                	add    %edx,%eax
 49e:	0f b6 40 08          	movzbl 0x8(%eax),%eax
 4a2:	84 c0                	test   %al,%al
 4a4:	74 19                	je     4bf <kmalloc_imp+0x108>
		{
			printf("\nFound Free");
 4a6:	83 ec 0c             	sub    $0xc,%esp
 4a9:	68 20 01 00 00       	push   $0x120
 4ae:	e8 fc ff ff ff       	call   4af <kmalloc_imp+0xf8>
 4b3:	83 c4 10             	add    $0x10,%esp
			foundFree = 1;
 4b6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
 4bd:	eb 26                	jmp    4e5 <kmalloc_imp+0x12e>
		}
		else if (!foundFree)
 4bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 4c3:	75 20                	jne    4e5 <kmalloc_imp+0x12e>
		{
			printf("\nNot Found Free");
 4c5:	83 ec 0c             	sub    $0xc,%esp
 4c8:	68 2c 01 00 00       	push   $0x12c
 4cd:	e8 fc ff ff ff       	call   4ce <kmalloc_imp+0x117>
 4d2:	83 c4 10             	add    $0x10,%esp
			firstFreeRegion = i;
 4d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
 4d8:	a3 0c 00 00 00       	mov    %eax,0xc
			firstFreeAddr = regionAddress;
 4dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 4e0:	a3 00 00 00 00       	mov    %eax,0x0
		}

		uint8_t* alignedAddress = (uint8_t*)alignUp((uintptr_t)regionAddress, alignment);
 4e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
 4e8:	83 ec 08             	sub    $0x8,%esp
 4eb:	ff 75 0c             	pushl  0xc(%ebp)
 4ee:	50                   	push   %eax
 4ef:	e8 fc ff ff ff       	call   4f0 <kmalloc_imp+0x139>
 4f4:	83 c4 10             	add    $0x10,%esp
 4f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uintptr_t additionalSize = (uintptr_t)alignedAddress - (uintptr_t)regionAddress;
 4fa:	8b 55 d8             	mov    -0x28(%ebp),%edx
 4fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 500:	29 c2                	sub    %eax,%edx
 502:	89 d0                	mov    %edx,%eax
 504:	89 45 d4             	mov    %eax,-0x2c(%ebp)

		// Check whether this region is free, big enough and fits page requirements
		if (!regions[i].reserved && (regions[i].size >= size + additionalSize) &&
 507:	8b 15 00 00 00 00    	mov    0x0,%edx
 50d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 510:	01 c0                	add    %eax,%eax
 512:	89 c1                	mov    %eax,%ecx
 514:	c1 e1 04             	shl    $0x4,%ecx
 517:	29 c1                	sub    %eax,%ecx
 519:	89 c8                	mov    %ecx,%eax
 51b:	01 d0                	add    %edx,%eax
 51d:	0f b6 40 08          	movzbl 0x8(%eax),%eax
 521:	84 c0                	test   %al,%al
 523:	0f 85 40 04 00 00    	jne    969 <kmalloc_imp+0x5b2>
 529:	8b 15 00 00 00 00    	mov    0x0,%edx
 52f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 532:	01 c0                	add    %eax,%eax
 534:	89 c1                	mov    %eax,%ecx
 536:	c1 e1 04             	shl    $0x4,%ecx
 539:	29 c1                	sub    %eax,%ecx
 53b:	89 c8                	mov    %ecx,%eax
 53d:	01 d0                	add    %edx,%eax
 53f:	8b 00                	mov    (%eax),%eax
 541:	8b 4d 08             	mov    0x8(%ebp),%ecx
 544:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 547:	01 ca                	add    %ecx,%edx
 549:	39 d0                	cmp    %edx,%eax
 54b:	0f 82 18 04 00 00    	jb     969 <kmalloc_imp+0x5b2>
			(within - (uintptr_t)regionAddress%within >= additionalSize))
 551:	8b 45 ec             	mov    -0x14(%ebp),%eax
 554:	ba 00 00 00 00       	mov    $0x0,%edx
 559:	f7 75 f4             	divl   -0xc(%ebp)
 55c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 55f:	29 d0                	sub    %edx,%eax

		uint8_t* alignedAddress = (uint8_t*)alignUp((uintptr_t)regionAddress, alignment);
		uintptr_t additionalSize = (uintptr_t)alignedAddress - (uintptr_t)regionAddress;

		// Check whether this region is free, big enough and fits page requirements
		if (!regions[i].reserved && (regions[i].size >= size + additionalSize) &&
 561:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
 564:	0f 82 ff 03 00 00    	jb     969 <kmalloc_imp+0x5b2>
			(within - (uintptr_t)regionAddress%within >= additionalSize))
		{
			printf("\nFound Free, big and page");
 56a:	83 ec 0c             	sub    $0xc,%esp
 56d:	68 3c 01 00 00       	push   $0x13c
 572:	e8 fc ff ff ff       	call   573 <kmalloc_imp+0x1bc>
 577:	83 c4 10             	add    $0x10,%esp
			// Check if the region consists of continuous physical memory if required
			if (continuous)
 57a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 57e:	0f 84 91 00 00 00    	je     615 <kmalloc_imp+0x25e>
			{
				int iscontinuous = 1;
 584:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
				for (uint32_t virt1 = (uint32_t)alignDown((uintptr_t)alignedAddress, PAGE_SIZE); (uintptr_t)((uint32_t)virt1 + PAGE_SIZE) <= (uintptr_t)(alignedAddress + size); virt1 += PAGE_SIZE)
 58b:	8b 45 d8             	mov    -0x28(%ebp),%eax
 58e:	83 ec 08             	sub    $0x8,%esp
 591:	68 00 10 00 00       	push   $0x1000
 596:	50                   	push   %eax
 597:	e8 fc ff ff ff       	call   598 <kmalloc_imp+0x1e1>
 59c:	83 c4 10             	add    $0x10,%esp
 59f:	89 45 e0             	mov    %eax,-0x20(%ebp)
 5a2:	eb 52                	jmp    5f6 <kmalloc_imp+0x23f>
				{
					uintptr_t phys1 = (uintptr_t)vmmngr_getPhysicalAddress(vmmngr_get_directory(), (uint32_t)virt1);
 5a4:	e8 fc ff ff ff       	call   5a5 <kmalloc_imp+0x1ee>
 5a9:	83 ec 08             	sub    $0x8,%esp
 5ac:	ff 75 e0             	pushl  -0x20(%ebp)
 5af:	50                   	push   %eax
 5b0:	e8 fc ff ff ff       	call   5b1 <kmalloc_imp+0x1fa>
 5b5:	83 c4 10             	add    $0x10,%esp
 5b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
					uintptr_t phys2 = (uintptr_t)vmmngr_getPhysicalAddress(vmmngr_get_directory(), (uint32_t)virt1 + PAGE_SIZE);
 5bb:	8b 45 e0             	mov    -0x20(%ebp),%eax
 5be:	8d 98 00 10 00 00    	lea    0x1000(%eax),%ebx
 5c4:	e8 fc ff ff ff       	call   5c5 <kmalloc_imp+0x20e>
 5c9:	83 ec 08             	sub    $0x8,%esp
 5cc:	53                   	push   %ebx
 5cd:	50                   	push   %eax
 5ce:	e8 fc ff ff ff       	call   5cf <kmalloc_imp+0x218>
 5d3:	83 c4 10             	add    $0x10,%esp
 5d6:	89 45 cc             	mov    %eax,-0x34(%ebp)
					if (phys1 + PAGE_SIZE != phys2)
 5d9:	8b 45 d0             	mov    -0x30(%ebp),%eax
 5dc:	05 00 10 00 00       	add    $0x1000,%eax
 5e1:	3b 45 cc             	cmp    -0x34(%ebp),%eax
 5e4:	74 09                	je     5ef <kmalloc_imp+0x238>
					{
						iscontinuous = 0;
 5e6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
						break;
 5ed:	eb 1c                	jmp    60b <kmalloc_imp+0x254>
			printf("\nFound Free, big and page");
			// Check if the region consists of continuous physical memory if required
			if (continuous)
			{
				int iscontinuous = 1;
				for (uint32_t virt1 = (uint32_t)alignDown((uintptr_t)alignedAddress, PAGE_SIZE); (uintptr_t)((uint32_t)virt1 + PAGE_SIZE) <= (uintptr_t)(alignedAddress + size); virt1 += PAGE_SIZE)
 5ef:	81 45 e0 00 10 00 00 	addl   $0x1000,-0x20(%ebp)
 5f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
 5f9:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
 5ff:	8b 55 d8             	mov    -0x28(%ebp),%edx
 602:	8b 45 08             	mov    0x8(%ebp),%eax
 605:	01 d0                	add    %edx,%eax
 607:	39 c1                	cmp    %eax,%ecx
 609:	76 99                	jbe    5a4 <kmalloc_imp+0x1ed>
					{
						iscontinuous = 0;
						break;
					}
				}
				if (!iscontinuous)
 60b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 60f:	0f 84 71 03 00 00    	je     986 <kmalloc_imp+0x5cf>
			// +------------------+--------------------------+----------+
			// | Before Alignment | Aligned Destination Area | Leftover |
			// +------------------+--------------------------+----------+

			// Split the pre-alignment area
			if (alignedAddress != regionAddress)
 615:	8b 45 d8             	mov    -0x28(%ebp),%eax
 618:	3b 45 ec             	cmp    -0x14(%ebp),%eax
 61b:	0f 84 43 01 00 00    	je     764 <kmalloc_imp+0x3ad>
			{
				// Check whether we are able to expand
				if (regionCount >= regionMaxCount)
 621:	8b 15 04 00 00 00    	mov    0x4,%edx
 627:	a1 08 00 00 00       	mov    0x8,%eax
 62c:	39 c2                	cmp    %eax,%edx
 62e:	72 1a                	jb     64a <kmalloc_imp+0x293>
				{
					printf("\nError3");
 630:	83 ec 0c             	sub    $0xc,%esp
 633:	68 56 01 00 00       	push   $0x156
 638:	e8 fc ff ff ff       	call   639 <kmalloc_imp+0x282>
 63d:	83 c4 10             	add    $0x10,%esp
					return (0);
 640:	b8 00 00 00 00       	mov    $0x0,%eax
 645:	e9 f1 03 00 00       	jmp    a3b <kmalloc_imp+0x684>
				}

				printf("\nMoving regions");
 64a:	83 ec 0c             	sub    $0xc,%esp
 64d:	68 5e 01 00 00       	push   $0x15e
 652:	e8 fc ff ff ff       	call   653 <kmalloc_imp+0x29c>
 657:	83 c4 10             	add    $0x10,%esp

				// Move all following regions ahead to get room for a new one
				memmove(regions + i + 1, regions + i, (regionCount - i) * sizeof(region_t));
 65a:	a1 04 00 00 00       	mov    0x4,%eax
 65f:	2b 45 e8             	sub    -0x18(%ebp),%eax
 662:	01 c0                	add    %eax,%eax
 664:	89 c2                	mov    %eax,%edx
 666:	c1 e2 04             	shl    $0x4,%edx
 669:	89 d1                	mov    %edx,%ecx
 66b:	29 c1                	sub    %eax,%ecx
 66d:	8b 15 00 00 00 00    	mov    0x0,%edx
 673:	8b 45 e8             	mov    -0x18(%ebp),%eax
 676:	01 c0                	add    %eax,%eax
 678:	89 c3                	mov    %eax,%ebx
 67a:	c1 e3 04             	shl    $0x4,%ebx
 67d:	29 c3                	sub    %eax,%ebx
 67f:	89 d8                	mov    %ebx,%eax
 681:	01 c2                	add    %eax,%edx
 683:	8b 1d 00 00 00 00    	mov    0x0,%ebx
 689:	8b 45 e8             	mov    -0x18(%ebp),%eax
 68c:	83 c0 01             	add    $0x1,%eax
 68f:	01 c0                	add    %eax,%eax
 691:	89 c6                	mov    %eax,%esi
 693:	c1 e6 04             	shl    $0x4,%esi
 696:	29 c6                	sub    %eax,%esi
 698:	89 f0                	mov    %esi,%eax
 69a:	01 d8                	add    %ebx,%eax
 69c:	83 ec 04             	sub    $0x4,%esp
 69f:	51                   	push   %ecx
 6a0:	52                   	push   %edx
 6a1:	50                   	push   %eax
 6a2:	e8 fc ff ff ff       	call   6a3 <kmalloc_imp+0x2ec>
 6a7:	83 c4 10             	add    $0x10,%esp

				++regionCount;
 6aa:	a1 04 00 00 00       	mov    0x4,%eax
 6af:	83 c0 01             	add    $0x1,%eax
 6b2:	a3 04 00 00 00       	mov    %eax,0x4

				// Setup the regions
				regions[i].size = alignedAddress - regionAddress;
 6b7:	8b 15 00 00 00 00    	mov    0x0,%edx
 6bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
 6c0:	01 c0                	add    %eax,%eax
 6c2:	89 c1                	mov    %eax,%ecx
 6c4:	c1 e1 04             	shl    $0x4,%ecx
 6c7:	29 c1                	sub    %eax,%ecx
 6c9:	89 c8                	mov    %ecx,%eax
 6cb:	01 d0                	add    %edx,%eax
 6cd:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 6d0:	8b 55 ec             	mov    -0x14(%ebp),%edx
 6d3:	29 d1                	sub    %edx,%ecx
 6d5:	89 ca                	mov    %ecx,%edx
 6d7:	89 10                	mov    %edx,(%eax)

				regions[i].reserved = 0;
 6d9:	8b 15 00 00 00 00    	mov    0x0,%edx
 6df:	8b 45 e8             	mov    -0x18(%ebp),%eax
 6e2:	01 c0                	add    %eax,%eax
 6e4:	89 c1                	mov    %eax,%ecx
 6e6:	c1 e1 04             	shl    $0x4,%ecx
 6e9:	29 c1                	sub    %eax,%ecx
 6eb:	89 c8                	mov    %ecx,%eax
 6ed:	01 d0                	add    %edx,%eax
 6ef:	c6 40 08 00          	movb   $0x0,0x8(%eax)

				regions[i + 1].size -= regions[i].size;
 6f3:	8b 15 00 00 00 00    	mov    0x0,%edx
 6f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
 6fc:	83 c0 01             	add    $0x1,%eax
 6ff:	01 c0                	add    %eax,%eax
 701:	89 c1                	mov    %eax,%ecx
 703:	c1 e1 04             	shl    $0x4,%ecx
 706:	29 c1                	sub    %eax,%ecx
 708:	89 c8                	mov    %ecx,%eax
 70a:	01 c2                	add    %eax,%edx
 70c:	8b 0d 00 00 00 00    	mov    0x0,%ecx
 712:	8b 45 e8             	mov    -0x18(%ebp),%eax
 715:	83 c0 01             	add    $0x1,%eax
 718:	01 c0                	add    %eax,%eax
 71a:	89 c3                	mov    %eax,%ebx
 71c:	c1 e3 04             	shl    $0x4,%ebx
 71f:	29 c3                	sub    %eax,%ebx
 721:	89 d8                	mov    %ebx,%eax
 723:	01 c8                	add    %ecx,%eax
 725:	8b 08                	mov    (%eax),%ecx
 727:	8b 1d 00 00 00 00    	mov    0x0,%ebx
 72d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 730:	01 c0                	add    %eax,%eax
 732:	89 c6                	mov    %eax,%esi
 734:	c1 e6 04             	shl    $0x4,%esi
 737:	29 c6                	sub    %eax,%esi
 739:	89 f0                	mov    %esi,%eax
 73b:	01 d8                	add    %ebx,%eax
 73d:	8b 00                	mov    (%eax),%eax
 73f:	29 c1                	sub    %eax,%ecx
 741:	89 c8                	mov    %ecx,%eax
 743:	89 02                	mov    %eax,(%edx)

				// "Aligned Destination Area" becomes the "current" region
				regionAddress += regions[i].size;
 745:	8b 15 00 00 00 00    	mov    0x0,%edx
 74b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 74e:	01 c0                	add    %eax,%eax
 750:	89 c1                	mov    %eax,%ecx
 752:	c1 e1 04             	shl    $0x4,%ecx
 755:	29 c1                	sub    %eax,%ecx
 757:	89 c8                	mov    %ecx,%eax
 759:	01 d0                	add    %edx,%eax
 75b:	8b 00                	mov    (%eax),%eax
 75d:	01 45 ec             	add    %eax,-0x14(%ebp)

				i++;
 760:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
			}

			// Split the leftover
			if (regions[i].size > size + additionalSize)
 764:	8b 15 00 00 00 00    	mov    0x0,%edx
 76a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 76d:	01 c0                	add    %eax,%eax
 76f:	89 c1                	mov    %eax,%ecx
 771:	c1 e1 04             	shl    $0x4,%ecx
 774:	29 c1                	sub    %eax,%ecx
 776:	89 c8                	mov    %ecx,%eax
 778:	01 d0                	add    %edx,%eax
 77a:	8b 00                	mov    (%eax),%eax
 77c:	8b 4d 08             	mov    0x8(%ebp),%ecx
 77f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 782:	01 ca                	add    %ecx,%edx
 784:	39 d0                	cmp    %edx,%eax
 786:	0f 86 3c 01 00 00    	jbe    8c8 <kmalloc_imp+0x511>
			{

				printf("\nSplitting leftover");
 78c:	83 ec 0c             	sub    $0xc,%esp
 78f:	68 6e 01 00 00       	push   $0x16e
 794:	e8 fc ff ff ff       	call   795 <kmalloc_imp+0x3de>
 799:	83 c4 10             	add    $0x10,%esp
				// Check whether we are able to expand
				if (regionCount + 1 > regionMaxCount)
 79c:	a1 04 00 00 00       	mov    0x4,%eax
 7a1:	8d 50 01             	lea    0x1(%eax),%edx
 7a4:	a1 08 00 00 00       	mov    0x8,%eax
 7a9:	39 c2                	cmp    %eax,%edx
 7ab:	76 1a                	jbe    7c7 <kmalloc_imp+0x410>
				{
					printf("\nError4");
 7ad:	83 ec 0c             	sub    $0xc,%esp
 7b0:	68 82 01 00 00       	push   $0x182
 7b5:	e8 fc ff ff ff       	call   7b6 <kmalloc_imp+0x3ff>
 7ba:	83 c4 10             	add    $0x10,%esp
					return (0);
 7bd:	b8 00 00 00 00       	mov    $0x0,%eax
 7c2:	e9 74 02 00 00       	jmp    a3b <kmalloc_imp+0x684>
				}

				printf("\nMoving regions 2");
 7c7:	83 ec 0c             	sub    $0xc,%esp
 7ca:	68 8a 01 00 00       	push   $0x18a
 7cf:	e8 fc ff ff ff       	call   7d0 <kmalloc_imp+0x419>
 7d4:	83 c4 10             	add    $0x10,%esp

				// Move all following regions ahead to get room for a new one
				memmove(regions + i + 2, regions + i + 1, (regionCount - i - 1)*sizeof(region_t));
 7d7:	a1 04 00 00 00       	mov    0x4,%eax
 7dc:	2b 45 e8             	sub    -0x18(%ebp),%eax
 7df:	01 c0                	add    %eax,%eax
 7e1:	89 c2                	mov    %eax,%edx
 7e3:	c1 e2 04             	shl    $0x4,%edx
 7e6:	29 c2                	sub    %eax,%edx
 7e8:	89 d0                	mov    %edx,%eax
 7ea:	8d 48 e2             	lea    -0x1e(%eax),%ecx
 7ed:	8b 15 00 00 00 00    	mov    0x0,%edx
 7f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 7f6:	83 c0 01             	add    $0x1,%eax
 7f9:	01 c0                	add    %eax,%eax
 7fb:	89 c3                	mov    %eax,%ebx
 7fd:	c1 e3 04             	shl    $0x4,%ebx
 800:	29 c3                	sub    %eax,%ebx
 802:	89 d8                	mov    %ebx,%eax
 804:	01 c2                	add    %eax,%edx
 806:	8b 1d 00 00 00 00    	mov    0x0,%ebx
 80c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80f:	01 c0                	add    %eax,%eax
 811:	89 c6                	mov    %eax,%esi
 813:	c1 e6 04             	shl    $0x4,%esi
 816:	29 c6                	sub    %eax,%esi
 818:	89 f0                	mov    %esi,%eax
 81a:	83 c0 3c             	add    $0x3c,%eax
 81d:	01 d8                	add    %ebx,%eax
 81f:	83 ec 04             	sub    $0x4,%esp
 822:	51                   	push   %ecx
 823:	52                   	push   %edx
 824:	50                   	push   %eax
 825:	e8 fc ff ff ff       	call   826 <kmalloc_imp+0x46f>
 82a:	83 c4 10             	add    $0x10,%esp

				++regionCount;
 82d:	a1 04 00 00 00       	mov    0x4,%eax
 832:	83 c0 01             	add    $0x1,%eax
 835:	a3 04 00 00 00       	mov    %eax,0x4

				// Setup the regions
				regions[i + 1].size = regions[i].size - size;
 83a:	8b 15 00 00 00 00    	mov    0x0,%edx
 840:	8b 45 e8             	mov    -0x18(%ebp),%eax
 843:	83 c0 01             	add    $0x1,%eax
 846:	01 c0                	add    %eax,%eax
 848:	89 c1                	mov    %eax,%ecx
 84a:	c1 e1 04             	shl    $0x4,%ecx
 84d:	29 c1                	sub    %eax,%ecx
 84f:	89 c8                	mov    %ecx,%eax
 851:	01 c2                	add    %eax,%edx
 853:	8b 0d 00 00 00 00    	mov    0x0,%ecx
 859:	8b 45 e8             	mov    -0x18(%ebp),%eax
 85c:	01 c0                	add    %eax,%eax
 85e:	89 c3                	mov    %eax,%ebx
 860:	c1 e3 04             	shl    $0x4,%ebx
 863:	29 c3                	sub    %eax,%ebx
 865:	89 d8                	mov    %ebx,%eax
 867:	01 c8                	add    %ecx,%eax
 869:	8b 00                	mov    (%eax),%eax
 86b:	2b 45 08             	sub    0x8(%ebp),%eax
 86e:	89 02                	mov    %eax,(%edx)
				regions[i + 1].reserved = 0;
 870:	8b 15 00 00 00 00    	mov    0x0,%edx
 876:	8b 45 e8             	mov    -0x18(%ebp),%eax
 879:	83 c0 01             	add    $0x1,%eax
 87c:	01 c0                	add    %eax,%eax
 87e:	89 c1                	mov    %eax,%ecx
 880:	c1 e1 04             	shl    $0x4,%ecx
 883:	29 c1                	sub    %eax,%ecx
 885:	89 c8                	mov    %ecx,%eax
 887:	01 d0                	add    %edx,%eax
 889:	c6 40 08 00          	movb   $0x0,0x8(%eax)
				regions[i + 1].number = 0;
 88d:	8b 15 00 00 00 00    	mov    0x0,%edx
 893:	8b 45 e8             	mov    -0x18(%ebp),%eax
 896:	83 c0 01             	add    $0x1,%eax
 899:	01 c0                	add    %eax,%eax
 89b:	89 c1                	mov    %eax,%ecx
 89d:	c1 e1 04             	shl    $0x4,%ecx
 8a0:	29 c1                	sub    %eax,%ecx
 8a2:	89 c8                	mov    %ecx,%eax
 8a4:	01 d0                	add    %edx,%eax
 8a6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

				regions[i].size = size;
 8ad:	8b 15 00 00 00 00    	mov    0x0,%edx
 8b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8b6:	01 c0                	add    %eax,%eax
 8b8:	89 c1                	mov    %eax,%ecx
 8ba:	c1 e1 04             	shl    $0x4,%ecx
 8bd:	29 c1                	sub    %eax,%ecx
 8bf:	89 c8                	mov    %ecx,%eax
 8c1:	01 c2                	add    %eax,%edx
 8c3:	8b 45 08             	mov    0x8(%ebp),%eax
 8c6:	89 02                	mov    %eax,(%edx)
			}

			printf("\nSet region to reserved and return");
 8c8:	83 ec 0c             	sub    $0xc,%esp
 8cb:	68 9c 01 00 00       	push   $0x19c
 8d0:	e8 fc ff ff ff       	call   8d1 <kmalloc_imp+0x51a>
 8d5:	83 c4 10             	add    $0x10,%esp

			// Set the region to "reserved" and return its address
			regions[i].reserved = 1;
 8d8:	8b 15 00 00 00 00    	mov    0x0,%edx
 8de:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8e1:	01 c0                	add    %eax,%eax
 8e3:	89 c1                	mov    %eax,%ecx
 8e5:	c1 e1 04             	shl    $0x4,%ecx
 8e8:	29 c1                	sub    %eax,%ecx
 8ea:	89 c8                	mov    %ecx,%eax
 8ec:	01 d0                	add    %edx,%eax
 8ee:	c6 40 08 01          	movb   $0x1,0x8(%eax)
			strncpy(regions[i].comment, comment, 20);
 8f2:	8b 15 00 00 00 00    	mov    0x0,%edx
 8f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8fb:	01 c0                	add    %eax,%eax
 8fd:	89 c1                	mov    %eax,%ecx
 8ff:	c1 e1 04             	shl    $0x4,%ecx
 902:	29 c1                	sub    %eax,%ecx
 904:	89 c8                	mov    %ecx,%eax
 906:	01 d0                	add    %edx,%eax
 908:	83 c0 09             	add    $0x9,%eax
 90b:	83 ec 04             	sub    $0x4,%esp
 90e:	6a 14                	push   $0x14
 910:	ff 75 10             	pushl  0x10(%ebp)
 913:	50                   	push   %eax
 914:	e8 fc ff ff ff       	call   915 <kmalloc_imp+0x55e>
 919:	83 c4 10             	add    $0x10,%esp
			regions[i].comment[20] = 0;
 91c:	8b 15 00 00 00 00    	mov    0x0,%edx
 922:	8b 45 e8             	mov    -0x18(%ebp),%eax
 925:	01 c0                	add    %eax,%eax
 927:	89 c1                	mov    %eax,%ecx
 929:	c1 e1 04             	shl    $0x4,%ecx
 92c:	29 c1                	sub    %eax,%ecx
 92e:	89 c8                	mov    %ecx,%eax
 930:	01 d0                	add    %edx,%eax
 932:	c6 40 1d 00          	movb   $0x0,0x1d(%eax)
			regions[i].number = ++consecutiveNumber;
 936:	8b 15 00 00 00 00    	mov    0x0,%edx
 93c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 93f:	01 c0                	add    %eax,%eax
 941:	89 c1                	mov    %eax,%ecx
 943:	c1 e1 04             	shl    $0x4,%ecx
 946:	29 c1                	sub    %eax,%ecx
 948:	89 c8                	mov    %ecx,%eax
 94a:	01 c2                	add    %eax,%edx
 94c:	a1 14 00 00 00       	mov    0x14,%eax
 951:	83 c0 01             	add    $0x1,%eax
 954:	a3 14 00 00 00       	mov    %eax,0x14
 959:	a1 14 00 00 00       	mov    0x14,%eax
 95e:	89 42 04             	mov    %eax,0x4(%edx)

			return (regionAddress);
 961:	8b 45 ec             	mov    -0x14(%ebp),%eax
 964:	e9 d2 00 00 00       	jmp    a3b <kmalloc_imp+0x684>

		} //region is free and big enough

		regionAddress += regions[i].size;
 969:	8b 15 00 00 00 00    	mov    0x0,%edx
 96f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 972:	01 c0                	add    %eax,%eax
 974:	89 c1                	mov    %eax,%ecx
 976:	c1 e1 04             	shl    $0x4,%ecx
 979:	29 c1                	sub    %eax,%ecx
 97b:	89 c8                	mov    %ecx,%eax
 97d:	01 d0                	add    %edx,%eax
 97f:	8b 00                	mov    (%eax),%eax
 981:	01 45 ec             	add    %eax,-0x14(%ebp)
 984:	eb 01                	jmp    987 <kmalloc_imp+0x5d0>
						iscontinuous = 0;
						break;
					}
				}
				if (!iscontinuous)
					continue;
 986:	90                   	nop

	int foundFree = 0;

	uint8_t* regionAddress = (uint8_t*)firstFreeAddr;

	for (uint32_t i = firstFreeRegion; i < regionCount;++i)
 987:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
 98b:	a1 04 00 00 00       	mov    0x4,%eax
 990:	39 45 e8             	cmp    %eax,-0x18(%ebp)
 993:	0f 82 dc fa ff ff    	jb     475 <kmalloc_imp+0xbe>

		regionAddress += regions[i].size;
	}

	// There is nothing free, try to expand the heap
	uint32_t sizeToGrow = max(HEAP_MIN_GROWTH, alignUp(size * 3 / 2, PAGE_SIZE));
 999:	8b 55 08             	mov    0x8(%ebp),%edx
 99c:	89 d0                	mov    %edx,%eax
 99e:	01 c0                	add    %eax,%eax
 9a0:	01 d0                	add    %edx,%eax
 9a2:	d1 e8                	shr    %eax
 9a4:	83 ec 08             	sub    $0x8,%esp
 9a7:	68 00 10 00 00       	push   $0x1000
 9ac:	50                   	push   %eax
 9ad:	e8 fc ff ff ff       	call   9ae <kmalloc_imp+0x5f7>
 9b2:	83 c4 10             	add    $0x10,%esp
 9b5:	ba 00 00 01 00       	mov    $0x10000,%edx
 9ba:	39 d0                	cmp    %edx,%eax
 9bc:	76 1e                	jbe    9dc <kmalloc_imp+0x625>
 9be:	8b 55 08             	mov    0x8(%ebp),%edx
 9c1:	89 d0                	mov    %edx,%eax
 9c3:	01 c0                	add    %eax,%eax
 9c5:	01 d0                	add    %edx,%eax
 9c7:	d1 e8                	shr    %eax
 9c9:	83 ec 08             	sub    $0x8,%esp
 9cc:	68 00 10 00 00       	push   $0x1000
 9d1:	50                   	push   %eax
 9d2:	e8 fc ff ff ff       	call   9d3 <kmalloc_imp+0x61c>
 9d7:	83 c4 10             	add    $0x10,%esp
 9da:	eb 05                	jmp    9e1 <kmalloc_imp+0x62a>
 9dc:	b8 00 00 01 00       	mov    $0x10000,%eax
 9e1:	89 45 c8             	mov    %eax,-0x38(%ebp)

	int success = heap_grow(sizeToGrow, (uint8_t*)((uintptr_t)HEAP_START + heapSize), continuous);
 9e4:	a1 04 00 00 00       	mov    0x4,%eax
 9e9:	89 c2                	mov    %eax,%edx
 9eb:	a1 10 00 00 00       	mov    0x10,%eax
 9f0:	01 d0                	add    %edx,%eax
 9f2:	83 ec 04             	sub    $0x4,%esp
 9f5:	ff 75 dc             	pushl  -0x24(%ebp)
 9f8:	50                   	push   %eax
 9f9:	ff 75 c8             	pushl  -0x38(%ebp)
 9fc:	e8 fc ff ff ff       	call   9fd <kmalloc_imp+0x646>
 a01:	83 c4 10             	add    $0x10,%esp
 a04:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	if (!success)
 a07:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 a0b:	75 17                	jne    a24 <kmalloc_imp+0x66d>
	{
		printf("\nError5");
 a0d:	83 ec 0c             	sub    $0xc,%esp
 a10:	68 bf 01 00 00       	push   $0x1bf
 a15:	e8 fc ff ff ff       	call   a16 <kmalloc_imp+0x65f>
 a1a:	83 c4 10             	add    $0x10,%esp
		return (0);
 a1d:	b8 00 00 00 00       	mov    $0x0,%eax
 a22:	eb 17                	jmp    a3b <kmalloc_imp+0x684>
	}

	asm volatile("xchgw %bx, %bx");
 a24:	66 87 db             	xchg   %bx,%bx

	// Now there should be a region that is large enough
	return kmalloc_imp(size, alignment, comment);
 a27:	83 ec 04             	sub    $0x4,%esp
 a2a:	ff 75 10             	pushl  0x10(%ebp)
 a2d:	ff 75 0c             	pushl  0xc(%ebp)
 a30:	ff 75 08             	pushl  0x8(%ebp)
 a33:	e8 fc ff ff ff       	call   a34 <kmalloc_imp+0x67d>
 a38:	83 c4 10             	add    $0x10,%esp
}
 a3b:	8d 65 f8             	lea    -0x8(%ebp),%esp
 a3e:	5b                   	pop    %ebx
 a3f:	5e                   	pop    %esi
 a40:	5d                   	pop    %ebp
 a41:	c3                   	ret    

00000a42 <kernel_malloc>:

void* kernel_malloc(size_t size){
 a42:	55                   	push   %ebp
 a43:	89 e5                	mov    %esp,%ebp
 a45:	83 ec 08             	sub    $0x8,%esp
	return kmalloc_imp(size, 0, "None");
 a48:	83 ec 04             	sub    $0x4,%esp
 a4b:	68 c7 01 00 00       	push   $0x1c7
 a50:	6a 00                	push   $0x0
 a52:	ff 75 08             	pushl  0x8(%ebp)
 a55:	e8 fc ff ff ff       	call   a56 <kernel_malloc+0x14>
 a5a:	83 c4 10             	add    $0x10,%esp
}
 a5d:	c9                   	leave  
 a5e:	c3                   	ret    

00000a5f <kernel_malloc_a>:

void* kernel_malloc_a(size_t size, uint32_t alignment){
 a5f:	55                   	push   %ebp
 a60:	89 e5                	mov    %esp,%ebp
 a62:	83 ec 08             	sub    $0x8,%esp
	return kmalloc_imp(size, alignment, "None");
 a65:	83 ec 04             	sub    $0x4,%esp
 a68:	68 c7 01 00 00       	push   $0x1c7
 a6d:	ff 75 0c             	pushl  0xc(%ebp)
 a70:	ff 75 08             	pushl  0x8(%ebp)
 a73:	e8 fc ff ff ff       	call   a74 <kernel_malloc_a+0x15>
 a78:	83 c4 10             	add    $0x10,%esp
}
 a7b:	c9                   	leave  
 a7c:	c3                   	ret    

00000a7d <kernel_malloc_c>:

void* kernel_malloc_c(size_t size, const char* comment){
 a7d:	55                   	push   %ebp
 a7e:	89 e5                	mov    %esp,%ebp
 a80:	83 ec 08             	sub    $0x8,%esp
	return kmalloc_imp(size, 0, comment);
 a83:	83 ec 04             	sub    $0x4,%esp
 a86:	ff 75 0c             	pushl  0xc(%ebp)
 a89:	6a 00                	push   $0x0
 a8b:	ff 75 08             	pushl  0x8(%ebp)
 a8e:	e8 fc ff ff ff       	call   a8f <kernel_malloc_c+0x12>
 a93:	83 c4 10             	add    $0x10,%esp
}
 a96:	c9                   	leave  
 a97:	c3                   	ret    

00000a98 <kernel_malloc_ac>:

void* kernel_malloc_ac(size_t size, uint32_t alignment, const char* comment){
 a98:	55                   	push   %ebp
 a99:	89 e5                	mov    %esp,%ebp
 a9b:	83 ec 08             	sub    $0x8,%esp
	return kmalloc_imp(size, alignment, comment);
 a9e:	83 ec 04             	sub    $0x4,%esp
 aa1:	ff 75 10             	pushl  0x10(%ebp)
 aa4:	ff 75 0c             	pushl  0xc(%ebp)
 aa7:	ff 75 08             	pushl  0x8(%ebp)
 aaa:	e8 fc ff ff ff       	call   aab <kernel_malloc_ac+0x13>
 aaf:	83 c4 10             	add    $0x10,%esp
}
 ab2:	c9                   	leave  
 ab3:	c3                   	ret    

00000ab4 <kernel_free>:

void kernel_free(void* addr)
{
 ab4:	55                   	push   %ebp
 ab5:	89 e5                	mov    %esp,%ebp
 ab7:	56                   	push   %esi
 ab8:	53                   	push   %ebx
 ab9:	83 ec 10             	sub    $0x10,%esp
	if (addr == 0)
 abc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 ac0:	0f 84 8b 02 00 00    	je     d51 <kernel_free+0x29d>
	{
		return;
	}

	// Walk the regions and find the correct one
	uint8_t* regionAddress = (uint8_t*)HEAP_START;
 ac6:	a1 04 00 00 00       	mov    0x4,%eax
 acb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for (uint32_t i = 0; i < regionCount; i++)
 ace:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 ad5:	e9 67 02 00 00       	jmp    d41 <kernel_free+0x28d>
	{
		if (regionAddress == addr && regions[i].reserved)
 ada:	8b 45 f4             	mov    -0xc(%ebp),%eax
 add:	3b 45 08             	cmp    0x8(%ebp),%eax
 ae0:	0f 85 3c 02 00 00    	jne    d22 <kernel_free+0x26e>
 ae6:	8b 15 00 00 00 00    	mov    0x0,%edx
 aec:	8b 45 f0             	mov    -0x10(%ebp),%eax
 aef:	01 c0                	add    %eax,%eax
 af1:	89 c1                	mov    %eax,%ecx
 af3:	c1 e1 04             	shl    $0x4,%ecx
 af6:	29 c1                	sub    %eax,%ecx
 af8:	89 c8                	mov    %ecx,%eax
 afa:	01 d0                	add    %edx,%eax
 afc:	0f b6 40 08          	movzbl 0x8(%eax),%eax
 b00:	84 c0                	test   %al,%al
 b02:	0f 84 1a 02 00 00    	je     d22 <kernel_free+0x26e>
		{
			regions[i].number = 0;
 b08:	8b 15 00 00 00 00    	mov    0x0,%edx
 b0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 b11:	01 c0                	add    %eax,%eax
 b13:	89 c1                	mov    %eax,%ecx
 b15:	c1 e1 04             	shl    $0x4,%ecx
 b18:	29 c1                	sub    %eax,%ecx
 b1a:	89 c8                	mov    %ecx,%eax
 b1c:	01 d0                	add    %edx,%eax
 b1e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			regions[i].reserved = 0; // free the region
 b25:	8b 15 00 00 00 00    	mov    0x0,%edx
 b2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 b2e:	01 c0                	add    %eax,%eax
 b30:	89 c1                	mov    %eax,%ecx
 b32:	c1 e1 04             	shl    $0x4,%ecx
 b35:	29 c1                	sub    %eax,%ecx
 b37:	89 c8                	mov    %ecx,%eax
 b39:	01 d0                	add    %edx,%eax
 b3b:	c6 40 08 00          	movb   $0x0,0x8(%eax)

										 // Check for a merge with the next region
			if ((i + 1 < regionCount) && !regions[i + 1].reserved)
 b3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 b42:	8d 50 01             	lea    0x1(%eax),%edx
 b45:	a1 04 00 00 00       	mov    0x4,%eax
 b4a:	39 c2                	cmp    %eax,%edx
 b4c:	0f 83 d5 00 00 00    	jae    c27 <kernel_free+0x173>
 b52:	8b 15 00 00 00 00    	mov    0x0,%edx
 b58:	8b 45 f0             	mov    -0x10(%ebp),%eax
 b5b:	83 c0 01             	add    $0x1,%eax
 b5e:	01 c0                	add    %eax,%eax
 b60:	89 c1                	mov    %eax,%ecx
 b62:	c1 e1 04             	shl    $0x4,%ecx
 b65:	29 c1                	sub    %eax,%ecx
 b67:	89 c8                	mov    %ecx,%eax
 b69:	01 d0                	add    %edx,%eax
 b6b:	0f b6 40 08          	movzbl 0x8(%eax),%eax
 b6f:	84 c0                	test   %al,%al
 b71:	0f 85 b0 00 00 00    	jne    c27 <kernel_free+0x173>
			{
				// Adjust the size of the now free region
				regions[i].size += regions[i + 1].size; // merge
 b77:	8b 15 00 00 00 00    	mov    0x0,%edx
 b7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 b80:	01 c0                	add    %eax,%eax
 b82:	89 c1                	mov    %eax,%ecx
 b84:	c1 e1 04             	shl    $0x4,%ecx
 b87:	29 c1                	sub    %eax,%ecx
 b89:	89 c8                	mov    %ecx,%eax
 b8b:	01 c2                	add    %eax,%edx
 b8d:	8b 0d 00 00 00 00    	mov    0x0,%ecx
 b93:	8b 45 f0             	mov    -0x10(%ebp),%eax
 b96:	01 c0                	add    %eax,%eax
 b98:	89 c3                	mov    %eax,%ebx
 b9a:	c1 e3 04             	shl    $0x4,%ebx
 b9d:	29 c3                	sub    %eax,%ebx
 b9f:	89 d8                	mov    %ebx,%eax
 ba1:	01 c8                	add    %ecx,%eax
 ba3:	8b 08                	mov    (%eax),%ecx
 ba5:	8b 1d 00 00 00 00    	mov    0x0,%ebx
 bab:	8b 45 f0             	mov    -0x10(%ebp),%eax
 bae:	83 c0 01             	add    $0x1,%eax
 bb1:	01 c0                	add    %eax,%eax
 bb3:	89 c6                	mov    %eax,%esi
 bb5:	c1 e6 04             	shl    $0x4,%esi
 bb8:	29 c6                	sub    %eax,%esi
 bba:	89 f0                	mov    %esi,%eax
 bbc:	01 d8                	add    %ebx,%eax
 bbe:	8b 00                	mov    (%eax),%eax
 bc0:	01 c8                	add    %ecx,%eax
 bc2:	89 02                	mov    %eax,(%edx)

														// Move all following regions back by one
				memmove(regions + i + 1, regions + i + 2, (regionCount - 2 - i)*sizeof(region_t));
 bc4:	a1 04 00 00 00       	mov    0x4,%eax
 bc9:	2b 45 f0             	sub    -0x10(%ebp),%eax
 bcc:	01 c0                	add    %eax,%eax
 bce:	89 c2                	mov    %eax,%edx
 bd0:	c1 e2 04             	shl    $0x4,%edx
 bd3:	29 c2                	sub    %eax,%edx
 bd5:	89 d0                	mov    %edx,%eax
 bd7:	8d 48 c4             	lea    -0x3c(%eax),%ecx
 bda:	8b 15 00 00 00 00    	mov    0x0,%edx
 be0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 be3:	01 c0                	add    %eax,%eax
 be5:	89 c3                	mov    %eax,%ebx
 be7:	c1 e3 04             	shl    $0x4,%ebx
 bea:	29 c3                	sub    %eax,%ebx
 bec:	89 d8                	mov    %ebx,%eax
 bee:	83 c0 3c             	add    $0x3c,%eax
 bf1:	01 c2                	add    %eax,%edx
 bf3:	8b 1d 00 00 00 00    	mov    0x0,%ebx
 bf9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 bfc:	83 c0 01             	add    $0x1,%eax
 bff:	01 c0                	add    %eax,%eax
 c01:	89 c6                	mov    %eax,%esi
 c03:	c1 e6 04             	shl    $0x4,%esi
 c06:	29 c6                	sub    %eax,%esi
 c08:	89 f0                	mov    %esi,%eax
 c0a:	01 d8                	add    %ebx,%eax
 c0c:	83 ec 04             	sub    $0x4,%esp
 c0f:	51                   	push   %ecx
 c10:	52                   	push   %edx
 c11:	50                   	push   %eax
 c12:	e8 fc ff ff ff       	call   c13 <kernel_free+0x15f>
 c17:	83 c4 10             	add    $0x10,%esp

				--regionCount;
 c1a:	a1 04 00 00 00       	mov    0x4,%eax
 c1f:	83 e8 01             	sub    $0x1,%eax
 c22:	a3 04 00 00 00       	mov    %eax,0x4
			}

			// Check for a merge with the previous region
			if (i > 0 && !regions[i - 1].reserved)
 c27:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 c2b:	0f 84 d5 00 00 00    	je     d06 <kernel_free+0x252>
 c31:	8b 15 00 00 00 00    	mov    0x0,%edx
 c37:	8b 45 f0             	mov    -0x10(%ebp),%eax
 c3a:	01 c0                	add    %eax,%eax
 c3c:	89 c1                	mov    %eax,%ecx
 c3e:	c1 e1 04             	shl    $0x4,%ecx
 c41:	29 c1                	sub    %eax,%ecx
 c43:	89 c8                	mov    %ecx,%eax
 c45:	83 e8 1e             	sub    $0x1e,%eax
 c48:	01 d0                	add    %edx,%eax
 c4a:	0f b6 40 08          	movzbl 0x8(%eax),%eax
 c4e:	84 c0                	test   %al,%al
 c50:	0f 85 b0 00 00 00    	jne    d06 <kernel_free+0x252>
			{
				// Adjust the size of the previous region
				regions[i - 1].size += regions[i].size; // merge
 c56:	8b 15 00 00 00 00    	mov    0x0,%edx
 c5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 c5f:	01 c0                	add    %eax,%eax
 c61:	89 c1                	mov    %eax,%ecx
 c63:	c1 e1 04             	shl    $0x4,%ecx
 c66:	29 c1                	sub    %eax,%ecx
 c68:	89 c8                	mov    %ecx,%eax
 c6a:	83 e8 1e             	sub    $0x1e,%eax
 c6d:	01 c2                	add    %eax,%edx
 c6f:	8b 0d 00 00 00 00    	mov    0x0,%ecx
 c75:	8b 45 f0             	mov    -0x10(%ebp),%eax
 c78:	01 c0                	add    %eax,%eax
 c7a:	89 c3                	mov    %eax,%ebx
 c7c:	c1 e3 04             	shl    $0x4,%ebx
 c7f:	29 c3                	sub    %eax,%ebx
 c81:	89 d8                	mov    %ebx,%eax
 c83:	83 e8 1e             	sub    $0x1e,%eax
 c86:	01 c8                	add    %ecx,%eax
 c88:	8b 08                	mov    (%eax),%ecx
 c8a:	8b 1d 00 00 00 00    	mov    0x0,%ebx
 c90:	8b 45 f0             	mov    -0x10(%ebp),%eax
 c93:	01 c0                	add    %eax,%eax
 c95:	89 c6                	mov    %eax,%esi
 c97:	c1 e6 04             	shl    $0x4,%esi
 c9a:	29 c6                	sub    %eax,%esi
 c9c:	89 f0                	mov    %esi,%eax
 c9e:	01 d8                	add    %ebx,%eax
 ca0:	8b 00                	mov    (%eax),%eax
 ca2:	01 c8                	add    %ecx,%eax
 ca4:	89 02                	mov    %eax,(%edx)

														// Move all following regions back by one
				memmove(regions + i, regions + i + 1, (regionCount - 1 - i)*sizeof(region_t));
 ca6:	a1 04 00 00 00       	mov    0x4,%eax
 cab:	2b 45 f0             	sub    -0x10(%ebp),%eax
 cae:	01 c0                	add    %eax,%eax
 cb0:	89 c2                	mov    %eax,%edx
 cb2:	c1 e2 04             	shl    $0x4,%edx
 cb5:	29 c2                	sub    %eax,%edx
 cb7:	89 d0                	mov    %edx,%eax
 cb9:	8d 48 e2             	lea    -0x1e(%eax),%ecx
 cbc:	8b 15 00 00 00 00    	mov    0x0,%edx
 cc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 cc5:	83 c0 01             	add    $0x1,%eax
 cc8:	01 c0                	add    %eax,%eax
 cca:	89 c3                	mov    %eax,%ebx
 ccc:	c1 e3 04             	shl    $0x4,%ebx
 ccf:	29 c3                	sub    %eax,%ebx
 cd1:	89 d8                	mov    %ebx,%eax
 cd3:	01 c2                	add    %eax,%edx
 cd5:	8b 1d 00 00 00 00    	mov    0x0,%ebx
 cdb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 cde:	01 c0                	add    %eax,%eax
 ce0:	89 c6                	mov    %eax,%esi
 ce2:	c1 e6 04             	shl    $0x4,%esi
 ce5:	29 c6                	sub    %eax,%esi
 ce7:	89 f0                	mov    %esi,%eax
 ce9:	01 d8                	add    %ebx,%eax
 ceb:	83 ec 04             	sub    $0x4,%esp
 cee:	51                   	push   %ecx
 cef:	52                   	push   %edx
 cf0:	50                   	push   %eax
 cf1:	e8 fc ff ff ff       	call   cf2 <kernel_free+0x23e>
 cf6:	83 c4 10             	add    $0x10,%esp

				--regionCount;
 cf9:	a1 04 00 00 00       	mov    0x4,%eax
 cfe:	83 e8 01             	sub    $0x1,%eax
 d01:	a3 04 00 00 00       	mov    %eax,0x4
			}

			if (i < firstFreeRegion)
 d06:	a1 0c 00 00 00       	mov    0xc,%eax
 d0b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
 d0e:	73 44                	jae    d54 <kernel_free+0x2a0>
			{
				firstFreeRegion = i;
 d10:	8b 45 f0             	mov    -0x10(%ebp),%eax
 d13:	a3 0c 00 00 00       	mov    %eax,0xc
				firstFreeAddr = regionAddress;
 d18:	8b 45 f4             	mov    -0xc(%ebp),%eax
 d1b:	a3 00 00 00 00       	mov    %eax,0x0
			}
			return;
 d20:	eb 32                	jmp    d54 <kernel_free+0x2a0>
		}

		regionAddress += regions[i].size;
 d22:	8b 15 00 00 00 00    	mov    0x0,%edx
 d28:	8b 45 f0             	mov    -0x10(%ebp),%eax
 d2b:	01 c0                	add    %eax,%eax
 d2d:	89 c1                	mov    %eax,%ecx
 d2f:	c1 e1 04             	shl    $0x4,%ecx
 d32:	29 c1                	sub    %eax,%ecx
 d34:	89 c8                	mov    %ecx,%eax
 d36:	01 d0                	add    %edx,%eax
 d38:	8b 00                	mov    (%eax),%eax
 d3a:	01 45 f4             	add    %eax,-0xc(%ebp)
		return;
	}

	// Walk the regions and find the correct one
	uint8_t* regionAddress = (uint8_t*)HEAP_START;
	for (uint32_t i = 0; i < regionCount; i++)
 d3d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 d41:	a1 04 00 00 00       	mov    0x4,%eax
 d46:	39 45 f0             	cmp    %eax,-0x10(%ebp)
 d49:	0f 82 8b fd ff ff    	jb     ada <kernel_free+0x26>
 d4f:	eb 04                	jmp    d55 <kernel_free+0x2a1>

void kernel_free(void* addr)
{
	if (addr == 0)
	{
		return;
 d51:	90                   	nop
 d52:	eb 01                	jmp    d55 <kernel_free+0x2a1>
			if (i < firstFreeRegion)
			{
				firstFreeRegion = i;
				firstFreeAddr = regionAddress;
			}
			return;
 d54:	90                   	nop
		}

		regionAddress += regions[i].size;
	}
 d55:	8d 65 f8             	lea    -0x8(%ebp),%esp
 d58:	5b                   	pop    %ebx
 d59:	5e                   	pop    %esi
 d5a:	5d                   	pop    %ebp
 d5b:	c3                   	ret    

keyboard.o:     file format elf32-i386


Disassembly of section .text:

00000000 <keyboard_ctrl_read_status>:

//===================================================================
// Keyboard private functions
//===================================================================

uint8_t keyboard_ctrl_read_status(){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp

	// Simply read status register
	return inportb(KEYBOARD_CTRL_STATS_REG);
   6:	83 ec 0c             	sub    $0xc,%esp
   9:	6a 64                	push   $0x64
   b:	e8 fc ff ff ff       	call   c <keyboard_ctrl_read_status+0xc>
  10:	83 c4 10             	add    $0x10,%esp
}
  13:	c9                   	leave  
  14:	c3                   	ret    

00000015 <keyboard_ctrl_send_command>:

void keyboard_ctrl_send_command(uint8_t cmd){
  15:	55                   	push   %ebp
  16:	89 e5                	mov    %esp,%ebp
  18:	83 ec 18             	sub    $0x18,%esp
  1b:	8b 45 08             	mov    0x8(%ebp),%eax
  1e:	88 45 f4             	mov    %al,-0xc(%ebp)

	// Wait until controller is ready to accept command.
	while(1){
		if((keyboard_ctrl_read_status() & KEYBOARD_CTRL_STATS_MASK_IN_BUF) == 0)
  21:	e8 fc ff ff ff       	call   22 <keyboard_ctrl_send_command+0xd>
  26:	0f b6 c0             	movzbl %al,%eax
  29:	83 e0 02             	and    $0x2,%eax
  2c:	85 c0                	test   %eax,%eax
  2e:	74 02                	je     32 <keyboard_ctrl_send_command+0x1d>
			break;
	}
  30:	eb ef                	jmp    21 <keyboard_ctrl_send_command+0xc>
void keyboard_ctrl_send_command(uint8_t cmd){

	// Wait until controller is ready to accept command.
	while(1){
		if((keyboard_ctrl_read_status() & KEYBOARD_CTRL_STATS_MASK_IN_BUF) == 0)
			break;
  32:	90                   	nop
	}

	// Send command to controller command register
	outportb(KEYBOARD_CTRL_CMD_REG, cmd);
  33:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  37:	83 ec 08             	sub    $0x8,%esp
  3a:	50                   	push   %eax
  3b:	6a 64                	push   $0x64
  3d:	e8 fc ff ff ff       	call   3e <keyboard_ctrl_send_command+0x29>
  42:	83 c4 10             	add    $0x10,%esp
}
  45:	90                   	nop
  46:	c9                   	leave  
  47:	c3                   	ret    

00000048 <keyboard_enc_read_buffer>:

uint8_t keyboard_enc_read_buffer(){
  48:	55                   	push   %ebp
  49:	89 e5                	mov    %esp,%ebp
  4b:	83 ec 08             	sub    $0x8,%esp

	// Simply read encoder buffer
	inportb(KEYBOARD_ENC_INPUT_BUF);
  4e:	83 ec 0c             	sub    $0xc,%esp
  51:	6a 60                	push   $0x60
  53:	e8 fc ff ff ff       	call   54 <keyboard_enc_read_buffer+0xc>
  58:	83 c4 10             	add    $0x10,%esp
}
  5b:	90                   	nop
  5c:	c9                   	leave  
  5d:	c3                   	ret    

0000005e <keyboard_enc_send_command>:

void keyboard_enc_send_command(uint8_t cmd){
  5e:	55                   	push   %ebp
  5f:	89 e5                	mov    %esp,%ebp
  61:	83 ec 18             	sub    $0x18,%esp
  64:	8b 45 08             	mov    0x8(%ebp),%eax
  67:	88 45 f4             	mov    %al,-0xc(%ebp)

	// Wait until controller is ready to accept command.
	while(1){
		if((keyboard_ctrl_read_status() & KEYBOARD_CTRL_STATS_MASK_IN_BUF) == 0)
  6a:	e8 fc ff ff ff       	call   6b <keyboard_enc_send_command+0xd>
  6f:	0f b6 c0             	movzbl %al,%eax
  72:	83 e0 02             	and    $0x2,%eax
  75:	85 c0                	test   %eax,%eax
  77:	74 02                	je     7b <keyboard_enc_send_command+0x1d>
			break;
	}
  79:	eb ef                	jmp    6a <keyboard_enc_send_command+0xc>
void keyboard_enc_send_command(uint8_t cmd){

	// Wait until controller is ready to accept command.
	while(1){
		if((keyboard_ctrl_read_status() & KEYBOARD_CTRL_STATS_MASK_IN_BUF) == 0)
			break;
  7b:	90                   	nop
	}

	// Send command to encoder command register
	outportb(KEYBOARD_ENC_CMD_REG, cmd);
  7c:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  80:	83 ec 08             	sub    $0x8,%esp
  83:	50                   	push   %eax
  84:	6a 60                	push   $0x60
  86:	e8 fc ff ff ff       	call   87 <keyboard_enc_send_command+0x29>
  8b:	83 c4 10             	add    $0x10,%esp
}
  8e:	90                   	nop
  8f:	c9                   	leave  
  90:	c3                   	ret    

00000091 <i86_keyboard_irq>:

void i86_keyboard_irq(){
  91:	55                   	push   %ebp
  92:	89 e5                	mov    %esp,%ebp
  94:	83 ec 18             	sub    $0x18,%esp

	asm volatile("add %esp, 12");
  97:	01 25 0c 00 00 00    	add    %esp,0xc
	asm volatile("pushal");
  9d:	60                   	pusha  
	asm volatile("cli");
  9e:	fa                   	cli    

	static int _extended = 0;

	int code = 0;
  9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// Check if there is anything in output buffer
	if(keyboard_ctrl_read_status() & KEYBOARD_CTRL_STATS_MASK_OUT_BUF){
  a6:	e8 fc ff ff ff       	call   a7 <i86_keyboard_irq+0x16>
  ab:	0f b6 c0             	movzbl %al,%eax
  ae:	83 e0 01             	and    $0x1,%eax
  b1:	85 c0                	test   %eax,%eax
  b3:	0f 84 eb 02 00 00    	je     3a4 <i86_keyboard_irq+0x313>

		// Read scan code
		code = keyboard_enc_read_buffer();
  b9:	e8 fc ff ff ff       	call   ba <i86_keyboard_irq+0x29>
  be:	0f b6 c0             	movzbl %al,%eax
  c1:	89 45 f4             	mov    %eax,-0xc(%ebp)

		if(code == 0xE0 || code == 0xE1){
  c4:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
  cb:	74 09                	je     d6 <i86_keyboard_irq+0x45>
  cd:	81 7d f4 e1 00 00 00 	cmpl   $0xe1,-0xc(%ebp)
  d4:	75 0f                	jne    e5 <i86_keyboard_irq+0x54>

			_extended = 1;
  d6:	c7 05 08 00 00 00 01 	movl   $0x1,0x8
  dd:	00 00 00 
  e0:	e9 75 02 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>

		} else {

			_extended = 0;
  e5:	c7 05 08 00 00 00 00 	movl   $0x0,0x8
  ec:	00 00 00 

			// Check if key is a break code(key up code)
			if(code & 0x80){
  ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  f2:	25 80 00 00 00       	and    $0x80,%eax
  f7:	85 c0                	test   %eax,%eax
  f9:	74 68                	je     163 <i86_keyboard_irq+0xd2>
				code -= 0x80;
  fb:	83 45 f4 80          	addl   $0xffffff80,-0xc(%ebp)

				int key = _keyboard_scancode_std[code];
  ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
 102:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
 109:	89 45 f0             	mov    %eax,-0x10(%ebp)

				// Check if key was a special key
				switch(key){
 10c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 10f:	2d 02 40 00 00       	sub    $0x4002,%eax
 114:	83 f8 06             	cmp    $0x6,%eax
 117:	0f 87 3d 02 00 00    	ja     35a <i86_keyboard_irq+0x2c9>
 11d:	8b 04 85 04 00 00 00 	mov    0x4(,%eax,4),%eax
 124:	ff e0                	jmp    *%eax

					case KEY_LCTRL:
					case KEY_RCTRL:
						_status.ctrl = 0;
 126:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 12d:	83 e0 df             	and    $0xffffffdf,%eax
 130:	a2 02 00 00 00       	mov    %al,0x2
						break;
 135:	e9 20 02 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>

					case KEY_LSHIFT:
					case KEY_RSHIFT:
						_status.shift = 0;
 13a:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 141:	83 e0 f7             	and    $0xfffffff7,%eax
 144:	a2 02 00 00 00       	mov    %al,0x2
						break;
 149:	e9 0c 02 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>

					case KEY_LALT:
					case KEY_RALT:
						_status.alt = 0;
 14e:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 155:	83 e0 ef             	and    $0xffffffef,%eax
 158:	a2 02 00 00 00       	mov    %al,0x2
						break;
 15d:	90                   	nop
 15e:	e9 f7 01 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>
				}
			} else { // Make code (Key down code)

				_scancode = code;
 163:	8b 45 f4             	mov    -0xc(%ebp),%eax
 166:	a2 00 00 00 00       	mov    %al,0x0

				int key = _keyboard_scancode_std[code];
 16b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 16e:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
 175:	89 45 ec             	mov    %eax,-0x14(%ebp)

				switch(key){
 178:	8b 45 ec             	mov    -0x14(%ebp),%eax
 17b:	3d 04 40 00 00       	cmp    $0x4004,%eax
 180:	0f 84 95 00 00 00    	je     21b <i86_keyboard_irq+0x18a>
 186:	3d 04 40 00 00       	cmp    $0x4004,%eax
 18b:	7f 35                	jg     1c2 <i86_keyboard_irq+0x131>
 18d:	3d 01 40 00 00       	cmp    $0x4001,%eax
 192:	0f 84 97 00 00 00    	je     22f <i86_keyboard_irq+0x19e>
 198:	3d 01 40 00 00       	cmp    $0x4001,%eax
 19d:	7f 10                	jg     1af <i86_keyboard_irq+0x11e>
 19f:	3d 0f 30 00 00       	cmp    $0x300f,%eax
 1a4:	0f 84 ee 00 00 00    	je     298 <i86_keyboard_irq+0x207>
 1aa:	e9 ab 01 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>
 1af:	3d 02 40 00 00       	cmp    $0x4002,%eax
 1b4:	74 51                	je     207 <i86_keyboard_irq+0x176>
 1b6:	3d 03 40 00 00       	cmp    $0x4003,%eax
 1bb:	74 36                	je     1f3 <i86_keyboard_irq+0x162>
 1bd:	e9 98 01 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>
 1c2:	3d 07 40 00 00       	cmp    $0x4007,%eax
 1c7:	74 2a                	je     1f3 <i86_keyboard_irq+0x162>
 1c9:	3d 07 40 00 00       	cmp    $0x4007,%eax
 1ce:	7f 0c                	jg     1dc <i86_keyboard_irq+0x14b>
 1d0:	3d 06 40 00 00       	cmp    $0x4006,%eax
 1d5:	74 30                	je     207 <i86_keyboard_irq+0x176>
 1d7:	e9 7e 01 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>
 1dc:	3d 08 40 00 00       	cmp    $0x4008,%eax
 1e1:	74 38                	je     21b <i86_keyboard_irq+0x18a>
 1e3:	3d 10 40 00 00       	cmp    $0x4010,%eax
 1e8:	0f 84 0b 01 00 00    	je     2f9 <i86_keyboard_irq+0x268>
 1ee:	e9 67 01 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>

					case KEY_LCTRL:
					case KEY_RCTRL:
						_status.ctrl = 1;
 1f3:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 1fa:	83 c8 20             	or     $0x20,%eax
 1fd:	a2 02 00 00 00       	mov    %al,0x2
						break;
 202:	e9 53 01 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>

					case KEY_LSHIFT:
					case KEY_RSHIFT:
						_status.shift = 1;
 207:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 20e:	83 c8 08             	or     $0x8,%eax
 211:	a2 02 00 00 00       	mov    %al,0x2
						break;
 216:	e9 3f 01 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>

					case KEY_LALT:
					case KEY_RALT:
						_status.alt = 1;
 21b:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 222:	83 c8 10             	or     $0x10,%eax
 225:	a2 02 00 00 00       	mov    %al,0x2
						break;
 22a:	e9 2b 01 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>

					case KEY_CAPSLOCK:
						TOGGLE(_status.caps_lock);
 22f:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 236:	83 e0 04             	and    $0x4,%eax
 239:	84 c0                	test   %al,%al
 23b:	0f 94 c0             	sete   %al
 23e:	83 e0 01             	and    $0x1,%eax
 241:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 248:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 24f:	83 e0 fb             	and    $0xfffffffb,%eax
 252:	09 d0                	or     %edx,%eax
 254:	a2 02 00 00 00       	mov    %al,0x2
						keyboard_set_leds(
							_status.num_lock, 
							_status.caps_lock,
							_status.scroll_lock);
 259:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 260:	d0 e8                	shr    %al
 262:	83 e0 01             	and    $0x1,%eax
						_status.alt = 1;
						break;

					case KEY_CAPSLOCK:
						TOGGLE(_status.caps_lock);
						keyboard_set_leds(
 265:	0f b6 c8             	movzbl %al,%ecx
							_status.num_lock, 
							_status.caps_lock,
 268:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 26f:	c0 e8 02             	shr    $0x2,%al
 272:	83 e0 01             	and    $0x1,%eax
						_status.alt = 1;
						break;

					case KEY_CAPSLOCK:
						TOGGLE(_status.caps_lock);
						keyboard_set_leds(
 275:	0f b6 d0             	movzbl %al,%edx
							_status.num_lock, 
 278:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 27f:	83 e0 01             	and    $0x1,%eax
						_status.alt = 1;
						break;

					case KEY_CAPSLOCK:
						TOGGLE(_status.caps_lock);
						keyboard_set_leds(
 282:	0f b6 c0             	movzbl %al,%eax
 285:	83 ec 04             	sub    $0x4,%esp
 288:	51                   	push   %ecx
 289:	52                   	push   %edx
 28a:	50                   	push   %eax
 28b:	e8 fc ff ff ff       	call   28c <i86_keyboard_irq+0x1fb>
 290:	83 c4 10             	add    $0x10,%esp
							_status.num_lock, 
							_status.caps_lock,
							_status.scroll_lock);
						break;
 293:	e9 c2 00 00 00       	jmp    35a <i86_keyboard_irq+0x2c9>

					case KEY_KP_NUMLOCK:
						TOGGLE(_status.num_lock);
 298:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 29f:	83 e0 01             	and    $0x1,%eax
 2a2:	84 c0                	test   %al,%al
 2a4:	0f 94 c0             	sete   %al
 2a7:	83 e0 01             	and    $0x1,%eax
 2aa:	89 c2                	mov    %eax,%edx
 2ac:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 2b3:	83 e0 fe             	and    $0xfffffffe,%eax
 2b6:	09 d0                	or     %edx,%eax
 2b8:	a2 02 00 00 00       	mov    %al,0x2
						keyboard_set_leds(
							_status.num_lock, 
							_status.caps_lock,
							_status.scroll_lock);
 2bd:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 2c4:	d0 e8                	shr    %al
 2c6:	83 e0 01             	and    $0x1,%eax
							_status.scroll_lock);
						break;

					case KEY_KP_NUMLOCK:
						TOGGLE(_status.num_lock);
						keyboard_set_leds(
 2c9:	0f b6 c8             	movzbl %al,%ecx
							_status.num_lock, 
							_status.caps_lock,
 2cc:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 2d3:	c0 e8 02             	shr    $0x2,%al
 2d6:	83 e0 01             	and    $0x1,%eax
							_status.scroll_lock);
						break;

					case KEY_KP_NUMLOCK:
						TOGGLE(_status.num_lock);
						keyboard_set_leds(
 2d9:	0f b6 d0             	movzbl %al,%edx
							_status.num_lock, 
 2dc:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 2e3:	83 e0 01             	and    $0x1,%eax
							_status.scroll_lock);
						break;

					case KEY_KP_NUMLOCK:
						TOGGLE(_status.num_lock);
						keyboard_set_leds(
 2e6:	0f b6 c0             	movzbl %al,%eax
 2e9:	83 ec 04             	sub    $0x4,%esp
 2ec:	51                   	push   %ecx
 2ed:	52                   	push   %edx
 2ee:	50                   	push   %eax
 2ef:	e8 fc ff ff ff       	call   2f0 <i86_keyboard_irq+0x25f>
 2f4:	83 c4 10             	add    $0x10,%esp
							_status.num_lock, 
							_status.caps_lock,
							_status.scroll_lock);
						break;
 2f7:	eb 61                	jmp    35a <i86_keyboard_irq+0x2c9>

					case KEY_SCROLLLOCK:
						TOGGLE(_status.scroll_lock);
 2f9:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 300:	83 e0 02             	and    $0x2,%eax
 303:	84 c0                	test   %al,%al
 305:	0f 94 c0             	sete   %al
 308:	83 e0 01             	and    $0x1,%eax
 30b:	8d 14 00             	lea    (%eax,%eax,1),%edx
 30e:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 315:	83 e0 fd             	and    $0xfffffffd,%eax
 318:	09 d0                	or     %edx,%eax
 31a:	a2 02 00 00 00       	mov    %al,0x2
						keyboard_set_leds(
							_status.num_lock, 
							_status.caps_lock,
							_status.scroll_lock);
 31f:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 326:	d0 e8                	shr    %al
 328:	83 e0 01             	and    $0x1,%eax
							_status.scroll_lock);
						break;

					case KEY_SCROLLLOCK:
						TOGGLE(_status.scroll_lock);
						keyboard_set_leds(
 32b:	0f b6 c8             	movzbl %al,%ecx
							_status.num_lock, 
							_status.caps_lock,
 32e:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 335:	c0 e8 02             	shr    $0x2,%al
 338:	83 e0 01             	and    $0x1,%eax
							_status.scroll_lock);
						break;

					case KEY_SCROLLLOCK:
						TOGGLE(_status.scroll_lock);
						keyboard_set_leds(
 33b:	0f b6 d0             	movzbl %al,%edx
							_status.num_lock, 
 33e:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 345:	83 e0 01             	and    $0x1,%eax
							_status.scroll_lock);
						break;

					case KEY_SCROLLLOCK:
						TOGGLE(_status.scroll_lock);
						keyboard_set_leds(
 348:	0f b6 c0             	movzbl %al,%eax
 34b:	83 ec 04             	sub    $0x4,%esp
 34e:	51                   	push   %ecx
 34f:	52                   	push   %edx
 350:	50                   	push   %eax
 351:	e8 fc ff ff ff       	call   352 <i86_keyboard_irq+0x2c1>
 356:	83 c4 10             	add    $0x10,%esp
							_status.num_lock, 
							_status.caps_lock,
							_status.scroll_lock);
						break;
 359:	90                   	nop
				}
			}
		}

		switch(code){
 35a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 35d:	3d fd 00 00 00       	cmp    $0xfd,%eax
 362:	74 1f                	je     383 <i86_keyboard_irq+0x2f2>
 364:	3d fe 00 00 00       	cmp    $0xfe,%eax
 369:	74 29                	je     394 <i86_keyboard_irq+0x303>
 36b:	3d fc 00 00 00       	cmp    $0xfc,%eax
 370:	75 32                	jne    3a4 <i86_keyboard_irq+0x313>

			case KEYBOARD_ERR_BAT_FAILED:
				_status.bat_res = 0;
 372:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 379:	83 e0 bf             	and    $0xffffffbf,%eax
 37c:	a2 02 00 00 00       	mov    %al,0x2
				break;
 381:	eb 21                	jmp    3a4 <i86_keyboard_irq+0x313>

			case KEYBOARD_ERR_DIAG_FAILED:
				_status.diag_res = 0;
 383:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 38a:	83 e0 7f             	and    $0x7f,%eax
 38d:	a2 02 00 00 00       	mov    %al,0x2
				break;
 392:	eb 10                	jmp    3a4 <i86_keyboard_irq+0x313>

			case KEYBOARD_ERR_RESEND_CMD:
				_status.resend_res = 1;
 394:	0f b6 05 03 00 00 00 	movzbl 0x3,%eax
 39b:	83 c8 01             	or     $0x1,%eax
 39e:	a2 03 00 00 00       	mov    %al,0x3
				break;
 3a3:	90                   	nop
		}
	}

	interruptdone(0);
 3a4:	83 ec 0c             	sub    $0xc,%esp
 3a7:	6a 00                	push   $0x0
 3a9:	e8 fc ff ff ff       	call   3aa <i86_keyboard_irq+0x319>
 3ae:	83 c4 10             	add    $0x10,%esp

	asm volatile("sti");
 3b1:	fb                   	sti    
	__asm__("popal; leave; iret");
 3b2:	61                   	popa   
 3b3:	c9                   	leave  
 3b4:	cf                   	iret   
}
 3b5:	90                   	nop
 3b6:	c9                   	leave  
 3b7:	c3                   	ret    

000003b8 <keyboard_get_scroll_lock>:

//===================================================================
// Keyboard Interface functions
//===================================================================

int keyboard_get_scroll_lock(){
 3b8:	55                   	push   %ebp
 3b9:	89 e5                	mov    %esp,%ebp
	return _status.scroll_lock;
 3bb:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 3c2:	d0 e8                	shr    %al
 3c4:	83 e0 01             	and    $0x1,%eax
 3c7:	0f b6 c0             	movzbl %al,%eax
}
 3ca:	5d                   	pop    %ebp
 3cb:	c3                   	ret    

000003cc <keyboard_get_numlock>:

int keyboard_get_numlock(){
 3cc:	55                   	push   %ebp
 3cd:	89 e5                	mov    %esp,%ebp
	return _status.num_lock;
 3cf:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 3d6:	83 e0 01             	and    $0x1,%eax
 3d9:	0f b6 c0             	movzbl %al,%eax
}
 3dc:	5d                   	pop    %ebp
 3dd:	c3                   	ret    

000003de <keyboard_get_capslock>:

int keyboard_get_capslock(){
 3de:	55                   	push   %ebp
 3df:	89 e5                	mov    %esp,%ebp
	return _status.caps_lock;
 3e1:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 3e8:	c0 e8 02             	shr    $0x2,%al
 3eb:	83 e0 01             	and    $0x1,%eax
 3ee:	0f b6 c0             	movzbl %al,%eax
}
 3f1:	5d                   	pop    %ebp
 3f2:	c3                   	ret    

000003f3 <keyboard_get_alt>:

int keyboard_get_alt(){
 3f3:	55                   	push   %ebp
 3f4:	89 e5                	mov    %esp,%ebp
	return _status.alt;
 3f6:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 3fd:	c0 e8 04             	shr    $0x4,%al
 400:	83 e0 01             	and    $0x1,%eax
 403:	0f b6 c0             	movzbl %al,%eax
}
 406:	5d                   	pop    %ebp
 407:	c3                   	ret    

00000408 <keyboard_get_ctrl>:

int keyboard_get_ctrl(){
 408:	55                   	push   %ebp
 409:	89 e5                	mov    %esp,%ebp
	return _status.ctrl;
 40b:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 412:	c0 e8 05             	shr    $0x5,%al
 415:	83 e0 01             	and    $0x1,%eax
 418:	0f b6 c0             	movzbl %al,%eax
}
 41b:	5d                   	pop    %ebp
 41c:	c3                   	ret    

0000041d <keyboard_get_shift>:

int keyboard_get_shift(){
 41d:	55                   	push   %ebp
 41e:	89 e5                	mov    %esp,%ebp
	return  _status.shift;
 420:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 427:	c0 e8 03             	shr    $0x3,%al
 42a:	83 e0 01             	and    $0x1,%eax
 42d:	0f b6 c0             	movzbl %al,%eax
}
 430:	5d                   	pop    %ebp
 431:	c3                   	ret    

00000432 <keyboard_ignore_resend>:

void keyboard_ignore_resend(){
 432:	55                   	push   %ebp
 433:	89 e5                	mov    %esp,%ebp
	_status.resend_res = 0;
 435:	0f b6 05 03 00 00 00 	movzbl 0x3,%eax
 43c:	83 e0 fe             	and    $0xfffffffe,%eax
 43f:	a2 03 00 00 00       	mov    %al,0x3
}
 444:	90                   	nop
 445:	5d                   	pop    %ebp
 446:	c3                   	ret    

00000447 <keyboard_check_resend>:

int keyboard_check_resend(){
 447:	55                   	push   %ebp
 448:	89 e5                	mov    %esp,%ebp
	return _status.resend_res;
 44a:	0f b6 05 03 00 00 00 	movzbl 0x3,%eax
 451:	83 e0 01             	and    $0x1,%eax
 454:	0f b6 c0             	movzbl %al,%eax
}
 457:	5d                   	pop    %ebp
 458:	c3                   	ret    

00000459 <keyboard_self_test>:

int keyboard_self_test(){
 459:	55                   	push   %ebp
 45a:	89 e5                	mov    %esp,%ebp
 45c:	83 ec 08             	sub    $0x8,%esp

	// Send self test command.
	keyboard_ctrl_send_command(KEYBOARD_CTRL_CMD_SELF_TEST);
 45f:	83 ec 0c             	sub    $0xc,%esp
 462:	68 aa 00 00 00       	push   $0xaa
 467:	e8 fc ff ff ff       	call   468 <keyboard_self_test+0xf>
 46c:	83 c4 10             	add    $0x10,%esp

	// Wait until data is ready
	while(1){
		if(keyboard_ctrl_read_status() & KEYBOARD_CTRL_STATS_MASK_OUT_BUF){
 46f:	e8 fc ff ff ff       	call   470 <keyboard_self_test+0x17>
 474:	0f b6 c0             	movzbl %al,%eax
 477:	83 e0 01             	and    $0x1,%eax
 47a:	85 c0                	test   %eax,%eax
 47c:	75 02                	jne    480 <keyboard_self_test+0x27>
			break;
		}
	}
 47e:	eb ef                	jmp    46f <keyboard_self_test+0x16>
	keyboard_ctrl_send_command(KEYBOARD_CTRL_CMD_SELF_TEST);

	// Wait until data is ready
	while(1){
		if(keyboard_ctrl_read_status() & KEYBOARD_CTRL_STATS_MASK_OUT_BUF){
			break;
 480:	90                   	nop
		}
	}

	// If data is 0x55, self test was passed.
	return (keyboard_enc_read_buffer() == 0x55) ? 1 : 0;
 481:	e8 fc ff ff ff       	call   482 <keyboard_self_test+0x29>
 486:	3c 55                	cmp    $0x55,%al
 488:	0f 94 c0             	sete   %al
 48b:	0f b6 c0             	movzbl %al,%eax
}
 48e:	c9                   	leave  
 48f:	c3                   	ret    

00000490 <keyboard_get_diag_res>:

int keyboard_get_diag_res(){
 490:	55                   	push   %ebp
 491:	89 e5                	mov    %esp,%ebp
	return _status.diag_res;
 493:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 49a:	c0 e8 07             	shr    $0x7,%al
 49d:	0f b6 c0             	movzbl %al,%eax
}
 4a0:	5d                   	pop    %ebp
 4a1:	c3                   	ret    

000004a2 <keyboard_get_bat_res>:

int keyboard_get_bat_res(){
 4a2:	55                   	push   %ebp
 4a3:	89 e5                	mov    %esp,%ebp
	return _status.bat_res;
 4a5:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 4ac:	c0 e8 06             	shr    $0x6,%al
 4af:	83 e0 01             	and    $0x1,%eax
 4b2:	0f b6 c0             	movzbl %al,%eax
}
 4b5:	5d                   	pop    %ebp
 4b6:	c3                   	ret    

000004b7 <keyboard_get_last_scan>:

uint8_t keyboard_get_last_scan(){
 4b7:	55                   	push   %ebp
 4b8:	89 e5                	mov    %esp,%ebp
	return _scancode;
 4ba:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
}
 4c1:	5d                   	pop    %ebp
 4c2:	c3                   	ret    

000004c3 <keyboard_get_last_key>:

KEYCODE keyboard_get_last_key(){
 4c3:	55                   	push   %ebp
 4c4:	89 e5                	mov    %esp,%ebp
	// Check if scan code is valid
	return (_scancode!=INVALID_SCANCODE) ? 
 4c6:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 4cd:	0f be c0             	movsbl %al,%eax
 4d0:	ba 00 00 00 00       	mov    $0x0,%edx
 4d5:	39 d0                	cmp    %edx,%eax
 4d7:	74 13                	je     4ec <keyboard_get_last_key+0x29>
		((KEYCODE)_keyboard_scancode_std [_scancode]) : 
 4d9:	0f b6 05 00 00 00 00 	movzbl 0x0,%eax
 4e0:	0f be c0             	movsbl %al,%eax
 4e3:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
	return _scancode;
}

KEYCODE keyboard_get_last_key(){
	// Check if scan code is valid
	return (_scancode!=INVALID_SCANCODE) ? 
 4ea:	eb 05                	jmp    4f1 <keyboard_get_last_key+0x2e>
 4ec:	b8 12 40 00 00       	mov    $0x4012,%eax
		((KEYCODE)_keyboard_scancode_std [_scancode]) : 
		(KEY_UNKNOWN);
}
 4f1:	5d                   	pop    %ebp
 4f2:	c3                   	ret    

000004f3 <keyboard_discard_last_key>:

void keyboard_discard_last_key(){
 4f3:	55                   	push   %ebp
 4f4:	89 e5                	mov    %esp,%ebp
	_scancode = INVALID_SCANCODE;
 4f6:	b8 00 00 00 00       	mov    $0x0,%eax
 4fb:	a2 00 00 00 00       	mov    %al,0x0
}
 500:	90                   	nop
 501:	5d                   	pop    %ebp
 502:	c3                   	ret    

00000503 <keyboard_set_leds>:

void keyboard_set_leds(int num, int caps, int scroll){
 503:	55                   	push   %ebp
 504:	89 e5                	mov    %esp,%ebp
 506:	83 ec 18             	sub    $0x18,%esp
	uint8_t data = 0;
 509:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

	if(num){
 50d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 511:	74 04                	je     517 <keyboard_set_leds+0x14>
		data |= (1<<1);
 513:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)
	}
	if(caps){
 517:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 51b:	74 04                	je     521 <keyboard_set_leds+0x1e>
		data |= (1<<2);
 51d:	80 4d f7 04          	orb    $0x4,-0x9(%ebp)
	}
	if(scroll){
 521:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 525:	74 04                	je     52b <keyboard_set_leds+0x28>
		data |= (1<<0);
 527:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
	}

	keyboard_enc_send_command(KEYBOARD_ENC_CMD_SET_LED);
 52b:	83 ec 0c             	sub    $0xc,%esp
 52e:	68 ed 00 00 00       	push   $0xed
 533:	e8 fc ff ff ff       	call   534 <keyboard_set_leds+0x31>
 538:	83 c4 10             	add    $0x10,%esp
	keyboard_enc_send_command(data);
 53b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
 53f:	83 ec 0c             	sub    $0xc,%esp
 542:	50                   	push   %eax
 543:	e8 fc ff ff ff       	call   544 <keyboard_set_leds+0x41>
 548:	83 c4 10             	add    $0x10,%esp
}
 54b:	90                   	nop
 54c:	c9                   	leave  
 54d:	c3                   	ret    

0000054e <keyboard_key_to_ascii>:

char keyboard_key_to_ascii(KEYCODE keycode){
 54e:	55                   	push   %ebp
 54f:	89 e5                	mov    %esp,%ebp
 551:	83 ec 10             	sub    $0x10,%esp

	uint8_t key = keycode;
 554:	8b 45 08             	mov    0x8(%ebp),%eax
 557:	88 45 ff             	mov    %al,-0x1(%ebp)

	if(isascii(key)){
 55a:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
 55e:	84 c0                	test   %al,%al
 560:	0f 88 10 01 00 00    	js     676 <keyboard_key_to_ascii+0x128>

		// TODO: change to XOR
		if(_status.shift || _status.caps_lock){
 566:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 56d:	83 e0 08             	and    $0x8,%eax
 570:	84 c0                	test   %al,%al
 572:	75 0e                	jne    582 <keyboard_key_to_ascii+0x34>
 574:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 57b:	83 e0 04             	and    $0x4,%eax
 57e:	84 c0                	test   %al,%al
 580:	74 10                	je     592 <keyboard_key_to_ascii+0x44>
			// Check if key is in a-z range
			if(key >= 'a' && key <= 'z'){
 582:	80 7d ff 60          	cmpb   $0x60,-0x1(%ebp)
 586:	76 0a                	jbe    592 <keyboard_key_to_ascii+0x44>
 588:	80 7d ff 7a          	cmpb   $0x7a,-0x1(%ebp)
 58c:	77 04                	ja     592 <keyboard_key_to_ascii+0x44>
				key -= 32;
 58e:	80 6d ff 20          	subb   $0x20,-0x1(%ebp)
			}
		}

		if(_status.shift && !_status.caps_lock){
 592:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 599:	83 e0 08             	and    $0x8,%eax
 59c:	84 c0                	test   %al,%al
 59e:	0f 84 cc 00 00 00    	je     670 <keyboard_key_to_ascii+0x122>
 5a4:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 5ab:	83 e0 04             	and    $0x4,%eax
 5ae:	84 c0                	test   %al,%al
 5b0:	0f 85 ba 00 00 00    	jne    670 <keyboard_key_to_ascii+0x122>
			if (key >= '0' && key <= '9'){
 5b6:	80 7d ff 2f          	cmpb   $0x2f,-0x1(%ebp)
 5ba:	76 5c                	jbe    618 <keyboard_key_to_ascii+0xca>
 5bc:	80 7d ff 39          	cmpb   $0x39,-0x1(%ebp)
 5c0:	77 56                	ja     618 <keyboard_key_to_ascii+0xca>
				switch (key) {
 5c2:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
 5c6:	83 e8 30             	sub    $0x30,%eax
 5c9:	83 f8 09             	cmp    $0x9,%eax
 5cc:	0f 87 9d 00 00 00    	ja     66f <keyboard_key_to_ascii+0x121>
 5d2:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
 5d9:	ff e0                	jmp    *%eax

					case '0':
						key = KEY_RIGHTPARENTHESIS;
 5db:	c6 45 ff 29          	movb   $0x29,-0x1(%ebp)
						break;
 5df:	eb 35                	jmp    616 <keyboard_key_to_ascii+0xc8>
					case '1':
						key = KEY_EXCLAMATION;
 5e1:	c6 45 ff 21          	movb   $0x21,-0x1(%ebp)
						break;
 5e5:	eb 2f                	jmp    616 <keyboard_key_to_ascii+0xc8>
					case '2':
						key = KEY_AT;
 5e7:	c6 45 ff 40          	movb   $0x40,-0x1(%ebp)
						break;
 5eb:	eb 29                	jmp    616 <keyboard_key_to_ascii+0xc8>
					case '3':
						key = KEY_EXCLAMATION;
 5ed:	c6 45 ff 21          	movb   $0x21,-0x1(%ebp)
						break;
 5f1:	eb 23                	jmp    616 <keyboard_key_to_ascii+0xc8>
					case '4':
						key = KEY_HASH;
 5f3:	c6 45 ff 23          	movb   $0x23,-0x1(%ebp)
						break;
 5f7:	eb 1d                	jmp    616 <keyboard_key_to_ascii+0xc8>
					case '5':
						key = KEY_PERCENT;
 5f9:	c6 45 ff 25          	movb   $0x25,-0x1(%ebp)
						break;
 5fd:	eb 17                	jmp    616 <keyboard_key_to_ascii+0xc8>
					case '6':
						key = KEY_CARRET;
 5ff:	c6 45 ff 5e          	movb   $0x5e,-0x1(%ebp)
						break;
 603:	eb 11                	jmp    616 <keyboard_key_to_ascii+0xc8>
					case '7':
						key = KEY_AMPERSAND;
 605:	c6 45 ff 26          	movb   $0x26,-0x1(%ebp)
						break;
 609:	eb 0b                	jmp    616 <keyboard_key_to_ascii+0xc8>
					case '8':
						key = KEY_ASTERISK;
 60b:	c6 45 ff 2a          	movb   $0x2a,-0x1(%ebp)
						break;
 60f:	eb 05                	jmp    616 <keyboard_key_to_ascii+0xc8>
					case '9':
						key = KEY_LEFTPARENTHESIS;
 611:	c6 45 ff 28          	movb   $0x28,-0x1(%ebp)
						break;
 615:	90                   	nop
				}
			} else {
 616:	eb 57                	jmp    66f <keyboard_key_to_ascii+0x121>
				switch (key) {
 618:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
 61c:	83 e8 27             	sub    $0x27,%eax
 61f:	83 f8 39             	cmp    $0x39,%eax
 622:	77 4c                	ja     670 <keyboard_key_to_ascii+0x122>
 624:	8b 04 85 48 00 00 00 	mov    0x48(,%eax,4),%eax
 62b:	ff e0                	jmp    *%eax
					case KEY_COMMA:
						key = KEY_LESS;
 62d:	c6 45 ff 3c          	movb   $0x3c,-0x1(%ebp)
						break;
 631:	eb 3d                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_DOT:
						key = KEY_GREATER;
 633:	c6 45 ff 3e          	movb   $0x3e,-0x1(%ebp)
						break;
 637:	eb 37                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_SLASH:
						key = KEY_QUESTION;
 639:	c6 45 ff 3f          	movb   $0x3f,-0x1(%ebp)
						break;
 63d:	eb 31                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_SEMICOLON:
						key = KEY_COLON;
 63f:	c6 45 ff 3a          	movb   $0x3a,-0x1(%ebp)
						break;
 643:	eb 2b                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_QUOTE:
						key = KEY_QUOTEDOUBLE;
 645:	c6 45 ff 22          	movb   $0x22,-0x1(%ebp)
						break;
 649:	eb 25                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_LEFTBRACKET :
						key = KEY_LEFTCURL;
 64b:	c6 45 ff 7b          	movb   $0x7b,-0x1(%ebp)
						break;
 64f:	eb 1f                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_RIGHTBRACKET :
						key = KEY_RIGHTCURL;
 651:	c6 45 ff 7d          	movb   $0x7d,-0x1(%ebp)
						break;
 655:	eb 19                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_GRAVE:
						key = KEY_TILDE;
 657:	c6 45 ff 7e          	movb   $0x7e,-0x1(%ebp)
						break;
 65b:	eb 13                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_MINUS:
						key = KEY_UNDERSCORE;
 65d:	c6 45 ff 5f          	movb   $0x5f,-0x1(%ebp)
						break;
 661:	eb 0d                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_PLUS:
						key = KEY_EQUAL;
 663:	c6 45 ff 3d          	movb   $0x3d,-0x1(%ebp)
						break;
 667:	eb 07                	jmp    670 <keyboard_key_to_ascii+0x122>

					case KEY_BACKSLASH:
						key = KEY_BAR;
 669:	c6 45 ff 7c          	movb   $0x7c,-0x1(%ebp)
						break;
 66d:	eb 01                	jmp    670 <keyboard_key_to_ascii+0x122>
						break;
					case '9':
						key = KEY_LEFTPARENTHESIS;
						break;
				}
			} else {
 66f:	90                   	nop
						break;
				}
			}
		}

		return key;
 670:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
 674:	eb 05                	jmp    67b <keyboard_key_to_ascii+0x12d>
	}
	// Scan code is not an ascii character
	return 0;
 676:	b8 00 00 00 00       	mov    $0x0,%eax
}
 67b:	c9                   	leave  
 67c:	c3                   	ret    

0000067d <keyboard_disable>:

void keyboard_disable(){
 67d:	55                   	push   %ebp
 67e:	89 e5                	mov    %esp,%ebp
 680:	83 ec 08             	sub    $0x8,%esp
	keyboard_ctrl_send_command(KEYBOARD_CTRL_CMD_DISABLE);
 683:	83 ec 0c             	sub    $0xc,%esp
 686:	68 ad 00 00 00       	push   $0xad
 68b:	e8 fc ff ff ff       	call   68c <keyboard_disable+0xf>
 690:	83 c4 10             	add    $0x10,%esp
	_status.enabled = 0;
 693:	0f b6 05 03 00 00 00 	movzbl 0x3,%eax
 69a:	83 e0 fd             	and    $0xfffffffd,%eax
 69d:	a2 03 00 00 00       	mov    %al,0x3
}
 6a2:	90                   	nop
 6a3:	c9                   	leave  
 6a4:	c3                   	ret    

000006a5 <keyboard_enable>:

void keyboard_enable(){
 6a5:	55                   	push   %ebp
 6a6:	89 e5                	mov    %esp,%ebp
 6a8:	83 ec 08             	sub    $0x8,%esp
	keyboard_ctrl_send_command(KEYBOARD_CTRL_CMD_ENABLE);
 6ab:	83 ec 0c             	sub    $0xc,%esp
 6ae:	68 ae 00 00 00       	push   $0xae
 6b3:	e8 fc ff ff ff       	call   6b4 <keyboard_enable+0xf>
 6b8:	83 c4 10             	add    $0x10,%esp
	_status.enabled = 1;
 6bb:	0f b6 05 03 00 00 00 	movzbl 0x3,%eax
 6c2:	83 c8 02             	or     $0x2,%eax
 6c5:	a2 03 00 00 00       	mov    %al,0x3
}
 6ca:	90                   	nop
 6cb:	c9                   	leave  
 6cc:	c3                   	ret    

000006cd <keyboard_is_disabled>:

int keyboard_is_disabled(){
 6cd:	55                   	push   %ebp
 6ce:	89 e5                	mov    %esp,%ebp
	return (_status.enabled) ? 0 : 1;
 6d0:	0f b6 05 03 00 00 00 	movzbl 0x3,%eax
 6d7:	83 e0 02             	and    $0x2,%eax
 6da:	84 c0                	test   %al,%al
 6dc:	0f 94 c0             	sete   %al
 6df:	0f b6 c0             	movzbl %al,%eax
}
 6e2:	5d                   	pop    %ebp
 6e3:	c3                   	ret    

000006e4 <keyboard_reset_system>:

void keyboard_reset_system(){
 6e4:	55                   	push   %ebp
 6e5:	89 e5                	mov    %esp,%ebp
 6e7:	83 ec 08             	sub    $0x8,%esp
	keyboard_ctrl_send_command(KEYBOARD_CTRL_CMD_WRITE_OUT_PORT);
 6ea:	83 ec 0c             	sub    $0xc,%esp
 6ed:	68 d1 00 00 00       	push   $0xd1
 6f2:	e8 fc ff ff ff       	call   6f3 <keyboard_reset_system+0xf>
 6f7:	83 c4 10             	add    $0x10,%esp
	keyboard_enc_send_command(0xFE);
 6fa:	83 ec 0c             	sub    $0xc,%esp
 6fd:	68 fe 00 00 00       	push   $0xfe
 702:	e8 fc ff ff ff       	call   703 <keyboard_reset_system+0x1f>
 707:	83 c4 10             	add    $0x10,%esp
}
 70a:	90                   	nop
 70b:	c9                   	leave  
 70c:	c3                   	ret    

0000070d <keyboard_install>:

void keyboard_install(int irq){
 70d:	55                   	push   %ebp
 70e:	89 e5                	mov    %esp,%ebp
 710:	83 ec 08             	sub    $0x8,%esp

	setvect(irq, i86_keyboard_irq);
 713:	83 ec 08             	sub    $0x8,%esp
 716:	68 00 00 00 00       	push   $0x0
 71b:	ff 75 08             	pushl  0x8(%ebp)
 71e:	e8 fc ff ff ff       	call   71f <keyboard_install+0x12>
 723:	83 c4 10             	add    $0x10,%esp

	_status.bat_res = 1;
 726:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 72d:	83 c8 40             	or     $0x40,%eax
 730:	a2 02 00 00 00       	mov    %al,0x2
	_scancode = 0;
 735:	c6 05 00 00 00 00 00 	movb   $0x0,0x0

	_status.num_lock = 0;
 73c:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 743:	83 e0 fe             	and    $0xfffffffe,%eax
 746:	a2 02 00 00 00       	mov    %al,0x2
	_status.caps_lock = 0;
 74b:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 752:	83 e0 fb             	and    $0xfffffffb,%eax
 755:	a2 02 00 00 00       	mov    %al,0x2
	_status.scroll_lock = 0;
 75a:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 761:	83 e0 fd             	and    $0xfffffffd,%eax
 764:	a2 02 00 00 00       	mov    %al,0x2

	keyboard_set_leds(0, 0, 0);
 769:	83 ec 04             	sub    $0x4,%esp
 76c:	6a 00                	push   $0x0
 76e:	6a 00                	push   $0x0
 770:	6a 00                	push   $0x0
 772:	e8 fc ff ff ff       	call   773 <keyboard_install+0x66>
 777:	83 c4 10             	add    $0x10,%esp

	_status.shift = 0;
 77a:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 781:	83 e0 f7             	and    $0xfffffff7,%eax
 784:	a2 02 00 00 00       	mov    %al,0x2
	_status.alt = 0;
 789:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 790:	83 e0 ef             	and    $0xffffffef,%eax
 793:	a2 02 00 00 00       	mov    %al,0x2
	_status.ctrl = 0;
 798:	0f b6 05 02 00 00 00 	movzbl 0x2,%eax
 79f:	83 e0 df             	and    $0xffffffdf,%eax
 7a2:	a2 02 00 00 00       	mov    %al,0x2
}
 7a7:	90                   	nop
 7a8:	c9                   	leave  
 7a9:	c3                   	ret    

000007aa <keyboard_set_autorepeat>:

void keyboard_set_autorepeat(uint8_t rate, uint8_t delay){
 7aa:	55                   	push   %ebp
 7ab:	89 e5                	mov    %esp,%ebp
 7ad:	83 ec 28             	sub    $0x28,%esp
 7b0:	8b 55 08             	mov    0x8(%ebp),%edx
 7b3:	8b 45 0c             	mov    0xc(%ebp),%eax
 7b6:	88 55 e4             	mov    %dl,-0x1c(%ebp)
 7b9:	88 45 e0             	mov    %al,-0x20(%ebp)
	
	// D - Delay
	// R - Rate
	// 0DDRRRRR 

	uint8_t data = rate & 0x1F;	
 7bc:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 7c0:	83 e0 1f             	and    $0x1f,%eax
 7c3:	88 45 f7             	mov    %al,-0x9(%ebp)
	data |= (delay & 0x03)<<5;
 7c6:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
 7ca:	83 e0 03             	and    $0x3,%eax
 7cd:	c1 e0 05             	shl    $0x5,%eax
 7d0:	89 c2                	mov    %eax,%edx
 7d2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
 7d6:	09 d0                	or     %edx,%eax
 7d8:	88 45 f7             	mov    %al,-0x9(%ebp)

	keyboard_enc_send_command(KEYBOARD_ENC_CMD_AUTODELAY);
 7db:	83 ec 0c             	sub    $0xc,%esp
 7de:	68 f3 00 00 00       	push   $0xf3
 7e3:	e8 fc ff ff ff       	call   7e4 <keyboard_set_autorepeat+0x3a>
 7e8:	83 c4 10             	add    $0x10,%esp
	keyboard_enc_send_command(data);
 7eb:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
 7ef:	83 ec 0c             	sub    $0xc,%esp
 7f2:	50                   	push   %eax
 7f3:	e8 fc ff ff ff       	call   7f4 <keyboard_set_autorepeat+0x4a>
 7f8:	83 c4 10             	add    $0x10,%esp
 7fb:	90                   	nop
 7fc:	c9                   	leave  
 7fd:	c3                   	ret    

kmalloc.o:     file format elf32-i386


Disassembly of section .text:

00000000 <kmalloc>:
#include <lib/string.h>

#include <mm/kernel_heap.h>

void* kmalloc(size_t size){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	return kernel_malloc(size);
   6:	83 ec 0c             	sub    $0xc,%esp
   9:	ff 75 08             	pushl  0x8(%ebp)
   c:	e8 fc ff ff ff       	call   d <kmalloc+0xd>
  11:	83 c4 10             	add    $0x10,%esp
}
  14:	c9                   	leave  
  15:	c3                   	ret    

00000016 <kmalloc_a>:

void* kmalloc_a(size_t size, size_t alignment){
  16:	55                   	push   %ebp
  17:	89 e5                	mov    %esp,%ebp
  19:	83 ec 08             	sub    $0x8,%esp
	return kernel_malloc_a(size, alignment);
  1c:	83 ec 08             	sub    $0x8,%esp
  1f:	ff 75 0c             	pushl  0xc(%ebp)
  22:	ff 75 08             	pushl  0x8(%ebp)
  25:	e8 fc ff ff ff       	call   26 <kmalloc_a+0x10>
  2a:	83 c4 10             	add    $0x10,%esp
}
  2d:	c9                   	leave  
  2e:	c3                   	ret    

0000002f <kmalloc_c>:

void* kmalloc_c(size_t size, const char* comment){
  2f:	55                   	push   %ebp
  30:	89 e5                	mov    %esp,%ebp
  32:	83 ec 08             	sub    $0x8,%esp
	return kernel_malloc_c(size, comment);
  35:	83 ec 08             	sub    $0x8,%esp
  38:	ff 75 0c             	pushl  0xc(%ebp)
  3b:	ff 75 08             	pushl  0x8(%ebp)
  3e:	e8 fc ff ff ff       	call   3f <kmalloc_c+0x10>
  43:	83 c4 10             	add    $0x10,%esp
}
  46:	c9                   	leave  
  47:	c3                   	ret    

00000048 <kmalloc_ac>:

void* kmalloc_ac(size_t size, size_t alignment, const char* comment){
  48:	55                   	push   %ebp
  49:	89 e5                	mov    %esp,%ebp
  4b:	83 ec 08             	sub    $0x8,%esp
	return kernel_malloc_ac(size, alignment, comment);
  4e:	83 ec 04             	sub    $0x4,%esp
  51:	ff 75 10             	pushl  0x10(%ebp)
  54:	ff 75 0c             	pushl  0xc(%ebp)
  57:	ff 75 08             	pushl  0x8(%ebp)
  5a:	e8 fc ff ff ff       	call   5b <kmalloc_ac+0x13>
  5f:	83 c4 10             	add    $0x10,%esp
}
  62:	c9                   	leave  
  63:	c3                   	ret    

00000064 <kfree>:

void kfree(void* addr){
  64:	55                   	push   %ebp
  65:	89 e5                	mov    %esp,%ebp
  67:	83 ec 08             	sub    $0x8,%esp
	kernel_free(addr);
  6a:	83 ec 0c             	sub    $0xc,%esp
  6d:	ff 75 08             	pushl  0x8(%ebp)
  70:	e8 fc ff ff ff       	call   71 <kfree+0xd>
  75:	83 c4 10             	add    $0x10,%esp
}
  78:	90                   	nop
  79:	c9                   	leave  
  7a:	c3                   	ret    

loader.o:     file format elf32-i386


Disassembly of section .text:

00000000 <MultiBootHeader>:
   0:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
   6:	00 00                	add    %al,(%eax)
   8:	fb                   	sti    
   9:	4f                   	dec    %edi
   a:	52                   	push   %edx
   b:	e4 b9                	in     $0xb9,%al

0000000c <_loader>:
   c:	b9 00 00 00 40       	mov    $0x40000000,%ecx
  11:	0f 22 d9             	mov    %ecx,%cr3
  14:	0f 20 e1             	mov    %cr4,%ecx
  17:	83 c9 10             	or     $0x10,%ecx
  1a:	0f 22 e1             	mov    %ecx,%cr4
  1d:	0f 20 c1             	mov    %cr0,%ecx
  20:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
  26:	0f 22 c1             	mov    %ecx,%cr0
  29:	8d 0d 31 00 00 00    	lea    0x31,%ecx
  2f:	ff e1                	jmp    *%ecx

00000031 <StartInHigherHalf>:
  31:	bc 00 40 00 00       	mov    $0x4000,%esp
  36:	50                   	push   %eax
  37:	81 c3 00 00 00 c0    	add    $0xc0000000,%ebx
  3d:	53                   	push   %ebx
  3e:	e8 fc ff ff ff       	call   3f <StartInHigherHalf+0xe>
  43:	fa                   	cli    
  44:	f4                   	hlt    

main.o:     file format elf32-i386


Disassembly of section .text:

00000000 <int32_test>:
// tell compiler our int32 function is external
extern void int32(unsigned char intnum, regs16_t *regs);
 
// int32 test
void int32_test()
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
    regs16_t regs;
     
    // switch to 320x200x256 graphics mode
    // regs.ax = 0x0013;

    regs.ax = 0x4F02;
   6:	66 c7 45 e8 02 4f    	movw   $0x4f02,-0x18(%ebp)
    regs.bx = 0x0118;
   c:	66 c7 45 e2 18 01    	movw   $0x118,-0x1e(%ebp)
    int32(0x10, &regs);
  12:	83 ec 08             	sub    $0x8,%esp
  15:	8d 45 da             	lea    -0x26(%ebp),%eax
  18:	50                   	push   %eax
  19:	6a 10                	push   $0x10
  1b:	e8 fc ff ff ff       	call   1c <int32_test+0x1c>
  20:	83 c4 10             	add    $0x10,%esp
     
    // full screen with blue color (1)
    memset((char *)0xA0000, 1, (320*200));
  23:	83 ec 04             	sub    $0x4,%esp
  26:	68 00 fa 00 00       	push   $0xfa00
  2b:	6a 01                	push   $0x1
  2d:	68 00 00 0a 00       	push   $0xa0000
  32:	e8 fc ff ff ff       	call   33 <int32_test+0x33>
  37:	83 c4 10             	add    $0x10,%esp
     
    // draw horizontal line from 100,80 to 100,240 in multiple colors
    for(y = 0; y < 200; y++)
  3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  41:	eb 29                	jmp    6c <int32_test+0x6c>
        memset((char *)0xA0000 + (y*320+80), 3, 160);
  43:	8b 55 f4             	mov    -0xc(%ebp),%edx
  46:	89 d0                	mov    %edx,%eax
  48:	c1 e0 02             	shl    $0x2,%eax
  4b:	01 d0                	add    %edx,%eax
  4d:	c1 e0 06             	shl    $0x6,%eax
  50:	05 50 00 0a 00       	add    $0xa0050,%eax
  55:	83 ec 04             	sub    $0x4,%esp
  58:	68 a0 00 00 00       	push   $0xa0
  5d:	6a 03                	push   $0x3
  5f:	50                   	push   %eax
  60:	e8 fc ff ff ff       	call   61 <int32_test+0x61>
  65:	83 c4 10             	add    $0x10,%esp
     
    // full screen with blue color (1)
    memset((char *)0xA0000, 1, (320*200));
     
    // draw horizontal line from 100,80 to 100,240 in multiple colors
    for(y = 0; y < 200; y++)
  68:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  6c:	81 7d f4 c7 00 00 00 	cmpl   $0xc7,-0xc(%ebp)
  73:	7e ce                	jle    43 <int32_test+0x43>
        memset((char *)0xA0000 + (y*320+80), 3, 160);
     
    // wait for key
    regs.ax = 0x0000;
  75:	66 c7 45 e8 00 00    	movw   $0x0,-0x18(%ebp)
    int32(0x16, &regs);
  7b:	83 ec 08             	sub    $0x8,%esp
  7e:	8d 45 da             	lea    -0x26(%ebp),%eax
  81:	50                   	push   %eax
  82:	6a 16                	push   $0x16
  84:	e8 fc ff ff ff       	call   85 <int32_test+0x85>
  89:	83 c4 10             	add    $0x10,%esp
     
    // switch to 80x25x16 text mode
    regs.ax = 0x0003;
  8c:	66 c7 45 e8 03 00    	movw   $0x3,-0x18(%ebp)
    int32(0x10, &regs);
  92:	83 ec 08             	sub    $0x8,%esp
  95:	8d 45 da             	lea    -0x26(%ebp),%eax
  98:	50                   	push   %eax
  99:	6a 10                	push   $0x10
  9b:	e8 fc ff ff ff       	call   9c <int32_test+0x9c>
  a0:	83 c4 10             	add    $0x10,%esp
}
  a3:	90                   	nop
  a4:	c9                   	leave  
  a5:	c3                   	ret    

000000a6 <init>:

void init(multiboot_info_t* mb_ptr){
  a6:	55                   	push   %ebp
  a7:	89 e5                	mov    %esp,%ebp
  a9:	83 ec 28             	sub    $0x28,%esp

	//asm volatile("xchgw %bx,%bx");

	clearScreen();
  ac:	e8 fc ff ff ff       	call   ad <init+0x7>

	printf("Multiboot at %#p\n", mb_ptr);
  b1:	83 ec 08             	sub    $0x8,%esp
  b4:	ff 75 08             	pushl  0x8(%ebp)
  b7:	68 35 00 00 00       	push   $0x35
  bc:	e8 fc ff ff ff       	call   bd <init+0x17>
  c1:	83 c4 10             	add    $0x10,%esp
	
	printf("OS kernel booting (%s)...\nPlease wait...\n", __FUNCTION__);
  c4:	83 ec 08             	sub    $0x8,%esp
  c7:	68 c8 02 00 00       	push   $0x2c8
  cc:	68 48 00 00 00       	push   $0x48
  d1:	e8 fc ff ff ff       	call   d2 <init+0x2c>
  d6:	83 c4 10             	add    $0x10,%esp

	printf("Initiating COM1 serial port\n");
  d9:	83 ec 0c             	sub    $0xc,%esp
  dc:	68 72 00 00 00       	push   $0x72
  e1:	e8 fc ff ff ff       	call   e2 <init+0x3c>
  e6:	83 c4 10             	add    $0x10,%esp

	init_serial(COM1, SERIAL_BAUD_115200, 8, 1, SERIAL_PARITY_NONE);
  e9:	83 ec 0c             	sub    $0xc,%esp
  ec:	6a 00                	push   $0x0
  ee:	6a 01                	push   $0x1
  f0:	6a 08                	push   $0x8
  f2:	6a 01                	push   $0x1
  f4:	6a 00                	push   $0x0
  f6:	e8 fc ff ff ff       	call   f7 <init+0x51>
  fb:	83 c4 20             	add    $0x20,%esp

	printf("Initializing HAL\n");
  fe:	83 ec 0c             	sub    $0xc,%esp
 101:	68 8f 00 00 00       	push   $0x8f
 106:	e8 fc ff ff ff       	call   107 <init+0x61>
 10b:	83 c4 10             	add    $0x10,%esp

	hal_initialize();
 10e:	e8 fc ff ff ff       	call   10f <init+0x69>

	printf("HAL initialization done!\n");
 113:	83 ec 0c             	sub    $0xc,%esp
 116:	68 a1 00 00 00       	push   $0xa1
 11b:	e8 fc ff ff ff       	call   11c <init+0x76>
 120:	83 c4 10             	add    $0x10,%esp

	setvect (0,(void (*)(void))divide_by_zero_fault);
 123:	83 ec 08             	sub    $0x8,%esp
 126:	68 00 00 00 00       	push   $0x0
 12b:	6a 00                	push   $0x0
 12d:	e8 fc ff ff ff       	call   12e <init+0x88>
 132:	83 c4 10             	add    $0x10,%esp
	setvect (1,(void (*)(void))single_step_trap);
 135:	83 ec 08             	sub    $0x8,%esp
 138:	68 00 00 00 00       	push   $0x0
 13d:	6a 01                	push   $0x1
 13f:	e8 fc ff ff ff       	call   140 <init+0x9a>
 144:	83 c4 10             	add    $0x10,%esp
	setvect (2,(void (*)(void))nmi_trap);
 147:	83 ec 08             	sub    $0x8,%esp
 14a:	68 00 00 00 00       	push   $0x0
 14f:	6a 02                	push   $0x2
 151:	e8 fc ff ff ff       	call   152 <init+0xac>
 156:	83 c4 10             	add    $0x10,%esp
	setvect (3,(void (*)(void))breakpoint_trap);
 159:	83 ec 08             	sub    $0x8,%esp
 15c:	68 00 00 00 00       	push   $0x0
 161:	6a 03                	push   $0x3
 163:	e8 fc ff ff ff       	call   164 <init+0xbe>
 168:	83 c4 10             	add    $0x10,%esp
	setvect (4,(void (*)(void))overflow_trap);
 16b:	83 ec 08             	sub    $0x8,%esp
 16e:	68 00 00 00 00       	push   $0x0
 173:	6a 04                	push   $0x4
 175:	e8 fc ff ff ff       	call   176 <init+0xd0>
 17a:	83 c4 10             	add    $0x10,%esp
	setvect (5,(void (*)(void))bounds_check_fault);
 17d:	83 ec 08             	sub    $0x8,%esp
 180:	68 00 00 00 00       	push   $0x0
 185:	6a 05                	push   $0x5
 187:	e8 fc ff ff ff       	call   188 <init+0xe2>
 18c:	83 c4 10             	add    $0x10,%esp
	setvect (6,(void (*)(void))invalid_opcode_fault);
 18f:	83 ec 08             	sub    $0x8,%esp
 192:	68 00 00 00 00       	push   $0x0
 197:	6a 06                	push   $0x6
 199:	e8 fc ff ff ff       	call   19a <init+0xf4>
 19e:	83 c4 10             	add    $0x10,%esp
	setvect (7,(void (*)(void))no_device_fault);
 1a1:	83 ec 08             	sub    $0x8,%esp
 1a4:	68 00 00 00 00       	push   $0x0
 1a9:	6a 07                	push   $0x7
 1ab:	e8 fc ff ff ff       	call   1ac <init+0x106>
 1b0:	83 c4 10             	add    $0x10,%esp
	setvect (8,(void (*)(void))double_fault_abort);
 1b3:	83 ec 08             	sub    $0x8,%esp
 1b6:	68 00 00 00 00       	push   $0x0
 1bb:	6a 08                	push   $0x8
 1bd:	e8 fc ff ff ff       	call   1be <init+0x118>
 1c2:	83 c4 10             	add    $0x10,%esp
	setvect (10,(void (*)(void))invalid_tss_fault);
 1c5:	83 ec 08             	sub    $0x8,%esp
 1c8:	68 00 00 00 00       	push   $0x0
 1cd:	6a 0a                	push   $0xa
 1cf:	e8 fc ff ff ff       	call   1d0 <init+0x12a>
 1d4:	83 c4 10             	add    $0x10,%esp
	setvect (11,(void (*)(void))no_segment_fault);
 1d7:	83 ec 08             	sub    $0x8,%esp
 1da:	68 00 00 00 00       	push   $0x0
 1df:	6a 0b                	push   $0xb
 1e1:	e8 fc ff ff ff       	call   1e2 <init+0x13c>
 1e6:	83 c4 10             	add    $0x10,%esp
	setvect (12,(void (*)(void))stack_fault);
 1e9:	83 ec 08             	sub    $0x8,%esp
 1ec:	68 00 00 00 00       	push   $0x0
 1f1:	6a 0c                	push   $0xc
 1f3:	e8 fc ff ff ff       	call   1f4 <init+0x14e>
 1f8:	83 c4 10             	add    $0x10,%esp
	setvect (13,(void (*)(void))general_protection_fault);
 1fb:	83 ec 08             	sub    $0x8,%esp
 1fe:	68 00 00 00 00       	push   $0x0
 203:	6a 0d                	push   $0xd
 205:	e8 fc ff ff ff       	call   206 <init+0x160>
 20a:	83 c4 10             	add    $0x10,%esp
	setvect (14,(void (*)(void))page_fault);
 20d:	83 ec 08             	sub    $0x8,%esp
 210:	68 00 00 00 00       	push   $0x0
 215:	6a 0e                	push   $0xe
 217:	e8 fc ff ff ff       	call   218 <init+0x172>
 21c:	83 c4 10             	add    $0x10,%esp
	setvect (16,(void (*)(void))fpu_fault);
 21f:	83 ec 08             	sub    $0x8,%esp
 222:	68 00 00 00 00       	push   $0x0
 227:	6a 10                	push   $0x10
 229:	e8 fc ff ff ff       	call   22a <init+0x184>
 22e:	83 c4 10             	add    $0x10,%esp
	setvect (17,(void (*)(void))alignment_check_fault);
 231:	83 ec 08             	sub    $0x8,%esp
 234:	68 00 00 00 00       	push   $0x0
 239:	6a 11                	push   $0x11
 23b:	e8 fc ff ff ff       	call   23c <init+0x196>
 240:	83 c4 10             	add    $0x10,%esp
	setvect (18,(void (*)(void))machine_check_abort);
 243:	83 ec 08             	sub    $0x8,%esp
 246:	68 00 00 00 00       	push   $0x0
 24b:	6a 12                	push   $0x12
 24d:	e8 fc ff ff ff       	call   24e <init+0x1a8>
 252:	83 c4 10             	add    $0x10,%esp
	setvect (19,(void (*)(void))simd_fpu_fault);
 255:	83 ec 08             	sub    $0x8,%esp
 258:	68 00 00 00 00       	push   $0x0
 25d:	6a 13                	push   $0x13
 25f:	e8 fc ff ff ff       	call   260 <init+0x1ba>
 264:	83 c4 10             	add    $0x10,%esp

	//printf("CPU Vendor: %s\n", get_cpu_vendor());

	//clearScreen();

	uint32_t memSize = 1024 + mb_ptr->mem_lower + mb_ptr->mem_upper;
 267:	8b 45 08             	mov    0x8(%ebp),%eax
 26a:	8b 50 04             	mov    0x4(%eax),%edx
 26d:	8b 45 08             	mov    0x8(%ebp),%eax
 270:	8b 40 08             	mov    0x8(%eax),%eax
 273:	01 d0                	add    %edx,%eax
 275:	05 00 04 00 00       	add    $0x400,%eax
 27a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	printf("Memory size: %i kB (%i MB)\n", memSize, memSize/1024);
 27d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 280:	c1 e8 0a             	shr    $0xa,%eax
 283:	83 ec 04             	sub    $0x4,%esp
 286:	50                   	push   %eax
 287:	ff 75 f0             	pushl  -0x10(%ebp)
 28a:	68 bb 00 00 00       	push   $0xbb
 28f:	e8 fc ff ff ff       	call   290 <init+0x1ea>
 294:	83 c4 10             	add    $0x10,%esp

	uint32_t kernel_end = (uint32_t)(&end);
 297:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

	printf("End: %#p\n", kernel_end);
 29e:	83 ec 08             	sub    $0x8,%esp
 2a1:	ff 75 ec             	pushl  -0x14(%ebp)
 2a4:	68 d7 00 00 00       	push   $0xd7
 2a9:	e8 fc ff ff ff       	call   2aa <init+0x204>
 2ae:	83 c4 10             	add    $0x10,%esp

	uint32_t kernel_size = kernel_end - 0xC0100000;
 2b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
 2b4:	05 00 00 f0 3f       	add    $0x3ff00000,%eax
 2b9:	89 45 e8             	mov    %eax,-0x18(%ebp)

	printf("Kernel size: %#i\n", kernel_size);
 2bc:	83 ec 08             	sub    $0x8,%esp
 2bf:	ff 75 e8             	pushl  -0x18(%ebp)
 2c2:	68 e1 00 00 00       	push   $0xe1
 2c7:	e8 fc ff ff ff       	call   2c8 <init+0x222>
 2cc:	83 c4 10             	add    $0x10,%esp

	pmmngr_init(memSize, 0xC0000000 + kernel_size);
 2cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
 2d2:	2d 00 00 00 40       	sub    $0x40000000,%eax
 2d7:	83 ec 08             	sub    $0x8,%esp
 2da:	50                   	push   %eax
 2db:	ff 75 f0             	pushl  -0x10(%ebp)
 2de:	e8 fc ff ff ff       	call   2df <init+0x239>
 2e3:	83 c4 10             	add    $0x10,%esp

	// Calculate number of mmap entries
	size_t entries = mb_ptr->mmap_length / sizeof(memory_map_t);
 2e6:	8b 45 08             	mov    0x8(%ebp),%eax
 2e9:	8b 40 2c             	mov    0x2c(%eax),%eax
 2ec:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
 2f1:	f7 e2                	mul    %edx
 2f3:	89 d0                	mov    %edx,%eax
 2f5:	c1 e8 04             	shr    $0x4,%eax
 2f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	
	memory_map_t* mem_map = (memory_map_t*)(mb_ptr->mmap_addr+0xC0000000);
 2fb:	8b 45 08             	mov    0x8(%ebp),%eax
 2fe:	8b 40 30             	mov    0x30(%eax),%eax
 301:	2d 00 00 00 40       	sub    $0x40000000,%eax
 306:	89 45 e0             	mov    %eax,-0x20(%ebp)

	printf("Mem_map: %#p\n", mem_map);
 309:	83 ec 08             	sub    $0x8,%esp
 30c:	ff 75 e0             	pushl  -0x20(%ebp)
 30f:	68 f3 00 00 00       	push   $0xf3
 314:	e8 fc ff ff ff       	call   315 <init+0x26f>
 319:	83 c4 10             	add    $0x10,%esp

	for(int i = 0; i < entries; ++i){
 31c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 323:	eb 5d                	jmp    382 <init+0x2dc>
			mem_map[i].length_high,
			mem_map[i].length_low,
			strMemoryTypes[mem_map[i].type]);*/
		

		if(mem_map[i].type == 1){
 325:	8b 55 f4             	mov    -0xc(%ebp),%edx
 328:	89 d0                	mov    %edx,%eax
 32a:	01 c0                	add    %eax,%eax
 32c:	01 d0                	add    %edx,%eax
 32e:	c1 e0 03             	shl    $0x3,%eax
 331:	89 c2                	mov    %eax,%edx
 333:	8b 45 e0             	mov    -0x20(%ebp),%eax
 336:	01 d0                	add    %edx,%eax
 338:	8b 40 14             	mov    0x14(%eax),%eax
 33b:	83 f8 01             	cmp    $0x1,%eax
 33e:	75 3e                	jne    37e <init+0x2d8>
			pmmngr_init_region(mem_map[i].base_addr_low + 0xC0000000, mem_map[i].length_low);
 340:	8b 55 f4             	mov    -0xc(%ebp),%edx
 343:	89 d0                	mov    %edx,%eax
 345:	01 c0                	add    %eax,%eax
 347:	01 d0                	add    %edx,%eax
 349:	c1 e0 03             	shl    $0x3,%eax
 34c:	89 c2                	mov    %eax,%edx
 34e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 351:	01 d0                	add    %edx,%eax
 353:	8b 48 0c             	mov    0xc(%eax),%ecx
 356:	8b 55 f4             	mov    -0xc(%ebp),%edx
 359:	89 d0                	mov    %edx,%eax
 35b:	01 c0                	add    %eax,%eax
 35d:	01 d0                	add    %edx,%eax
 35f:	c1 e0 03             	shl    $0x3,%eax
 362:	89 c2                	mov    %eax,%edx
 364:	8b 45 e0             	mov    -0x20(%ebp),%eax
 367:	01 d0                	add    %edx,%eax
 369:	8b 40 04             	mov    0x4(%eax),%eax
 36c:	2d 00 00 00 40       	sub    $0x40000000,%eax
 371:	83 ec 08             	sub    $0x8,%esp
 374:	51                   	push   %ecx
 375:	50                   	push   %eax
 376:	e8 fc ff ff ff       	call   377 <init+0x2d1>
 37b:	83 c4 10             	add    $0x10,%esp
	
	memory_map_t* mem_map = (memory_map_t*)(mb_ptr->mmap_addr+0xC0000000);

	printf("Mem_map: %#p\n", mem_map);

	for(int i = 0; i < entries; ++i){
 37e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 382:	8b 45 f4             	mov    -0xc(%ebp),%eax
 385:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 388:	72 9b                	jb     325 <init+0x27f>
			pmmngr_init_region(mem_map[i].base_addr_low + 0xC0000000, mem_map[i].length_low);
			//printf("Initializing region: A:%#p, S:%i\n", mem_map[i].base_addr_low  + 0xC0000000, mem_map[i].length_low);
		}
	}

	pmmngr_deinit_region(0xC0100000, kernel_size);
 38a:	83 ec 08             	sub    $0x8,%esp
 38d:	ff 75 e8             	pushl  -0x18(%ebp)
 390:	68 00 00 10 c0       	push   $0xc0100000
 395:	e8 fc ff ff ff       	call   396 <init+0x2f0>
 39a:	83 c4 10             	add    $0x10,%esp
	// This does a video mode switch
	// Do not enable until graphics mode driver and serial debug
	// output driver is developed.
	// int32_test();

	printf("Initializing VMM\n");
 39d:	83 ec 0c             	sub    $0xc,%esp
 3a0:	68 01 01 00 00       	push   $0x101
 3a5:	e8 fc ff ff ff       	call   3a6 <init+0x300>
 3aa:	83 c4 10             	add    $0x10,%esp

	vmmngr_initialize();
 3ad:	e8 fc ff ff ff       	call   3ae <init+0x308>

	//printf("Initializing kernel heap\n");

	//init_kernel_heap();

	printf("Initializing PCI\n");
 3b2:	83 ec 0c             	sub    $0xc,%esp
 3b5:	68 13 01 00 00       	push   $0x113
 3ba:	e8 fc ff ff ff       	call   3bb <init+0x315>
 3bf:	83 c4 10             	add    $0x10,%esp

	pciInit();
 3c2:	e8 fc ff ff ff       	call   3c3 <init+0x31d>

	printf("Installing keyboard\n");
 3c7:	83 ec 0c             	sub    $0xc,%esp
 3ca:	68 25 01 00 00       	push   $0x125
 3cf:	e8 fc ff ff ff       	call   3d0 <init+0x32a>
 3d4:	83 c4 10             	add    $0x10,%esp

	keyboard_install (33);
 3d7:	83 ec 0c             	sub    $0xc,%esp
 3da:	6a 21                	push   $0x21
 3dc:	e8 fc ff ff ff       	call   3dd <init+0x337>
 3e1:	83 c4 10             	add    $0x10,%esp

	keyboard_set_autorepeat(0x1F, 3);
 3e4:	83 ec 08             	sub    $0x8,%esp
 3e7:	6a 03                	push   $0x3
 3e9:	6a 1f                	push   $0x1f
 3eb:	e8 fc ff ff ff       	call   3ec <init+0x346>
 3f0:	83 c4 10             	add    $0x10,%esp
	//printf("Installing IRQ\n");

	// Install floppy disk on IR 38 (IRQ 6)
	//floppy_disk_install(38);

	printf("Kernel initialization done!\n");
 3f3:	83 ec 0c             	sub    $0xc,%esp
 3f6:	68 3a 01 00 00       	push   $0x13a
 3fb:	e8 fc ff ff ff       	call   3fc <init+0x356>
 400:	83 c4 10             	add    $0x10,%esp

	getch();
 403:	e8 fc ff ff ff       	call   404 <init+0x35e>
}
 408:	90                   	nop
 409:	c9                   	leave  
 40a:	c3                   	ret    

0000040b <sleep>:

void sleep (int ms) {
 40b:	55                   	push   %ebp
 40c:	89 e5                	mov    %esp,%ebp
 40e:	83 ec 18             	sub    $0x18,%esp

	int ticks = ms + get_tick_count ();
 411:	e8 fc ff ff ff       	call   412 <sleep+0x7>
 416:	89 c2                	mov    %eax,%edx
 418:	8b 45 08             	mov    0x8(%ebp),%eax
 41b:	01 d0                	add    %edx,%eax
 41d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	while (ticks > get_tick_count ())
 420:	90                   	nop
 421:	e8 fc ff ff ff       	call   422 <sleep+0x17>
 426:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 429:	7c f6                	jl     421 <sleep+0x16>
		;
}
 42b:	90                   	nop
 42c:	c9                   	leave  
 42d:	c3                   	ret    

0000042e <cmd>:

void cmd () {
 42e:	55                   	push   %ebp
 42f:	89 e5                	mov    %esp,%ebp
 431:	83 ec 08             	sub    $0x8,%esp

	printf ("\nCommand> ");
 434:	83 ec 0c             	sub    $0xc,%esp
 437:	68 57 01 00 00       	push   $0x157
 43c:	e8 fc ff ff ff       	call   43d <cmd+0xf>
 441:	83 c4 10             	add    $0x10,%esp
}
 444:	90                   	nop
 445:	c9                   	leave  
 446:	c3                   	ret    

00000447 <get_cmd>:

void get_cmd (char* buf, int n) {
 447:	55                   	push   %ebp
 448:	89 e5                	mov    %esp,%ebp
 44a:	83 ec 28             	sub    $0x28,%esp

	cmd ();
 44d:	e8 fc ff ff ff       	call   44e <get_cmd+0x7>

	KEYCODE key = KEY_UNKNOWN;
 452:	c7 45 ec 12 40 00 00 	movl   $0x4012,-0x14(%ebp)
	int	BufChar;

	//! get command string
	int i=0;
 459:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	while ( i < n ) {
 460:	e9 e8 00 00 00       	jmp    54d <get_cmd+0x106>

		//! buffer the next char
		BufChar = 1;
 465:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

		//! grab next char
		key = getch ();
 46c:	e8 fc ff ff ff       	call   46d <get_cmd+0x26>
 471:	89 45 ec             	mov    %eax,-0x14(%ebp)

		//! end of command if enter is pressed
		if (key==KEY_RETURN)
 474:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
 478:	0f 84 dd 00 00 00    	je     55b <get_cmd+0x114>
			break;

		//! backspace
		if (key==KEY_BACKSPACE) {
 47e:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
 482:	75 79                	jne    4fd <get_cmd+0xb6>

			//! dont buffer this char
			BufChar = 0;
 484:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

			if (i > 0) {
 48b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 48f:	7e 6c                	jle    4fd <get_cmd+0xb6>

				//! go back one char
				unsigned y, x;
				getCursor (&x, &y);
 491:	83 ec 08             	sub    $0x8,%esp
 494:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 497:	50                   	push   %eax
 498:	8d 45 e0             	lea    -0x20(%ebp),%eax
 49b:	50                   	push   %eax
 49c:	e8 fc ff ff ff       	call   49d <get_cmd+0x56>
 4a1:	83 c4 10             	add    $0x10,%esp
				if (x>0)
 4a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 4a7:	85 c0                	test   %eax,%eax
 4a9:	74 1e                	je     4c9 <get_cmd+0x82>
					setCursor (--x, y);
 4ab:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 4ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
 4b1:	83 e8 01             	sub    $0x1,%eax
 4b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
 4b7:	8b 45 e0             	mov    -0x20(%ebp),%eax
 4ba:	83 ec 08             	sub    $0x8,%esp
 4bd:	52                   	push   %edx
 4be:	50                   	push   %eax
 4bf:	e8 fc ff ff ff       	call   4c0 <get_cmd+0x79>
 4c4:	83 c4 10             	add    $0x10,%esp
 4c7:	eb 10                	jmp    4d9 <get_cmd+0x92>
				else {
					//! x is already 0, so go back one line
					y--;
 4c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 4cc:	83 e8 01             	sub    $0x1,%eax
 4cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					x = 80; // TODO: Do not hardcode
 4d2:	c7 45 e0 50 00 00 00 	movl   $0x50,-0x20(%ebp)
				}

				//! erase the character from display
				putch (' ');
 4d9:	83 ec 0c             	sub    $0xc,%esp
 4dc:	6a 20                	push   $0x20
 4de:	e8 fc ff ff ff       	call   4df <get_cmd+0x98>
 4e3:	83 c4 10             	add    $0x10,%esp
				setCursor (x, y);
 4e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 4e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
 4ec:	83 ec 08             	sub    $0x8,%esp
 4ef:	52                   	push   %edx
 4f0:	50                   	push   %eax
 4f1:	e8 fc ff ff ff       	call   4f2 <get_cmd+0xab>
 4f6:	83 c4 10             	add    $0x10,%esp

				//! go back one char in cmd buf
				i--;
 4f9:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
			}
		}

		//! only add the char if it is to be buffered
		if (BufChar) {
 4fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 501:	74 3d                	je     540 <get_cmd+0xf9>

			//! convert key to an ascii char and put it in buffer
			char c = keyboard_key_to_ascii (key);
 503:	83 ec 0c             	sub    $0xc,%esp
 506:	ff 75 ec             	pushl  -0x14(%ebp)
 509:	e8 fc ff ff ff       	call   50a <get_cmd+0xc3>
 50e:	83 c4 10             	add    $0x10,%esp
 511:	88 45 eb             	mov    %al,-0x15(%ebp)
			if (c != 0) { //insure its an ascii char
 514:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
 518:	74 26                	je     540 <get_cmd+0xf9>

				putch (c);
 51a:	0f be 45 eb          	movsbl -0x15(%ebp),%eax
 51e:	83 ec 0c             	sub    $0xc,%esp
 521:	50                   	push   %eax
 522:	e8 fc ff ff ff       	call   523 <get_cmd+0xdc>
 527:	83 c4 10             	add    $0x10,%esp
				buf [i++] = c;
 52a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 52d:	8d 50 01             	lea    0x1(%eax),%edx
 530:	89 55 f0             	mov    %edx,-0x10(%ebp)
 533:	89 c2                	mov    %eax,%edx
 535:	8b 45 08             	mov    0x8(%ebp),%eax
 538:	01 c2                	add    %eax,%edx
 53a:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
 53e:	88 02                	mov    %al,(%edx)
			}
		}

		sleep(20);
 540:	83 ec 0c             	sub    $0xc,%esp
 543:	6a 14                	push   $0x14
 545:	e8 fc ff ff ff       	call   546 <get_cmd+0xff>
 54a:	83 c4 10             	add    $0x10,%esp
	KEYCODE key = KEY_UNKNOWN;
	int	BufChar;

	//! get command string
	int i=0;
	while ( i < n ) {
 54d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 550:	3b 45 0c             	cmp    0xc(%ebp),%eax
 553:	0f 8c 0c ff ff ff    	jl     465 <get_cmd+0x1e>
 559:	eb 01                	jmp    55c <get_cmd+0x115>
		//! grab next char
		key = getch ();

		//! end of command if enter is pressed
		if (key==KEY_RETURN)
			break;
 55b:	90                   	nop

		sleep(20);
	}

	//! null terminate the string
	buf [i] = '\0';
 55c:	8b 55 f0             	mov    -0x10(%ebp),%edx
 55f:	8b 45 08             	mov    0x8(%ebp),%eax
 562:	01 d0                	add    %edx,%eax
 564:	c6 00 00             	movb   $0x0,(%eax)
}
 567:	90                   	nop
 568:	c9                   	leave  
 569:	c3                   	ret    

0000056a <run_cmd>:
	uint32_t useful_value;
	uint32_t useless_value;

} test_struct_t;

int run_cmd (char* cmd_buf) {
 56a:	55                   	push   %ebp
 56b:	89 e5                	mov    %esp,%ebp
 56d:	83 ec 28             	sub    $0x28,%esp

	//! exit command
	if (strcmp (cmd_buf, "exit") == 0) {
 570:	83 ec 08             	sub    $0x8,%esp
 573:	68 62 01 00 00       	push   $0x162
 578:	ff 75 08             	pushl  0x8(%ebp)
 57b:	e8 fc ff ff ff       	call   57c <run_cmd+0x12>
 580:	83 c4 10             	add    $0x10,%esp
 583:	85 c0                	test   %eax,%eax
 585:	75 0a                	jne    591 <run_cmd+0x27>
		return 1;
 587:	b8 01 00 00 00       	mov    $0x1,%eax
 58c:	e9 a1 02 00 00       	jmp    832 <run_cmd+0x2c8>
	}

	//! clear screen
	else if (strcmp (cmd_buf, "cls") == 0) {
 591:	83 ec 08             	sub    $0x8,%esp
 594:	68 67 01 00 00       	push   $0x167
 599:	ff 75 08             	pushl  0x8(%ebp)
 59c:	e8 fc ff ff ff       	call   59d <run_cmd+0x33>
 5a1:	83 c4 10             	add    $0x10,%esp
 5a4:	85 c0                	test   %eax,%eax
 5a6:	75 0a                	jne    5b2 <run_cmd+0x48>
		clearScreen();
 5a8:	e8 fc ff ff ff       	call   5a9 <run_cmd+0x3f>
 5ad:	e9 7b 02 00 00       	jmp    82d <run_cmd+0x2c3>
	}

	else if (strcmp(cmd_buf, "heap") == 0) {
 5b2:	83 ec 08             	sub    $0x8,%esp
 5b5:	68 6b 01 00 00       	push   $0x16b
 5ba:	ff 75 08             	pushl  0x8(%ebp)
 5bd:	e8 fc ff ff ff       	call   5be <run_cmd+0x54>
 5c2:	83 c4 10             	add    $0x10,%esp
 5c5:	85 c0                	test   %eax,%eax
 5c7:	0f 85 15 01 00 00    	jne    6e2 <run_cmd+0x178>
		printf("\nStarting kernel heap test.");
 5cd:	83 ec 0c             	sub    $0xc,%esp
 5d0:	68 70 01 00 00       	push   $0x170
 5d5:	e8 fc ff ff ff       	call   5d6 <run_cmd+0x6c>
 5da:	83 c4 10             	add    $0x10,%esp
		printf("\nAllocating int");
 5dd:	83 ec 0c             	sub    $0xc,%esp
 5e0:	68 8c 01 00 00       	push   $0x18c
 5e5:	e8 fc ff ff ff       	call   5e6 <run_cmd+0x7c>
 5ea:	83 c4 10             	add    $0x10,%esp

		int* i = kmalloc(sizeof(int));
 5ed:	83 ec 0c             	sub    $0xc,%esp
 5f0:	6a 04                	push   $0x4
 5f2:	e8 fc ff ff ff       	call   5f3 <run_cmd+0x89>
 5f7:	83 c4 10             	add    $0x10,%esp
 5fa:	89 45 ec             	mov    %eax,-0x14(%ebp)

		printf("\nAddress: %#(10)p", i);
 5fd:	83 ec 08             	sub    $0x8,%esp
 600:	ff 75 ec             	pushl  -0x14(%ebp)
 603:	68 9c 01 00 00       	push   $0x19c
 608:	e8 fc ff ff ff       	call   609 <run_cmd+0x9f>
 60d:	83 c4 10             	add    $0x10,%esp

		printf("\nWriting to int");
 610:	83 ec 0c             	sub    $0xc,%esp
 613:	68 ae 01 00 00       	push   $0x1ae
 618:	e8 fc ff ff ff       	call   619 <run_cmd+0xaf>
 61d:	83 c4 10             	add    $0x10,%esp

		*i = 4;
 620:	8b 45 ec             	mov    -0x14(%ebp),%eax
 623:	c7 00 04 00 00 00    	movl   $0x4,(%eax)

		printf("\nNew value: %i: ", *i);
 629:	8b 45 ec             	mov    -0x14(%ebp),%eax
 62c:	8b 00                	mov    (%eax),%eax
 62e:	83 ec 08             	sub    $0x8,%esp
 631:	50                   	push   %eax
 632:	68 be 01 00 00       	push   $0x1be
 637:	e8 fc ff ff ff       	call   638 <run_cmd+0xce>
 63c:	83 c4 10             	add    $0x10,%esp

		printf("\nAllocating struct");
 63f:	83 ec 0c             	sub    $0xc,%esp
 642:	68 cf 01 00 00       	push   $0x1cf
 647:	e8 fc ff ff ff       	call   648 <run_cmd+0xde>
 64c:	83 c4 10             	add    $0x10,%esp

		test_struct_t* p = kmalloc(sizeof(test_struct_t));
 64f:	83 ec 0c             	sub    $0xc,%esp
 652:	6a 08                	push   $0x8
 654:	e8 fc ff ff ff       	call   655 <run_cmd+0xeb>
 659:	83 c4 10             	add    $0x10,%esp
 65c:	89 45 e8             	mov    %eax,-0x18(%ebp)

		printf("\nAddress: %#(10)p", p);
 65f:	83 ec 08             	sub    $0x8,%esp
 662:	ff 75 e8             	pushl  -0x18(%ebp)
 665:	68 9c 01 00 00       	push   $0x19c
 66a:	e8 fc ff ff ff       	call   66b <run_cmd+0x101>
 66f:	83 c4 10             	add    $0x10,%esp

		printf("\nWriting to struct");
 672:	83 ec 0c             	sub    $0xc,%esp
 675:	68 e2 01 00 00       	push   $0x1e2
 67a:	e8 fc ff ff ff       	call   67b <run_cmd+0x111>
 67f:	83 c4 10             	add    $0x10,%esp

		p->useful_value = 10;
 682:	8b 45 e8             	mov    -0x18(%ebp),%eax
 685:	c7 00 0a 00 00 00    	movl   $0xa,(%eax)

		printf("\nNew value: %i: ", p->useful_value);
 68b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 68e:	8b 00                	mov    (%eax),%eax
 690:	83 ec 08             	sub    $0x8,%esp
 693:	50                   	push   %eax
 694:	68 be 01 00 00       	push   $0x1be
 699:	e8 fc ff ff ff       	call   69a <run_cmd+0x130>
 69e:	83 c4 10             	add    $0x10,%esp

		printf("\nFreeing int");
 6a1:	83 ec 0c             	sub    $0xc,%esp
 6a4:	68 f5 01 00 00       	push   $0x1f5
 6a9:	e8 fc ff ff ff       	call   6aa <run_cmd+0x140>
 6ae:	83 c4 10             	add    $0x10,%esp

		kfree(i);
 6b1:	83 ec 0c             	sub    $0xc,%esp
 6b4:	ff 75 ec             	pushl  -0x14(%ebp)
 6b7:	e8 fc ff ff ff       	call   6b8 <run_cmd+0x14e>
 6bc:	83 c4 10             	add    $0x10,%esp

		printf("\nFreeing struct");
 6bf:	83 ec 0c             	sub    $0xc,%esp
 6c2:	68 02 02 00 00       	push   $0x202
 6c7:	e8 fc ff ff ff       	call   6c8 <run_cmd+0x15e>
 6cc:	83 c4 10             	add    $0x10,%esp

		kfree(p);
 6cf:	83 ec 0c             	sub    $0xc,%esp
 6d2:	ff 75 e8             	pushl  -0x18(%ebp)
 6d5:	e8 fc ff ff ff       	call   6d6 <run_cmd+0x16c>
 6da:	83 c4 10             	add    $0x10,%esp
 6dd:	e9 4b 01 00 00       	jmp    82d <run_cmd+0x2c3>

	}

	//! help
	else if (strcmp (cmd_buf, "help") == 0) {
 6e2:	83 ec 08             	sub    $0x8,%esp
 6e5:	68 12 02 00 00       	push   $0x212
 6ea:	ff 75 08             	pushl  0x8(%ebp)
 6ed:	e8 fc ff ff ff       	call   6ee <run_cmd+0x184>
 6f2:	83 c4 10             	add    $0x10,%esp
 6f5:	85 c0                	test   %eax,%eax
 6f7:	75 15                	jne    70e <run_cmd+0x1a4>

		printf("\nHelp text...");
 6f9:	83 ec 0c             	sub    $0xc,%esp
 6fc:	68 17 02 00 00       	push   $0x217
 701:	e8 fc ff ff ff       	call   702 <run_cmd+0x198>
 706:	83 c4 10             	add    $0x10,%esp
 709:	e9 1f 01 00 00       	jmp    82d <run_cmd+0x2c3>
		serial_printf(COM1, "\n%*i", 5, 123456);
		serial_printf(COM1, "\n%0(5)i", 4);
		serial_printf(COM1, "\n%-(5)i", 4);
#endif
	}
	else if(strcmp (cmd_buf, "readfloppybuggy") == 0) {
 70e:	83 ec 08             	sub    $0x8,%esp
 711:	68 25 02 00 00       	push   $0x225
 716:	ff 75 08             	pushl  0x8(%ebp)
 719:	e8 fc ff ff ff       	call   71a <run_cmd+0x1b0>
 71e:	83 c4 10             	add    $0x10,%esp
 721:	85 c0                	test   %eax,%eax
 723:	0f 85 f4 00 00 00    	jne    81d <run_cmd+0x2b3>
		uint32_t sectornum = 0;
 729:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		char sectornumbuf[4];
		const uint8_t* sector = 0;
 730:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

		printf("Enter sector num: ");
 737:	83 ec 0c             	sub    $0xc,%esp
 73a:	68 35 02 00 00       	push   $0x235
 73f:	e8 fc ff ff ff       	call   740 <run_cmd+0x1d6>
 744:	83 c4 10             	add    $0x10,%esp
		get_cmd(sectornumbuf, 5);
 747:	83 ec 08             	sub    $0x8,%esp
 74a:	6a 05                	push   $0x5
 74c:	8d 45 dc             	lea    -0x24(%ebp),%eax
 74f:	50                   	push   %eax
 750:	e8 fc ff ff ff       	call   751 <run_cmd+0x1e7>
 755:	83 c4 10             	add    $0x10,%esp
		sectornum = atoi(sectornumbuf);
 758:	83 ec 0c             	sub    $0xc,%esp
 75b:	8d 45 dc             	lea    -0x24(%ebp),%eax
 75e:	50                   	push   %eax
 75f:	e8 fc ff ff ff       	call   760 <run_cmd+0x1f6>
 764:	83 c4 10             	add    $0x10,%esp
 767:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		printf("Sector %i contents:\n\n", sectornum);
 76a:	83 ec 08             	sub    $0x8,%esp
 76d:	ff 75 e4             	pushl  -0x1c(%ebp)
 770:	68 48 02 00 00       	push   $0x248
 775:	e8 fc ff ff ff       	call   776 <run_cmd+0x20c>
 77a:	83 c4 10             	add    $0x10,%esp

		sector = floppy_disk_read_sector(sectornum);
 77d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 780:	83 ec 0c             	sub    $0xc,%esp
 783:	50                   	push   %eax
 784:	e8 fc ff ff ff       	call   785 <run_cmd+0x21b>
 789:	83 c4 10             	add    $0x10,%esp
 78c:	89 45 e0             	mov    %eax,-0x20(%ebp)

		if(sector != 0){
 78f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 793:	74 66                	je     7fb <run_cmd+0x291>

			for(int c = 0; c < 512; c+=128){
 795:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 79c:	eb 52                	jmp    7f0 <run_cmd+0x286>
				for(int i = 0; i < 128; ++i){
 79e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 7a5:	eb 2a                	jmp    7d1 <run_cmd+0x267>
					printf("0x%a ", sector[c+i]);
 7a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
 7aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
 7ad:	01 d0                	add    %edx,%eax
 7af:	89 c2                	mov    %eax,%edx
 7b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
 7b4:	01 d0                	add    %edx,%eax
 7b6:	0f b6 00             	movzbl (%eax),%eax
 7b9:	0f b6 c0             	movzbl %al,%eax
 7bc:	83 ec 08             	sub    $0x8,%esp
 7bf:	50                   	push   %eax
 7c0:	68 5e 02 00 00       	push   $0x25e
 7c5:	e8 fc ff ff ff       	call   7c6 <run_cmd+0x25c>
 7ca:	83 c4 10             	add    $0x10,%esp
		sector = floppy_disk_read_sector(sectornum);

		if(sector != 0){

			for(int c = 0; c < 512; c+=128){
				for(int i = 0; i < 128; ++i){
 7cd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 7d1:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
 7d5:	7e d0                	jle    7a7 <run_cmd+0x23d>
					printf("0x%a ", sector[c+i]);
				}

				printf("Press any key to continue\n");
 7d7:	83 ec 0c             	sub    $0xc,%esp
 7da:	68 64 02 00 00       	push   $0x264
 7df:	e8 fc ff ff ff       	call   7e0 <run_cmd+0x276>
 7e4:	83 c4 10             	add    $0x10,%esp

				getch();
 7e7:	e8 fc ff ff ff       	call   7e8 <run_cmd+0x27e>

		sector = floppy_disk_read_sector(sectornum);

		if(sector != 0){

			for(int c = 0; c < 512; c+=128){
 7ec:	83 6d f4 80          	subl   $0xffffff80,-0xc(%ebp)
 7f0:	81 7d f4 ff 01 00 00 	cmpl   $0x1ff,-0xc(%ebp)
 7f7:	7e a5                	jle    79e <run_cmd+0x234>
 7f9:	eb 10                	jmp    80b <run_cmd+0x2a1>
				getch();
			}
		}
		else{

			printf("\nError reading from disk");
 7fb:	83 ec 0c             	sub    $0xc,%esp
 7fe:	68 7f 02 00 00       	push   $0x27f
 803:	e8 fc ff ff ff       	call   804 <run_cmd+0x29a>
 808:	83 c4 10             	add    $0x10,%esp
		}
		printf("\nDone\n");
 80b:	83 ec 0c             	sub    $0xc,%esp
 80e:	68 98 02 00 00       	push   $0x298
 813:	e8 fc ff ff ff       	call   814 <run_cmd+0x2aa>
 818:	83 c4 10             	add    $0x10,%esp
 81b:	eb 10                	jmp    82d <run_cmd+0x2c3>
	}

	//! invalid command
	else {
		printf ("\nUnkown command");
 81d:	83 ec 0c             	sub    $0xc,%esp
 820:	68 9f 02 00 00       	push   $0x29f
 825:	e8 fc ff ff ff       	call   826 <run_cmd+0x2bc>
 82a:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
 82d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 832:	c9                   	leave  
 833:	c3                   	ret    

00000834 <run>:

void run () {
 834:	55                   	push   %ebp
 835:	89 e5                	mov    %esp,%ebp
 837:	83 ec 78             	sub    $0x78,%esp
char	cmd_buf [100];

	while (1) {

		//! get command
		get_cmd (cmd_buf, 98);
 83a:	83 ec 08             	sub    $0x8,%esp
 83d:	6a 62                	push   $0x62
 83f:	8d 45 94             	lea    -0x6c(%ebp),%eax
 842:	50                   	push   %eax
 843:	e8 fc ff ff ff       	call   844 <run+0x10>
 848:	83 c4 10             	add    $0x10,%esp

		//! run command
		if (run_cmd (cmd_buf) == 1)
 84b:	83 ec 0c             	sub    $0xc,%esp
 84e:	8d 45 94             	lea    -0x6c(%ebp),%eax
 851:	50                   	push   %eax
 852:	e8 fc ff ff ff       	call   853 <run+0x1f>
 857:	83 c4 10             	add    $0x10,%esp
 85a:	83 f8 01             	cmp    $0x1,%eax
 85d:	74 02                	je     861 <run+0x2d>
			break;
	}
 85f:	eb d9                	jmp    83a <run+0x6>
		//! get command
		get_cmd (cmd_buf, 98);

		//! run command
		if (run_cmd (cmd_buf) == 1)
			break;
 861:	90                   	nop
	}
}
 862:	90                   	nop
 863:	c9                   	leave  
 864:	c3                   	ret    

00000865 <kernel_main>:
 *  The C entry point of the kernel.
 *  
 *	@return 	0 when done
 */
int kernel_main(unsigned int ebx)
{
 865:	55                   	push   %ebp
 866:	89 e5                	mov    %esp,%ebp
 868:	83 ec 18             	sub    $0x18,%esp
	multiboot_info_t* mb_ptr = (multiboot_info_t*) (ebx);
 86b:	8b 45 08             	mov    0x8(%ebp),%eax
 86e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	init(mb_ptr);
 871:	83 ec 0c             	sub    $0xc,%esp
 874:	ff 75 f4             	pushl  -0xc(%ebp)
 877:	e8 fc ff ff ff       	call   878 <kernel_main+0x13>
 87c:	83 c4 10             	add    $0x10,%esp

	clearScreen();
 87f:	e8 fc ff ff ff       	call   880 <kernel_main+0x1b>

	run ();
 884:	e8 fc ff ff ff       	call   885 <kernel_main+0x20>

	printf("\nExit command recieved\n");
 889:	83 ec 0c             	sub    $0xc,%esp
 88c:	68 af 02 00 00       	push   $0x2af
 891:	e8 fc ff ff ff       	call   892 <kernel_main+0x2d>
 896:	83 c4 10             	add    $0x10,%esp

	for(;;);
 899:	eb fe                	jmp    899 <kernel_main+0x34>

memcmp.o:     file format elf32-i386


Disassembly of section .text:

00000000 <memcmp>:
#include <lib/string.h>

int memcmp(const void* aptr, const void* bptr, size_t bytes){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
	const uint8_t* a = (const uint8_t*) aptr;
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	const uint8_t* b = (const uint8_t*) bptr;
   c:	8b 45 0c             	mov    0xc(%ebp),%eax
   f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	for(size_t i = 0; i < bytes; ++i){
  12:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  19:	eb 46                	jmp    61 <memcmp+0x61>
		if(a[i] < b[i])
  1b:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  21:	01 d0                	add    %edx,%eax
  23:	0f b6 10             	movzbl (%eax),%edx
  26:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  29:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2c:	01 c8                	add    %ecx,%eax
  2e:	0f b6 00             	movzbl (%eax),%eax
  31:	38 c2                	cmp    %al,%dl
  33:	73 07                	jae    3c <memcmp+0x3c>
			return -1;
  35:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  3a:	eb 32                	jmp    6e <memcmp+0x6e>
		else if(b[i] < a[i])
  3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  42:	01 d0                	add    %edx,%eax
  44:	0f b6 10             	movzbl (%eax),%edx
  47:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  4d:	01 c8                	add    %ecx,%eax
  4f:	0f b6 00             	movzbl (%eax),%eax
  52:	38 c2                	cmp    %al,%dl
  54:	73 07                	jae    5d <memcmp+0x5d>
			return 1;
  56:	b8 01 00 00 00       	mov    $0x1,%eax
  5b:	eb 11                	jmp    6e <memcmp+0x6e>

int memcmp(const void* aptr, const void* bptr, size_t bytes){
	const uint8_t* a = (const uint8_t*) aptr;
	const uint8_t* b = (const uint8_t*) bptr;

	for(size_t i = 0; i < bytes; ++i){
  5d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  61:	8b 45 fc             	mov    -0x4(%ebp),%eax
  64:	3b 45 10             	cmp    0x10(%ebp),%eax
  67:	72 b2                	jb     1b <memcmp+0x1b>
		if(a[i] < b[i])
			return -1;
		else if(b[i] < a[i])
			return 1;
	}
	return 0;
  69:	b8 00 00 00 00       	mov    $0x0,%eax
  6e:	c9                   	leave  
  6f:	c3                   	ret    

memcpy.o:     file format elf32-i386


Disassembly of section .text:

00000000 <memcpy>:
#include <lib/string.h>

void* memcpy(void* dest, const void* src, size_t bytes){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
	uint8_t* destPtr = (uint8_t*) dest;
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	const uint8_t* srcPtr = (const uint8_t*) src;
   c:	8b 45 0c             	mov    0xc(%ebp),%eax
   f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	for(size_t i = 0; i < bytes; ++i){
  12:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  19:	eb 19                	jmp    34 <memcpy+0x34>
		destPtr[i] = srcPtr[i];
  1b:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  21:	01 c2                	add    %eax,%edx
  23:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  26:	8b 45 fc             	mov    -0x4(%ebp),%eax
  29:	01 c8                	add    %ecx,%eax
  2b:	0f b6 00             	movzbl (%eax),%eax
  2e:	88 02                	mov    %al,(%edx)

void* memcpy(void* dest, const void* src, size_t bytes){
	uint8_t* destPtr = (uint8_t*) dest;
	const uint8_t* srcPtr = (const uint8_t*) src;

	for(size_t i = 0; i < bytes; ++i){
  30:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  34:	8b 45 fc             	mov    -0x4(%ebp),%eax
  37:	3b 45 10             	cmp    0x10(%ebp),%eax
  3a:	72 df                	jb     1b <memcpy+0x1b>
		destPtr[i] = srcPtr[i];
	}

	return dest;
  3c:	8b 45 08             	mov    0x8(%ebp),%eax
  3f:	c9                   	leave  
  40:	c3                   	ret    

memmove.o:     file format elf32-i386


Disassembly of section .text:

00000000 <memmove>:
#include <lib/string.h>

void* memmove(void* dest, const void* src, size_t bytes){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
	uint8_t* destPtr = (uint8_t*) dest;
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	const uint8_t* srcPtr = (const uint8_t*) src;
   c:	8b 45 0c             	mov    0xc(%ebp),%eax
   f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if(destPtr < srcPtr){
  12:	8b 45 f4             	mov    -0xc(%ebp),%eax
  15:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  18:	73 2c                	jae    46 <memmove+0x46>
		for(size_t i = 0; i < bytes; ++i){
  1a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  21:	eb 19                	jmp    3c <memmove+0x3c>
			destPtr[i] = srcPtr[i];
  23:	8b 55 f4             	mov    -0xc(%ebp),%edx
  26:	8b 45 fc             	mov    -0x4(%ebp),%eax
  29:	01 c2                	add    %eax,%edx
  2b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  31:	01 c8                	add    %ecx,%eax
  33:	0f b6 00             	movzbl (%eax),%eax
  36:	88 02                	mov    %al,(%edx)
void* memmove(void* dest, const void* src, size_t bytes){
	uint8_t* destPtr = (uint8_t*) dest;
	const uint8_t* srcPtr = (const uint8_t*) src;

	if(destPtr < srcPtr){
		for(size_t i = 0; i < bytes; ++i){
  38:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  3c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  3f:	3b 45 10             	cmp    0x10(%ebp),%eax
  42:	72 df                	jb     23 <memmove+0x23>
  44:	eb 2d                	jmp    73 <memmove+0x73>
			destPtr[i] = srcPtr[i];
		}
	}else{ 	// 	If destination is after source in memory, we revese copying 
			//	to ensure that memory is not overwritten before it is copied.
		for(size_t i = bytes; i != 0; --i){
  46:	8b 45 10             	mov    0x10(%ebp),%eax
  49:	89 45 f8             	mov    %eax,-0x8(%ebp)
  4c:	eb 1f                	jmp    6d <memmove+0x6d>
			destPtr[i-1] = srcPtr[i-1];
  4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  51:	8d 50 ff             	lea    -0x1(%eax),%edx
  54:	8b 45 f4             	mov    -0xc(%ebp),%eax
  57:	01 c2                	add    %eax,%edx
  59:	8b 45 f8             	mov    -0x8(%ebp),%eax
  5c:	8d 48 ff             	lea    -0x1(%eax),%ecx
  5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  62:	01 c8                	add    %ecx,%eax
  64:	0f b6 00             	movzbl (%eax),%eax
  67:	88 02                	mov    %al,(%edx)
		for(size_t i = 0; i < bytes; ++i){
			destPtr[i] = srcPtr[i];
		}
	}else{ 	// 	If destination is after source in memory, we revese copying 
			//	to ensure that memory is not overwritten before it is copied.
		for(size_t i = bytes; i != 0; --i){
  69:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  6d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  71:	75 db                	jne    4e <memmove+0x4e>
			destPtr[i-1] = srcPtr[i-1];
		}
	}
	return dest;
  73:	8b 45 08             	mov    0x8(%ebp),%eax
  76:	c9                   	leave  
  77:	c3                   	ret    

memset.o:     file format elf32-i386


Disassembly of section .text:

00000000 <memset>:
#include <lib/string.h>

void* memset(void* bufptr, int32_t value, size_t bytes){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
	uint8_t* buf = (uint8_t*) bufptr;
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(size_t i = 0; i < bytes; ++i){
   c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  13:	eb 11                	jmp    26 <memset+0x26>
		buf[i] = (uint8_t)value;
  15:	8b 55 f8             	mov    -0x8(%ebp),%edx
  18:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1b:	01 d0                	add    %edx,%eax
  1d:	8b 55 0c             	mov    0xc(%ebp),%edx
  20:	88 10                	mov    %dl,(%eax)
#include <lib/string.h>

void* memset(void* bufptr, int32_t value, size_t bytes){
	uint8_t* buf = (uint8_t*) bufptr;
	for(size_t i = 0; i < bytes; ++i){
  22:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  26:	8b 45 fc             	mov    -0x4(%ebp),%eax
  29:	3b 45 10             	cmp    0x10(%ebp),%eax
  2c:	72 e7                	jb     15 <memset+0x15>
		buf[i] = (uint8_t)value;
	}
	return bufptr;
  2e:	8b 45 08             	mov    0x8(%ebp),%eax
}
  31:	c9                   	leave  
  32:	c3                   	ret    

monitor.o:     file format elf32-i386


Disassembly of section .text:

00000000 <offset>:
//===================================================================
// Private function implementations
//===================================================================

// Calculates the offset to the entry at (x,y) from video memory start.
inline uint32_t offset(uint32_t x, uint32_t y) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp

	return (x + (y * MONITOR_WIDTH));
   3:	8b 55 0c             	mov    0xc(%ebp),%edx
   6:	89 d0                	mov    %edx,%eax
   8:	c1 e0 02             	shl    $0x2,%eax
   b:	01 d0                	add    %edx,%eax
   d:	c1 e0 04             	shl    $0x4,%eax
  10:	89 c2                	mov    %eax,%edx
  12:	8b 45 08             	mov    0x8(%ebp),%eax
  15:	01 d0                	add    %edx,%eax

}
  17:	5d                   	pop    %ebp
  18:	c3                   	ret    

00000019 <scroll>:

void scroll(){
  19:	55                   	push   %ebp
  1a:	89 e5                	mov    %esp,%ebp
  1c:	53                   	push   %ebx
  1d:	83 ec 10             	sub    $0x10,%esp
	if(cursor_y>=25){
  20:	a1 04 00 00 00       	mov    0x4,%eax
  25:	83 f8 18             	cmp    $0x18,%eax
  28:	0f 86 97 00 00 00    	jbe    c5 <scroll+0xac>
		int i;
		for(i = 0; i < (80*24);++i){
  2e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  35:	eb 26                	jmp    5d <scroll+0x44>
			asm volatile("nop");
  37:	90                   	nop
			VIDMEM[i] = VIDMEM[i+80];
  38:	a1 00 00 00 00       	mov    0x0,%eax
  3d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  40:	01 d2                	add    %edx,%edx
  42:	01 c2                	add    %eax,%edx
  44:	a1 00 00 00 00       	mov    0x0,%eax
  49:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  4c:	83 c1 50             	add    $0x50,%ecx
  4f:	01 c9                	add    %ecx,%ecx
  51:	01 c8                	add    %ecx,%eax
  53:	0f b7 00             	movzwl (%eax),%eax
  56:	66 89 02             	mov    %ax,(%edx)
}

void scroll(){
	if(cursor_y>=25){
		int i;
		for(i = 0; i < (80*24);++i){
  59:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  5d:	81 7d f8 7f 07 00 00 	cmpl   $0x77f,-0x8(%ebp)
  64:	7e d1                	jle    37 <scroll+0x1e>
			asm volatile("nop");
			VIDMEM[i] = VIDMEM[i+80];
		}
		for(i; i < (80*25);++i){
  66:	eb 4a                	jmp    b2 <scroll+0x99>
			asm volatile("nop");
  68:	90                   	nop
			VIDMEM[i] = (character_entry_t){' ',foreground_color, background_color};
  69:	a1 00 00 00 00       	mov    0x0,%eax
  6e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  71:	01 d2                	add    %edx,%edx
  73:	01 d0                	add    %edx,%eax
  75:	0f b6 15 04 00 00 00 	movzbl 0x4,%edx
  7c:	89 d3                	mov    %edx,%ebx
  7e:	83 e3 0f             	and    $0xf,%ebx
  81:	0f b6 15 08 00 00 00 	movzbl 0x8,%edx
  88:	89 d1                	mov    %edx,%ecx
  8a:	83 e1 0f             	and    $0xf,%ecx
  8d:	c6 00 20             	movb   $0x20,(%eax)
  90:	83 e3 0f             	and    $0xf,%ebx
  93:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  97:	83 e2 f0             	and    $0xfffffff0,%edx
  9a:	09 da                	or     %ebx,%edx
  9c:	88 50 01             	mov    %dl,0x1(%eax)
  9f:	c1 e1 04             	shl    $0x4,%ecx
  a2:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  a6:	83 e2 0f             	and    $0xf,%edx
  a9:	09 ca                	or     %ecx,%edx
  ab:	88 50 01             	mov    %dl,0x1(%eax)
		int i;
		for(i = 0; i < (80*24);++i){
			asm volatile("nop");
			VIDMEM[i] = VIDMEM[i+80];
		}
		for(i; i < (80*25);++i){
  ae:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  b2:	81 7d f8 cf 07 00 00 	cmpl   $0x7cf,-0x8(%ebp)
  b9:	7e ad                	jle    68 <scroll+0x4f>
			asm volatile("nop");
			VIDMEM[i] = (character_entry_t){' ',foreground_color, background_color};
		}
		cursor_y = 24;
  bb:	c7 05 04 00 00 00 18 	movl   $0x18,0x4
  c2:	00 00 00 
	}
}
  c5:	90                   	nop
  c6:	83 c4 10             	add    $0x10,%esp
  c9:	5b                   	pop    %ebx
  ca:	5d                   	pop    %ebp
  cb:	c3                   	ret    

000000cc <monitor_putch>:

//===================================================================
// Interface functions
//===================================================================

void monitor_putch(char c) {
  cc:	55                   	push   %ebp
  cd:	89 e5                	mov    %esp,%ebp
  cf:	53                   	push   %ebx
  d0:	83 ec 04             	sub    $0x4,%esp
  d3:	8b 45 08             	mov    0x8(%ebp),%eax
  d6:	88 45 f8             	mov    %al,-0x8(%ebp)

	// Sort out special characters

	if(c == 0)
  d9:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
  dd:	0f 84 bc 00 00 00    	je     19f <monitor_putch+0xd3>
		return;

	if(c == '\n' || c == '\r'){
  e3:	80 7d f8 0a          	cmpb   $0xa,-0x8(%ebp)
  e7:	74 06                	je     ef <monitor_putch+0x23>
  e9:	80 7d f8 0d          	cmpb   $0xd,-0x8(%ebp)
  ed:	75 1c                	jne    10b <monitor_putch+0x3f>
		cursor_x = 0;
  ef:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
  f6:	00 00 00 
		++cursor_y;
  f9:	a1 04 00 00 00       	mov    0x4,%eax
  fe:	83 c0 01             	add    $0x1,%eax
 101:	a3 04 00 00 00       	mov    %eax,0x4
		return;
 106:	e9 95 00 00 00       	jmp    1a0 <monitor_putch+0xd4>
	}

	// Line wrap if needed
	if(cursor_x >= MONITOR_WIDTH){
 10b:	a1 00 00 00 00       	mov    0x0,%eax
 110:	83 f8 4f             	cmp    $0x4f,%eax
 113:	76 17                	jbe    12c <monitor_putch+0x60>
		
		cursor_x = 0;
 115:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 11c:	00 00 00 
		++cursor_y;
 11f:	a1 04 00 00 00       	mov    0x4,%eax
 124:	83 c0 01             	add    $0x1,%eax
 127:	a3 04 00 00 00       	mov    %eax,0x4

	}

	if (cursor_y >= 25)
 12c:	a1 04 00 00 00       	mov    0x4,%eax
 131:	83 f8 18             	cmp    $0x18,%eax
 134:	76 05                	jbe    13b <monitor_putch+0x6f>
		scroll ();
 136:	e8 fc ff ff ff       	call   137 <monitor_putch+0x6b>

	// Put ascii characters
	VIDMEM[offset(cursor_x++, cursor_y)] = 
 13b:	8b 1d 00 00 00 00    	mov    0x0,%ebx
 141:	8b 15 04 00 00 00    	mov    0x4,%edx
 147:	a1 00 00 00 00       	mov    0x0,%eax
 14c:	8d 48 01             	lea    0x1(%eax),%ecx
 14f:	89 0d 00 00 00 00    	mov    %ecx,0x0
 155:	52                   	push   %edx
 156:	50                   	push   %eax
 157:	e8 fc ff ff ff       	call   158 <monitor_putch+0x8c>
 15c:	83 c4 08             	add    $0x8,%esp
 15f:	01 c0                	add    %eax,%eax
 161:	01 d8                	add    %ebx,%eax
 163:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
 167:	0f b6 0d 04 00 00 00 	movzbl 0x4,%ecx
 16e:	89 cb                	mov    %ecx,%ebx
 170:	83 e3 0f             	and    $0xf,%ebx
 173:	0f b6 0d 08 00 00 00 	movzbl 0x8,%ecx
 17a:	83 e1 0f             	and    $0xf,%ecx
 17d:	88 10                	mov    %dl,(%eax)
 17f:	83 e3 0f             	and    $0xf,%ebx
 182:	0f b6 50 01          	movzbl 0x1(%eax),%edx
 186:	83 e2 f0             	and    $0xfffffff0,%edx
 189:	09 da                	or     %ebx,%edx
 18b:	88 50 01             	mov    %dl,0x1(%eax)
 18e:	c1 e1 04             	shl    $0x4,%ecx
 191:	0f b6 50 01          	movzbl 0x1(%eax),%edx
 195:	83 e2 0f             	and    $0xf,%edx
 198:	09 ca                	or     %ecx,%edx
 19a:	88 50 01             	mov    %dl,0x1(%eax)
 19d:	eb 01                	jmp    1a0 <monitor_putch+0xd4>
void monitor_putch(char c) {

	// Sort out special characters

	if(c == 0)
		return;
 19f:	90                   	nop
		scroll ();

	// Put ascii characters
	VIDMEM[offset(cursor_x++, cursor_y)] = 
		(character_entry_t){c,foreground_color, background_color};
}
 1a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 1a3:	c9                   	leave  
 1a4:	c3                   	ret    

000001a5 <monitor_puts>:

void monitor_puts(const char* s){
 1a5:	55                   	push   %ebp
 1a6:	89 e5                	mov    %esp,%ebp

	while(*s){
 1a8:	eb 18                	jmp    1c2 <monitor_puts+0x1d>

		monitor_putch(*(s++));
 1aa:	8b 45 08             	mov    0x8(%ebp),%eax
 1ad:	8d 50 01             	lea    0x1(%eax),%edx
 1b0:	89 55 08             	mov    %edx,0x8(%ebp)
 1b3:	0f b6 00             	movzbl (%eax),%eax
 1b6:	0f be c0             	movsbl %al,%eax
 1b9:	50                   	push   %eax
 1ba:	e8 fc ff ff ff       	call   1bb <monitor_puts+0x16>
 1bf:	83 c4 04             	add    $0x4,%esp
		(character_entry_t){c,foreground_color, background_color};
}

void monitor_puts(const char* s){

	while(*s){
 1c2:	8b 45 08             	mov    0x8(%ebp),%eax
 1c5:	0f b6 00             	movzbl (%eax),%eax
 1c8:	84 c0                	test   %al,%al
 1ca:	75 de                	jne    1aa <monitor_puts+0x5>

		monitor_putch(*(s++));
		
	}

}
 1cc:	90                   	nop
 1cd:	c9                   	leave  
 1ce:	c3                   	ret    

000001cf <monitor_clear>:

void monitor_clear(){
 1cf:	55                   	push   %ebp
 1d0:	89 e5                	mov    %esp,%ebp
 1d2:	53                   	push   %ebx
 1d3:	83 ec 10             	sub    $0x10,%esp
	for(int32_t i = 0; i < (MONITOR_WIDTH*MONITOR_HEIGHT); ++i){
 1d6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
 1dd:	eb 49                	jmp    228 <monitor_clear+0x59>
		VIDMEM[i] = (character_entry_t){' ',foreground_color, background_color};
 1df:	a1 00 00 00 00       	mov    0x0,%eax
 1e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
 1e7:	01 d2                	add    %edx,%edx
 1e9:	01 d0                	add    %edx,%eax
 1eb:	0f b6 15 04 00 00 00 	movzbl 0x4,%edx
 1f2:	89 d3                	mov    %edx,%ebx
 1f4:	83 e3 0f             	and    $0xf,%ebx
 1f7:	0f b6 15 08 00 00 00 	movzbl 0x8,%edx
 1fe:	89 d1                	mov    %edx,%ecx
 200:	83 e1 0f             	and    $0xf,%ecx
 203:	c6 00 20             	movb   $0x20,(%eax)
 206:	83 e3 0f             	and    $0xf,%ebx
 209:	0f b6 50 01          	movzbl 0x1(%eax),%edx
 20d:	83 e2 f0             	and    $0xfffffff0,%edx
 210:	09 da                	or     %ebx,%edx
 212:	88 50 01             	mov    %dl,0x1(%eax)
 215:	c1 e1 04             	shl    $0x4,%ecx
 218:	0f b6 50 01          	movzbl 0x1(%eax),%edx
 21c:	83 e2 0f             	and    $0xf,%edx
 21f:	09 ca                	or     %ecx,%edx
 221:	88 50 01             	mov    %dl,0x1(%eax)
	}

}

void monitor_clear(){
	for(int32_t i = 0; i < (MONITOR_WIDTH*MONITOR_HEIGHT); ++i){
 224:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
 228:	8b 45 f8             	mov    -0x8(%ebp),%eax
 22b:	3d cf 07 00 00       	cmp    $0x7cf,%eax
 230:	76 ad                	jbe    1df <monitor_clear+0x10>
		VIDMEM[i] = (character_entry_t){' ',foreground_color, background_color};
	}

	cursor_x = 0;
 232:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 239:	00 00 00 
	cursor_y = 0;
 23c:	c7 05 04 00 00 00 00 	movl   $0x0,0x4
 243:	00 00 00 
}
 246:	90                   	nop
 247:	83 c4 10             	add    $0x10,%esp
 24a:	5b                   	pop    %ebx
 24b:	5d                   	pop    %ebp
 24c:	c3                   	ret    

0000024d <monitor_setFColor>:

void monitor_setFColor(vga_color_t fc){
 24d:	55                   	push   %ebp
 24e:	89 e5                	mov    %esp,%ebp
	foreground_color = fc;
 250:	8b 45 08             	mov    0x8(%ebp),%eax
 253:	a2 04 00 00 00       	mov    %al,0x4
}
 258:	90                   	nop
 259:	5d                   	pop    %ebp
 25a:	c3                   	ret    

0000025b <monitor_setBColor>:

void monitor_setBColor(vga_color_t bc){
 25b:	55                   	push   %ebp
 25c:	89 e5                	mov    %esp,%ebp
	background_color = bc;
 25e:	8b 45 08             	mov    0x8(%ebp),%eax
 261:	a2 08 00 00 00       	mov    %al,0x8
}
 266:	90                   	nop
 267:	5d                   	pop    %ebp
 268:	c3                   	ret    

00000269 <monitor_setCursor>:

void monitor_setCursor(uint32_t x, uint32_t y){
 269:	55                   	push   %ebp
 26a:	89 e5                	mov    %esp,%ebp
	cursor_x = x;
 26c:	8b 45 08             	mov    0x8(%ebp),%eax
 26f:	a3 00 00 00 00       	mov    %eax,0x0
	cursor_y = y;
 274:	8b 45 0c             	mov    0xc(%ebp),%eax
 277:	a3 04 00 00 00       	mov    %eax,0x4
}
 27c:	90                   	nop
 27d:	5d                   	pop    %ebp
 27e:	c3                   	ret    

0000027f <monitor_getCursor>:

void monitor_getCursor(uint32_t* x, uint32_t* y){
 27f:	55                   	push   %ebp
 280:	89 e5                	mov    %esp,%ebp
	*x = cursor_x;
 282:	8b 15 00 00 00 00    	mov    0x0,%edx
 288:	8b 45 08             	mov    0x8(%ebp),%eax
 28b:	89 10                	mov    %edx,(%eax)
	*y = cursor_y;
 28d:	8b 15 04 00 00 00    	mov    0x4,%edx
 293:	8b 45 0c             	mov    0xc(%ebp),%eax
 296:	89 10                	mov    %edx,(%eax)
}
 298:	90                   	nop
 299:	5d                   	pop    %ebp
 29a:	c3                   	ret    

panic.o:     file format elf32-i386


Disassembly of section .text:

00000000 <kernel_panic>:
#include <kernel/panic.h>
#include <hal/hal.h>
#include <lib/stdarg.h>
#include <lib/stdio.h>

void kernel_panic (const char* fmt, ...){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	81 ec 14 01 00 00    	sub    $0x114,%esp

	disable();
   a:	e8 fc ff ff ff       	call   b <kernel_panic+0xb>

	va_list args;
	
	char buf[256] = {0};
   f:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
  15:	b8 00 00 00 00       	mov    $0x0,%eax
  1a:	b9 40 00 00 00       	mov    $0x40,%ecx
  1f:	89 d7                	mov    %edx,%edi
  21:	f3 ab                	rep stos %eax,%es:(%edi)

	va_start(args, fmt);
  23:	8d 45 0c             	lea    0xc(%ebp),%eax
  26:	89 45 f4             	mov    %eax,-0xc(%ebp)

	vsprintf(buf, fmt, args);
  29:	8b 45 08             	mov    0x8(%ebp),%eax
  2c:	83 ec 04             	sub    $0x4,%esp
  2f:	ff 75 f4             	pushl  -0xc(%ebp)
  32:	50                   	push   %eax
  33:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
  39:	50                   	push   %eax
  3a:	e8 fc ff ff ff       	call   3b <kernel_panic+0x3b>
  3f:	83 c4 10             	add    $0x10,%esp

	va_end(args);

	printf("[KERNEL_PANIC]: %s\n", buf);
  42:	83 ec 08             	sub    $0x8,%esp
  45:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
  4b:	50                   	push   %eax
  4c:	68 00 00 00 00       	push   $0x0
  51:	e8 fc ff ff ff       	call   52 <kernel_panic+0x52>
  56:	83 c4 10             	add    $0x10,%esp
}
  59:	90                   	nop
  5a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  5d:	c9                   	leave  
  5e:	c3                   	ret    

pci_device.o:     file format elf32-i386


Disassembly of section .text:

00000000 <pci_read_device_info>:
#include <pci/pci_device.h>

#include <pci/pci_io.h>

void pci_read_device_info(uint32_t id, PciDeviceInfo_t* info)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	if (!info)
   6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   a:	0f 84 b8 02 00 00    	je     2c8 <pci_read_device_info+0x2c8>
	{
		return;
	}

	info->vendorID = pci_read_w(id, PCI_CONFIG_VENDOR_ID);
  10:	83 ec 08             	sub    $0x8,%esp
  13:	6a 00                	push   $0x0
  15:	ff 75 08             	pushl  0x8(%ebp)
  18:	e8 fc ff ff ff       	call   19 <pci_read_device_info+0x19>
  1d:	83 c4 10             	add    $0x10,%esp
  20:	89 c2                	mov    %eax,%edx
  22:	8b 45 0c             	mov    0xc(%ebp),%eax
  25:	66 89 50 02          	mov    %dx,0x2(%eax)
	info->deviceID = pci_read_w(id, PCI_CONFIG_DEVICE_ID);
  29:	83 ec 08             	sub    $0x8,%esp
  2c:	6a 02                	push   $0x2
  2e:	ff 75 08             	pushl  0x8(%ebp)
  31:	e8 fc ff ff ff       	call   32 <pci_read_device_info+0x32>
  36:	83 c4 10             	add    $0x10,%esp
  39:	89 c2                	mov    %eax,%edx
  3b:	8b 45 0c             	mov    0xc(%ebp),%eax
  3e:	66 89 50 04          	mov    %dx,0x4(%eax)

	info->command_w = pci_read_w(id, PCI_CONFIG_COMMAND);
  42:	83 ec 08             	sub    $0x8,%esp
  45:	6a 04                	push   $0x4
  47:	ff 75 08             	pushl  0x8(%ebp)
  4a:	e8 fc ff ff ff       	call   4b <pci_read_device_info+0x4b>
  4f:	83 c4 10             	add    $0x10,%esp
  52:	89 c2                	mov    %eax,%edx
  54:	8b 45 0c             	mov    0xc(%ebp),%eax
  57:	66 89 50 06          	mov    %dx,0x6(%eax)
	info->status_w = pci_read_w(id, PCI_CONFIG_STATUS);
  5b:	83 ec 08             	sub    $0x8,%esp
  5e:	6a 06                	push   $0x6
  60:	ff 75 08             	pushl  0x8(%ebp)
  63:	e8 fc ff ff ff       	call   64 <pci_read_device_info+0x64>
  68:	83 c4 10             	add    $0x10,%esp
  6b:	89 c2                	mov    %eax,%edx
  6d:	8b 45 0c             	mov    0xc(%ebp),%eax
  70:	66 89 50 08          	mov    %dx,0x8(%eax)

	info->revisionID = pci_read_b(id, PCI_CONFIG_REVISION_ID);
  74:	83 ec 08             	sub    $0x8,%esp
  77:	6a 08                	push   $0x8
  79:	ff 75 08             	pushl  0x8(%ebp)
  7c:	e8 fc ff ff ff       	call   7d <pci_read_device_info+0x7d>
  81:	83 c4 10             	add    $0x10,%esp
  84:	89 c2                	mov    %eax,%edx
  86:	8b 45 0c             	mov    0xc(%ebp),%eax
  89:	88 50 0a             	mov    %dl,0xa(%eax)
	info->progIntf = pci_read_b(id, PCI_CONFIG_PROG_INTF);
  8c:	83 ec 08             	sub    $0x8,%esp
  8f:	6a 09                	push   $0x9
  91:	ff 75 08             	pushl  0x8(%ebp)
  94:	e8 fc ff ff ff       	call   95 <pci_read_device_info+0x95>
  99:	83 c4 10             	add    $0x10,%esp
  9c:	89 c2                	mov    %eax,%edx
  9e:	8b 45 0c             	mov    0xc(%ebp),%eax
  a1:	88 50 0b             	mov    %dl,0xb(%eax)
	info->subClass = pci_read_b(id, PCI_CONFIG_SUBCLASS);
  a4:	83 ec 08             	sub    $0x8,%esp
  a7:	6a 0a                	push   $0xa
  a9:	ff 75 08             	pushl  0x8(%ebp)
  ac:	e8 fc ff ff ff       	call   ad <pci_read_device_info+0xad>
  b1:	83 c4 10             	add    $0x10,%esp
  b4:	89 c2                	mov    %eax,%edx
  b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  b9:	88 50 0c             	mov    %dl,0xc(%eax)
	info->classCode = pci_read_b(id, PCI_CONFIG_CLASS_CODE);
  bc:	83 ec 08             	sub    $0x8,%esp
  bf:	6a 0b                	push   $0xb
  c1:	ff 75 08             	pushl  0x8(%ebp)
  c4:	e8 fc ff ff ff       	call   c5 <pci_read_device_info+0xc5>
  c9:	83 c4 10             	add    $0x10,%esp
  cc:	89 c2                	mov    %eax,%edx
  ce:	8b 45 0c             	mov    0xc(%ebp),%eax
  d1:	88 50 0d             	mov    %dl,0xd(%eax)

	info->cacheLineSize = pci_read_b(id, PCI_CONFIG_CACHELINE_SIZE);
  d4:	83 ec 08             	sub    $0x8,%esp
  d7:	6a 0c                	push   $0xc
  d9:	ff 75 08             	pushl  0x8(%ebp)
  dc:	e8 fc ff ff ff       	call   dd <pci_read_device_info+0xdd>
  e1:	83 c4 10             	add    $0x10,%esp
  e4:	89 c2                	mov    %eax,%edx
  e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  e9:	88 50 0e             	mov    %dl,0xe(%eax)
	info->latencyTimer = pci_read_b(id, PCI_CONFIG_LATENCY);
  ec:	83 ec 08             	sub    $0x8,%esp
  ef:	6a 0d                	push   $0xd
  f1:	ff 75 08             	pushl  0x8(%ebp)
  f4:	e8 fc ff ff ff       	call   f5 <pci_read_device_info+0xf5>
  f9:	83 c4 10             	add    $0x10,%esp
  fc:	89 c2                	mov    %eax,%edx
  fe:	8b 45 0c             	mov    0xc(%ebp),%eax
 101:	88 50 0f             	mov    %dl,0xf(%eax)
	info->headerType = pci_read_b(id, PCI_CONFIG_HEADER_TYPE);
 104:	83 ec 08             	sub    $0x8,%esp
 107:	6a 0e                	push   $0xe
 109:	ff 75 08             	pushl  0x8(%ebp)
 10c:	e8 fc ff ff ff       	call   10d <pci_read_device_info+0x10d>
 111:	83 c4 10             	add    $0x10,%esp
 114:	89 c2                	mov    %eax,%edx
 116:	8b 45 0c             	mov    0xc(%ebp),%eax
 119:	88 50 10             	mov    %dl,0x10(%eax)
	info->BIST = pci_read_b(id, PCI_CONFIG_BIST);
 11c:	83 ec 08             	sub    $0x8,%esp
 11f:	6a 0f                	push   $0xf
 121:	ff 75 08             	pushl  0x8(%ebp)
 124:	e8 fc ff ff ff       	call   125 <pci_read_device_info+0x125>
 129:	83 c4 10             	add    $0x10,%esp
 12c:	89 c2                	mov    %eax,%edx
 12e:	8b 45 0c             	mov    0xc(%ebp),%eax
 131:	88 50 11             	mov    %dl,0x11(%eax)

	// TODO: Fill out with all information from PCI
	switch (info->headerType & 0x7F) // Filter 7 lowest bits
 134:	8b 45 0c             	mov    0xc(%ebp),%eax
 137:	0f b6 40 10          	movzbl 0x10(%eax),%eax
 13b:	0f b6 c0             	movzbl %al,%eax
 13e:	83 e0 7f             	and    $0x7f,%eax
 141:	83 f8 01             	cmp    $0x1,%eax
 144:	0f 84 81 01 00 00    	je     2cb <pci_read_device_info+0x2cb>
 14a:	83 f8 02             	cmp    $0x2,%eax
 14d:	0f 84 7b 01 00 00    	je     2ce <pci_read_device_info+0x2ce>
 153:	85 c0                	test   %eax,%eax
 155:	74 05                	je     15c <pci_read_device_info+0x15c>
		break;
	case 2: // PCI-to-CardBus bridge

		break;
	default: // Invalid PCI device
		break;
 157:	e9 73 01 00 00       	jmp    2cf <pci_read_device_info+0x2cf>

	// TODO: Fill out with all information from PCI
	switch (info->headerType & 0x7F) // Filter 7 lowest bits
	{
	case 0: // PCI Device
		info->type0.BaseAddresses[0] = pci_read_l(id, PCI_TYPE0_CONFIG_BAR0);
 15c:	83 ec 08             	sub    $0x8,%esp
 15f:	6a 10                	push   $0x10
 161:	ff 75 08             	pushl  0x8(%ebp)
 164:	e8 fc ff ff ff       	call   165 <pci_read_device_info+0x165>
 169:	83 c4 10             	add    $0x10,%esp
 16c:	89 c2                	mov    %eax,%edx
 16e:	8b 45 0c             	mov    0xc(%ebp),%eax
 171:	89 50 14             	mov    %edx,0x14(%eax)
		info->type0.BaseAddresses[1] = pci_read_l(id, PCI_TYPE0_CONFIG_BAR1);
 174:	83 ec 08             	sub    $0x8,%esp
 177:	6a 14                	push   $0x14
 179:	ff 75 08             	pushl  0x8(%ebp)
 17c:	e8 fc ff ff ff       	call   17d <pci_read_device_info+0x17d>
 181:	83 c4 10             	add    $0x10,%esp
 184:	89 c2                	mov    %eax,%edx
 186:	8b 45 0c             	mov    0xc(%ebp),%eax
 189:	89 50 18             	mov    %edx,0x18(%eax)
		info->type0.BaseAddresses[2] = pci_read_l(id, PCI_TYPE0_CONFIG_BAR2);
 18c:	83 ec 08             	sub    $0x8,%esp
 18f:	6a 18                	push   $0x18
 191:	ff 75 08             	pushl  0x8(%ebp)
 194:	e8 fc ff ff ff       	call   195 <pci_read_device_info+0x195>
 199:	83 c4 10             	add    $0x10,%esp
 19c:	89 c2                	mov    %eax,%edx
 19e:	8b 45 0c             	mov    0xc(%ebp),%eax
 1a1:	89 50 1c             	mov    %edx,0x1c(%eax)
		info->type0.BaseAddresses[3] = pci_read_l(id, PCI_TYPE0_CONFIG_BAR3);
 1a4:	83 ec 08             	sub    $0x8,%esp
 1a7:	6a 1c                	push   $0x1c
 1a9:	ff 75 08             	pushl  0x8(%ebp)
 1ac:	e8 fc ff ff ff       	call   1ad <pci_read_device_info+0x1ad>
 1b1:	83 c4 10             	add    $0x10,%esp
 1b4:	89 c2                	mov    %eax,%edx
 1b6:	8b 45 0c             	mov    0xc(%ebp),%eax
 1b9:	89 50 20             	mov    %edx,0x20(%eax)
		info->type0.BaseAddresses[4] = pci_read_l(id, PCI_TYPE0_CONFIG_BAR4);
 1bc:	83 ec 08             	sub    $0x8,%esp
 1bf:	6a 20                	push   $0x20
 1c1:	ff 75 08             	pushl  0x8(%ebp)
 1c4:	e8 fc ff ff ff       	call   1c5 <pci_read_device_info+0x1c5>
 1c9:	83 c4 10             	add    $0x10,%esp
 1cc:	89 c2                	mov    %eax,%edx
 1ce:	8b 45 0c             	mov    0xc(%ebp),%eax
 1d1:	89 50 24             	mov    %edx,0x24(%eax)
		info->type0.BaseAddresses[5] = pci_read_l(id, PCI_TYPE0_CONFIG_BAR5);
 1d4:	83 ec 08             	sub    $0x8,%esp
 1d7:	6a 24                	push   $0x24
 1d9:	ff 75 08             	pushl  0x8(%ebp)
 1dc:	e8 fc ff ff ff       	call   1dd <pci_read_device_info+0x1dd>
 1e1:	83 c4 10             	add    $0x10,%esp
 1e4:	89 c2                	mov    %eax,%edx
 1e6:	8b 45 0c             	mov    0xc(%ebp),%eax
 1e9:	89 50 28             	mov    %edx,0x28(%eax)

		info->type0.CIS = pci_read_l(id, PCI_TYPE0_CONFIG_CARDBUS_CIS);
 1ec:	83 ec 08             	sub    $0x8,%esp
 1ef:	6a 28                	push   $0x28
 1f1:	ff 75 08             	pushl  0x8(%ebp)
 1f4:	e8 fc ff ff ff       	call   1f5 <pci_read_device_info+0x1f5>
 1f9:	83 c4 10             	add    $0x10,%esp
 1fc:	89 c2                	mov    %eax,%edx
 1fe:	8b 45 0c             	mov    0xc(%ebp),%eax
 201:	89 50 2c             	mov    %edx,0x2c(%eax)
		info->type0.SubVendorID = pci_read_w(id, PCI_TYPE0_CONFIG_SUBSYSTEM_VENDOR_ID);
 204:	83 ec 08             	sub    $0x8,%esp
 207:	6a 2c                	push   $0x2c
 209:	ff 75 08             	pushl  0x8(%ebp)
 20c:	e8 fc ff ff ff       	call   20d <pci_read_device_info+0x20d>
 211:	83 c4 10             	add    $0x10,%esp
 214:	89 c2                	mov    %eax,%edx
 216:	8b 45 0c             	mov    0xc(%ebp),%eax
 219:	66 89 50 30          	mov    %dx,0x30(%eax)
		info->type0.SubSystemID = pci_read_w(id, PCI_TYPE0_CONFIG_SUBSYSTEM_DEVICE_ID);
 21d:	83 ec 08             	sub    $0x8,%esp
 220:	6a 2e                	push   $0x2e
 222:	ff 75 08             	pushl  0x8(%ebp)
 225:	e8 fc ff ff ff       	call   226 <pci_read_device_info+0x226>
 22a:	83 c4 10             	add    $0x10,%esp
 22d:	89 c2                	mov    %eax,%edx
 22f:	8b 45 0c             	mov    0xc(%ebp),%eax
 232:	66 89 50 32          	mov    %dx,0x32(%eax)
		info->type0.ROMBaseAddress = pci_read_l(id, PCI_TYPE0_CONFIG_EXPANSION_ROM);
 236:	83 ec 08             	sub    $0x8,%esp
 239:	6a 30                	push   $0x30
 23b:	ff 75 08             	pushl  0x8(%ebp)
 23e:	e8 fc ff ff ff       	call   23f <pci_read_device_info+0x23f>
 243:	83 c4 10             	add    $0x10,%esp
 246:	89 c2                	mov    %eax,%edx
 248:	8b 45 0c             	mov    0xc(%ebp),%eax
 24b:	89 50 34             	mov    %edx,0x34(%eax)
		info->type0.CapabilitiesPtr = pci_read_b(id, PCI_TYPE0_CONFIG_CAPABILITIES);
 24e:	83 ec 08             	sub    $0x8,%esp
 251:	6a 34                	push   $0x34
 253:	ff 75 08             	pushl  0x8(%ebp)
 256:	e8 fc ff ff ff       	call   257 <pci_read_device_info+0x257>
 25b:	83 c4 10             	add    $0x10,%esp
 25e:	89 c2                	mov    %eax,%edx
 260:	8b 45 0c             	mov    0xc(%ebp),%eax
 263:	88 50 38             	mov    %dl,0x38(%eax)
		info->type0.InterruptLine = pci_read_b(id, PCI_TYPE0_CONFIG_INTERRUPT_LINE);
 266:	83 ec 08             	sub    $0x8,%esp
 269:	6a 3c                	push   $0x3c
 26b:	ff 75 08             	pushl  0x8(%ebp)
 26e:	e8 fc ff ff ff       	call   26f <pci_read_device_info+0x26f>
 273:	83 c4 10             	add    $0x10,%esp
 276:	89 c2                	mov    %eax,%edx
 278:	8b 45 0c             	mov    0xc(%ebp),%eax
 27b:	88 50 40             	mov    %dl,0x40(%eax)
		info->type0.InterruptPin = pci_read_b(id, PCI_TYPE0_CONFIG_INTERRUPT_PIN);
 27e:	83 ec 08             	sub    $0x8,%esp
 281:	6a 3d                	push   $0x3d
 283:	ff 75 08             	pushl  0x8(%ebp)
 286:	e8 fc ff ff ff       	call   287 <pci_read_device_info+0x287>
 28b:	83 c4 10             	add    $0x10,%esp
 28e:	89 c2                	mov    %eax,%edx
 290:	8b 45 0c             	mov    0xc(%ebp),%eax
 293:	88 50 41             	mov    %dl,0x41(%eax)
		info->type0.MinimumGrant = pci_read_b(id, PCI_TYPE0_CONFIG_MIN_GRANT);
 296:	83 ec 08             	sub    $0x8,%esp
 299:	6a 3e                	push   $0x3e
 29b:	ff 75 08             	pushl  0x8(%ebp)
 29e:	e8 fc ff ff ff       	call   29f <pci_read_device_info+0x29f>
 2a3:	83 c4 10             	add    $0x10,%esp
 2a6:	89 c2                	mov    %eax,%edx
 2a8:	8b 45 0c             	mov    0xc(%ebp),%eax
 2ab:	88 50 42             	mov    %dl,0x42(%eax)
		info->type0.MaximumLatency = pci_read_b(id, PCI_TYPE0_CONFIG_MAX_LATENCY);
 2ae:	83 ec 08             	sub    $0x8,%esp
 2b1:	6a 3f                	push   $0x3f
 2b3:	ff 75 08             	pushl  0x8(%ebp)
 2b6:	e8 fc ff ff ff       	call   2b7 <pci_read_device_info+0x2b7>
 2bb:	83 c4 10             	add    $0x10,%esp
 2be:	89 c2                	mov    %eax,%edx
 2c0:	8b 45 0c             	mov    0xc(%ebp),%eax
 2c3:	88 50 43             	mov    %dl,0x43(%eax)
		break;
 2c6:	eb 07                	jmp    2cf <pci_read_device_info+0x2cf>

void pci_read_device_info(uint32_t id, PciDeviceInfo_t* info)
{
	if (!info)
	{
		return;
 2c8:	90                   	nop
 2c9:	eb 04                	jmp    2cf <pci_read_device_info+0x2cf>
		info->type0.MinimumGrant = pci_read_b(id, PCI_TYPE0_CONFIG_MIN_GRANT);
		info->type0.MaximumLatency = pci_read_b(id, PCI_TYPE0_CONFIG_MAX_LATENCY);
		break;
	case 1: // PCI-to-PCI bridge

		break;
 2cb:	90                   	nop
 2cc:	eb 01                	jmp    2cf <pci_read_device_info+0x2cf>
	case 2: // PCI-to-CardBus bridge

		break;
 2ce:	90                   	nop
	default: // Invalid PCI device
		break;
	}
}
 2cf:	c9                   	leave  
 2d0:	c3                   	ret    

000002d1 <pci_device_name>:

const char* pci_device_name(uint32_t vendorID, uint32_t deviceID)
{
 2d1:	55                   	push   %ebp
 2d2:	89 e5                	mov    %esp,%ebp
	// TODO
	return "Unknown Device";
 2d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
 2d9:	5d                   	pop    %ebp
 2da:	c3                   	ret    

000002db <pci_class_name>:

const char* pci_class_name(uint32_t classCode, uint32_t subClass, uint32_t progIntf)
{
 2db:	55                   	push   %ebp
 2dc:	89 e5                	mov    %esp,%ebp
	switch ((classCode << 8) | subClass)
 2de:	8b 45 08             	mov    0x8(%ebp),%eax
 2e1:	c1 e0 08             	shl    $0x8,%eax
 2e4:	0b 45 0c             	or     0xc(%ebp),%eax
 2e7:	3d 80 07 00 00       	cmp    $0x780,%eax
 2ec:	0f 84 da 06 00 00    	je     9cc <pci_class_name+0x6f1>
 2f2:	3d 80 07 00 00       	cmp    $0x780,%eax
 2f7:	0f 87 78 02 00 00    	ja     575 <pci_class_name+0x29a>
 2fd:	3d 00 04 00 00       	cmp    $0x400,%eax
 302:	0f 84 e8 05 00 00    	je     8f0 <pci_class_name+0x615>
 308:	3d 00 04 00 00       	cmp    $0x400,%eax
 30d:	0f 87 36 01 00 00    	ja     449 <pci_class_name+0x16e>
 313:	3d 01 02 00 00       	cmp    $0x201,%eax
 318:	0f 84 64 05 00 00    	je     882 <pci_class_name+0x5a7>
 31e:	3d 01 02 00 00       	cmp    $0x201,%eax
 323:	0f 87 95 00 00 00    	ja     3be <pci_class_name+0xe3>
 329:	3d 03 01 00 00       	cmp    $0x103,%eax
 32e:	0f 84 12 05 00 00    	je     846 <pci_class_name+0x56b>
 334:	3d 03 01 00 00       	cmp    $0x103,%eax
 339:	77 3b                	ja     376 <pci_class_name+0x9b>
 33b:	3d 00 01 00 00       	cmp    $0x100,%eax
 340:	0f 84 e2 04 00 00    	je     828 <pci_class_name+0x54d>
 346:	3d 00 01 00 00       	cmp    $0x100,%eax
 34b:	77 0e                	ja     35b <pci_class_name+0x80>
 34d:	83 f8 01             	cmp    $0x1,%eax
 350:	0f 84 c8 04 00 00    	je     81e <pci_class_name+0x543>
 356:	e9 55 08 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 35b:	3d 01 01 00 00       	cmp    $0x101,%eax
 360:	0f 84 cc 04 00 00    	je     832 <pci_class_name+0x557>
 366:	3d 02 01 00 00       	cmp    $0x102,%eax
 36b:	0f 84 cb 04 00 00    	je     83c <pci_class_name+0x561>
 371:	e9 3a 08 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 376:	3d 06 01 00 00       	cmp    $0x106,%eax
 37b:	0f 84 e3 04 00 00    	je     864 <pci_class_name+0x589>
 381:	3d 06 01 00 00       	cmp    $0x106,%eax
 386:	77 1b                	ja     3a3 <pci_class_name+0xc8>
 388:	3d 04 01 00 00       	cmp    $0x104,%eax
 38d:	0f 84 bd 04 00 00    	je     850 <pci_class_name+0x575>
 393:	3d 05 01 00 00       	cmp    $0x105,%eax
 398:	0f 84 bc 04 00 00    	je     85a <pci_class_name+0x57f>
 39e:	e9 0d 08 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 3a3:	3d 80 01 00 00       	cmp    $0x180,%eax
 3a8:	0f 84 c0 04 00 00    	je     86e <pci_class_name+0x593>
 3ae:	3d 00 02 00 00       	cmp    $0x200,%eax
 3b3:	0f 84 bf 04 00 00    	je     878 <pci_class_name+0x59d>
 3b9:	e9 f2 07 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 3be:	3d 06 02 00 00       	cmp    $0x206,%eax
 3c3:	0f 84 eb 04 00 00    	je     8b4 <pci_class_name+0x5d9>
 3c9:	3d 06 02 00 00       	cmp    $0x206,%eax
 3ce:	77 31                	ja     401 <pci_class_name+0x126>
 3d0:	3d 03 02 00 00       	cmp    $0x203,%eax
 3d5:	0f 84 bb 04 00 00    	je     896 <pci_class_name+0x5bb>
 3db:	3d 03 02 00 00       	cmp    $0x203,%eax
 3e0:	0f 82 a6 04 00 00    	jb     88c <pci_class_name+0x5b1>
 3e6:	3d 04 02 00 00       	cmp    $0x204,%eax
 3eb:	0f 84 af 04 00 00    	je     8a0 <pci_class_name+0x5c5>
 3f1:	3d 05 02 00 00       	cmp    $0x205,%eax
 3f6:	0f 84 ae 04 00 00    	je     8aa <pci_class_name+0x5cf>
 3fc:	e9 af 07 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 401:	3d 01 03 00 00       	cmp    $0x301,%eax
 406:	0f 84 c6 04 00 00    	je     8d2 <pci_class_name+0x5f7>
 40c:	3d 01 03 00 00       	cmp    $0x301,%eax
 411:	77 1b                	ja     42e <pci_class_name+0x153>
 413:	3d 80 02 00 00       	cmp    $0x280,%eax
 418:	0f 84 a0 04 00 00    	je     8be <pci_class_name+0x5e3>
 41e:	3d 00 03 00 00       	cmp    $0x300,%eax
 423:	0f 84 9f 04 00 00    	je     8c8 <pci_class_name+0x5ed>
 429:	e9 82 07 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 42e:	3d 02 03 00 00       	cmp    $0x302,%eax
 433:	0f 84 a3 04 00 00    	je     8dc <pci_class_name+0x601>
 439:	3d 80 03 00 00       	cmp    $0x380,%eax
 43e:	0f 84 a2 04 00 00    	je     8e6 <pci_class_name+0x60b>
 444:	e9 67 07 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 449:	3d 03 06 00 00       	cmp    $0x603,%eax
 44e:	0f 84 0a 05 00 00    	je     95e <pci_class_name+0x683>
 454:	3d 03 06 00 00       	cmp    $0x603,%eax
 459:	0f 87 8b 00 00 00    	ja     4ea <pci_class_name+0x20f>
 45f:	3d 00 05 00 00       	cmp    $0x500,%eax
 464:	0f 84 b8 04 00 00    	je     922 <pci_class_name+0x647>
 46a:	3d 00 05 00 00       	cmp    $0x500,%eax
 46f:	77 31                	ja     4a2 <pci_class_name+0x1c7>
 471:	3d 02 04 00 00       	cmp    $0x402,%eax
 476:	0f 84 88 04 00 00    	je     904 <pci_class_name+0x629>
 47c:	3d 02 04 00 00       	cmp    $0x402,%eax
 481:	0f 82 73 04 00 00    	jb     8fa <pci_class_name+0x61f>
 487:	3d 03 04 00 00       	cmp    $0x403,%eax
 48c:	0f 84 7c 04 00 00    	je     90e <pci_class_name+0x633>
 492:	3d 80 04 00 00       	cmp    $0x480,%eax
 497:	0f 84 7b 04 00 00    	je     918 <pci_class_name+0x63d>
 49d:	e9 0e 07 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 4a2:	3d 00 06 00 00       	cmp    $0x600,%eax
 4a7:	0f 84 93 04 00 00    	je     940 <pci_class_name+0x665>
 4ad:	3d 00 06 00 00       	cmp    $0x600,%eax
 4b2:	77 1b                	ja     4cf <pci_class_name+0x1f4>
 4b4:	3d 01 05 00 00       	cmp    $0x501,%eax
 4b9:	0f 84 6d 04 00 00    	je     92c <pci_class_name+0x651>
 4bf:	3d 80 05 00 00       	cmp    $0x580,%eax
 4c4:	0f 84 6c 04 00 00    	je     936 <pci_class_name+0x65b>
 4ca:	e9 e1 06 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 4cf:	3d 01 06 00 00       	cmp    $0x601,%eax
 4d4:	0f 84 70 04 00 00    	je     94a <pci_class_name+0x66f>
 4da:	3d 02 06 00 00       	cmp    $0x602,%eax
 4df:	0f 84 6f 04 00 00    	je     954 <pci_class_name+0x679>
 4e5:	e9 c6 06 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 4ea:	3d 08 06 00 00       	cmp    $0x608,%eax
 4ef:	0f 84 9b 04 00 00    	je     990 <pci_class_name+0x6b5>
 4f5:	3d 08 06 00 00       	cmp    $0x608,%eax
 4fa:	77 31                	ja     52d <pci_class_name+0x252>
 4fc:	3d 05 06 00 00       	cmp    $0x605,%eax
 501:	0f 84 6b 04 00 00    	je     972 <pci_class_name+0x697>
 507:	3d 05 06 00 00       	cmp    $0x605,%eax
 50c:	0f 82 56 04 00 00    	jb     968 <pci_class_name+0x68d>
 512:	3d 06 06 00 00       	cmp    $0x606,%eax
 517:	0f 84 5f 04 00 00    	je     97c <pci_class_name+0x6a1>
 51d:	3d 07 06 00 00       	cmp    $0x607,%eax
 522:	0f 84 5e 04 00 00    	je     986 <pci_class_name+0x6ab>
 528:	e9 83 06 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 52d:	3d 01 07 00 00       	cmp    $0x701,%eax
 532:	0f 84 76 04 00 00    	je     9ae <pci_class_name+0x6d3>
 538:	3d 01 07 00 00       	cmp    $0x701,%eax
 53d:	77 1b                	ja     55a <pci_class_name+0x27f>
 53f:	3d 80 06 00 00       	cmp    $0x680,%eax
 544:	0f 84 50 04 00 00    	je     99a <pci_class_name+0x6bf>
 54a:	3d 00 07 00 00       	cmp    $0x700,%eax
 54f:	0f 84 4f 04 00 00    	je     9a4 <pci_class_name+0x6c9>
 555:	e9 56 06 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 55a:	3d 02 07 00 00       	cmp    $0x702,%eax
 55f:	0f 84 53 04 00 00    	je     9b8 <pci_class_name+0x6dd>
 565:	3d 03 07 00 00       	cmp    $0x703,%eax
 56a:	0f 84 52 04 00 00    	je     9c2 <pci_class_name+0x6e7>
 570:	e9 3b 06 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 575:	3d 00 0c 00 00       	cmp    $0xc00,%eax
 57a:	0f 84 28 05 00 00    	je     aa8 <pci_class_name+0x7cd>
 580:	3d 00 0c 00 00       	cmp    $0xc00,%eax
 585:	0f 87 44 01 00 00    	ja     6cf <pci_class_name+0x3f4>
 58b:	3d 03 09 00 00       	cmp    $0x903,%eax
 590:	0f 84 a4 04 00 00    	je     a3a <pci_class_name+0x75f>
 596:	3d 03 09 00 00       	cmp    $0x903,%eax
 59b:	0f 87 97 00 00 00    	ja     638 <pci_class_name+0x35d>
 5a1:	3d 04 08 00 00       	cmp    $0x804,%eax
 5a6:	0f 84 52 04 00 00    	je     9fe <pci_class_name+0x723>
 5ac:	3d 04 08 00 00       	cmp    $0x804,%eax
 5b1:	77 3d                	ja     5f0 <pci_class_name+0x315>
 5b3:	3d 01 08 00 00       	cmp    $0x801,%eax
 5b8:	0f 84 22 04 00 00    	je     9e0 <pci_class_name+0x705>
 5be:	3d 01 08 00 00       	cmp    $0x801,%eax
 5c3:	77 10                	ja     5d5 <pci_class_name+0x2fa>
 5c5:	3d 00 08 00 00       	cmp    $0x800,%eax
 5ca:	0f 84 06 04 00 00    	je     9d6 <pci_class_name+0x6fb>
 5d0:	e9 db 05 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 5d5:	3d 02 08 00 00       	cmp    $0x802,%eax
 5da:	0f 84 0a 04 00 00    	je     9ea <pci_class_name+0x70f>
 5e0:	3d 03 08 00 00       	cmp    $0x803,%eax
 5e5:	0f 84 09 04 00 00    	je     9f4 <pci_class_name+0x719>
 5eb:	e9 c0 05 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 5f0:	3d 00 09 00 00       	cmp    $0x900,%eax
 5f5:	0f 84 21 04 00 00    	je     a1c <pci_class_name+0x741>
 5fb:	3d 00 09 00 00       	cmp    $0x900,%eax
 600:	77 1b                	ja     61d <pci_class_name+0x342>
 602:	3d 05 08 00 00       	cmp    $0x805,%eax
 607:	0f 84 fb 03 00 00    	je     a08 <pci_class_name+0x72d>
 60d:	3d 80 08 00 00       	cmp    $0x880,%eax
 612:	0f 84 fa 03 00 00    	je     a12 <pci_class_name+0x737>
 618:	e9 93 05 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 61d:	3d 01 09 00 00       	cmp    $0x901,%eax
 622:	0f 84 fe 03 00 00    	je     a26 <pci_class_name+0x74b>
 628:	3d 02 09 00 00       	cmp    $0x902,%eax
 62d:	0f 84 fd 03 00 00    	je     a30 <pci_class_name+0x755>
 633:	e9 78 05 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 638:	3d 00 0b 00 00       	cmp    $0xb00,%eax
 63d:	0f 84 29 04 00 00    	je     a6c <pci_class_name+0x791>
 643:	3d 00 0b 00 00       	cmp    $0xb00,%eax
 648:	77 3d                	ja     687 <pci_class_name+0x3ac>
 64a:	3d 80 09 00 00       	cmp    $0x980,%eax
 64f:	0f 84 f9 03 00 00    	je     a4e <pci_class_name+0x773>
 655:	3d 80 09 00 00       	cmp    $0x980,%eax
 65a:	77 10                	ja     66c <pci_class_name+0x391>
 65c:	3d 04 09 00 00       	cmp    $0x904,%eax
 661:	0f 84 dd 03 00 00    	je     a44 <pci_class_name+0x769>
 667:	e9 44 05 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 66c:	3d 00 0a 00 00       	cmp    $0xa00,%eax
 671:	0f 84 e1 03 00 00    	je     a58 <pci_class_name+0x77d>
 677:	3d 80 0a 00 00       	cmp    $0xa80,%eax
 67c:	0f 84 e0 03 00 00    	je     a62 <pci_class_name+0x787>
 682:	e9 29 05 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 687:	3d 10 0b 00 00       	cmp    $0xb10,%eax
 68c:	0f 84 f8 03 00 00    	je     a8a <pci_class_name+0x7af>
 692:	3d 10 0b 00 00       	cmp    $0xb10,%eax
 697:	77 1b                	ja     6b4 <pci_class_name+0x3d9>
 699:	3d 01 0b 00 00       	cmp    $0xb01,%eax
 69e:	0f 84 d2 03 00 00    	je     a76 <pci_class_name+0x79b>
 6a4:	3d 02 0b 00 00       	cmp    $0xb02,%eax
 6a9:	0f 84 d1 03 00 00    	je     a80 <pci_class_name+0x7a5>
 6af:	e9 fc 04 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 6b4:	3d 30 0b 00 00       	cmp    $0xb30,%eax
 6b9:	0f 84 d5 03 00 00    	je     a94 <pci_class_name+0x7b9>
 6bf:	3d 40 0b 00 00       	cmp    $0xb40,%eax
 6c4:	0f 84 d4 03 00 00    	je     a9e <pci_class_name+0x7c3>
 6ca:	e9 e1 04 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 6cf:	3d 21 0d 00 00       	cmp    $0xd21,%eax
 6d4:	0f 84 82 04 00 00    	je     b5c <pci_class_name+0x881>
 6da:	3d 21 0d 00 00       	cmp    $0xd21,%eax
 6df:	0f 87 97 00 00 00    	ja     77c <pci_class_name+0x4a1>
 6e5:	3d 00 0d 00 00       	cmp    $0xd00,%eax
 6ea:	0f 84 42 04 00 00    	je     b32 <pci_class_name+0x857>
 6f0:	3d 00 0d 00 00       	cmp    $0xd00,%eax
 6f5:	77 3d                	ja     734 <pci_class_name+0x459>
 6f7:	3d 03 0c 00 00       	cmp    $0xc03,%eax
 6fc:	0f 84 ba 03 00 00    	je     abc <pci_class_name+0x7e1>
 702:	3d 03 0c 00 00       	cmp    $0xc03,%eax
 707:	77 10                	ja     719 <pci_class_name+0x43e>
 709:	3d 02 0c 00 00       	cmp    $0xc02,%eax
 70e:	0f 84 9e 03 00 00    	je     ab2 <pci_class_name+0x7d7>
 714:	e9 97 04 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 719:	3d 04 0c 00 00       	cmp    $0xc04,%eax
 71e:	0f 84 fa 03 00 00    	je     b1e <pci_class_name+0x843>
 724:	3d 05 0c 00 00       	cmp    $0xc05,%eax
 729:	0f 84 f9 03 00 00    	je     b28 <pci_class_name+0x84d>
 72f:	e9 7c 04 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 734:	3d 11 0d 00 00       	cmp    $0xd11,%eax
 739:	0f 84 08 04 00 00    	je     b47 <pci_class_name+0x86c>
 73f:	3d 11 0d 00 00       	cmp    $0xd11,%eax
 744:	77 1b                	ja     761 <pci_class_name+0x486>
 746:	3d 01 0d 00 00       	cmp    $0xd01,%eax
 74b:	0f 84 e8 03 00 00    	je     b39 <pci_class_name+0x85e>
 751:	3d 10 0d 00 00       	cmp    $0xd10,%eax
 756:	0f 84 e4 03 00 00    	je     b40 <pci_class_name+0x865>
 75c:	e9 4f 04 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 761:	3d 12 0d 00 00       	cmp    $0xd12,%eax
 766:	0f 84 e2 03 00 00    	je     b4e <pci_class_name+0x873>
 76c:	3d 20 0d 00 00       	cmp    $0xd20,%eax
 771:	0f 84 de 03 00 00    	je     b55 <pci_class_name+0x87a>
 777:	e9 34 04 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 77c:	3d 04 0f 00 00       	cmp    $0xf04,%eax
 781:	0f 84 ff 03 00 00    	je     b86 <pci_class_name+0x8ab>
 787:	3d 04 0f 00 00       	cmp    $0xf04,%eax
 78c:	77 48                	ja     7d6 <pci_class_name+0x4fb>
 78e:	3d 00 0f 00 00       	cmp    $0xf00,%eax
 793:	0f 84 d8 03 00 00    	je     b71 <pci_class_name+0x896>
 799:	3d 00 0f 00 00       	cmp    $0xf00,%eax
 79e:	77 1b                	ja     7bb <pci_class_name+0x4e0>
 7a0:	3d 80 0d 00 00       	cmp    $0xd80,%eax
 7a5:	0f 84 b8 03 00 00    	je     b63 <pci_class_name+0x888>
 7ab:	3d 00 0e 00 00       	cmp    $0xe00,%eax
 7b0:	0f 84 b4 03 00 00    	je     b6a <pci_class_name+0x88f>
 7b6:	e9 f5 03 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 7bb:	3d 01 0f 00 00       	cmp    $0xf01,%eax
 7c0:	0f 84 b2 03 00 00    	je     b78 <pci_class_name+0x89d>
 7c6:	3d 03 0f 00 00       	cmp    $0xf03,%eax
 7cb:	0f 84 ae 03 00 00    	je     b7f <pci_class_name+0x8a4>
 7d1:	e9 da 03 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 7d6:	3d 80 10 00 00       	cmp    $0x1080,%eax
 7db:	0f 84 ba 03 00 00    	je     b9b <pci_class_name+0x8c0>
 7e1:	3d 80 10 00 00       	cmp    $0x1080,%eax
 7e6:	77 1b                	ja     803 <pci_class_name+0x528>
 7e8:	3d 00 10 00 00       	cmp    $0x1000,%eax
 7ed:	0f 84 9a 03 00 00    	je     b8d <pci_class_name+0x8b2>
 7f3:	3d 01 10 00 00       	cmp    $0x1001,%eax
 7f8:	0f 84 96 03 00 00    	je     b94 <pci_class_name+0x8b9>
 7fe:	e9 ad 03 00 00       	jmp    bb0 <pci_class_name+0x8d5>
 803:	3d 00 11 00 00       	cmp    $0x1100,%eax
 808:	0f 84 94 03 00 00    	je     ba2 <pci_class_name+0x8c7>
 80e:	3d 80 11 00 00       	cmp    $0x1180,%eax
 813:	0f 84 90 03 00 00    	je     ba9 <pci_class_name+0x8ce>
 819:	e9 92 03 00 00       	jmp    bb0 <pci_class_name+0x8d5>
	{
	case PCI_VGA_COMPATIBLE:            return "VGA-Compatible Device";
 81e:	b8 0f 00 00 00       	mov    $0xf,%eax
 823:	e9 8d 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_STORAGE_SCSI:              return "SCSI Storage Controller";
 828:	b8 25 00 00 00       	mov    $0x25,%eax
 82d:	e9 83 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_STORAGE_IDE:               return "IDE Interface";
 832:	b8 3d 00 00 00       	mov    $0x3d,%eax
 837:	e9 79 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_STORAGE_FLOPPY:            return "Floppy Disk Controller";
 83c:	b8 4b 00 00 00       	mov    $0x4b,%eax
 841:	e9 6f 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_STORAGE_IPI:               return "IPI Bus Controller";
 846:	b8 62 00 00 00       	mov    $0x62,%eax
 84b:	e9 65 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_STORAGE_RAID:              return "RAID Bus Controller";
 850:	b8 75 00 00 00       	mov    $0x75,%eax
 855:	e9 5b 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_STORAGE_ATA:               return "ATA Controller";
 85a:	b8 89 00 00 00       	mov    $0x89,%eax
 85f:	e9 51 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_STORAGE_SATA:              return "SATA Controller";
 864:	b8 98 00 00 00       	mov    $0x98,%eax
 869:	e9 47 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_STORAGE_OTHER:             return "Mass Storage Controller";
 86e:	b8 a8 00 00 00       	mov    $0xa8,%eax
 873:	e9 3d 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_NETWORK_ETHERNET:          return "Ethernet Controller";
 878:	b8 c0 00 00 00       	mov    $0xc0,%eax
 87d:	e9 33 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_NETWORK_TOKEN_RING:        return "Token Ring Controller";
 882:	b8 d4 00 00 00       	mov    $0xd4,%eax
 887:	e9 29 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_NETWORK_FDDI:              return "FDDI Controller";
 88c:	b8 ea 00 00 00       	mov    $0xea,%eax
 891:	e9 1f 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_NETWORK_ATM:               return "ATM Controller";
 896:	b8 fa 00 00 00       	mov    $0xfa,%eax
 89b:	e9 15 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_NETWORK_ISDN:              return "ISDN Controller";
 8a0:	b8 09 01 00 00       	mov    $0x109,%eax
 8a5:	e9 0b 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_NETWORK_WORLDFIP:          return "WorldFip Controller";
 8aa:	b8 19 01 00 00       	mov    $0x119,%eax
 8af:	e9 01 03 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_NETWORK_PICGMG:            return "PICMG Controller";
 8b4:	b8 2d 01 00 00       	mov    $0x12d,%eax
 8b9:	e9 f7 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_NETWORK_OTHER:             return "Network Controller";
 8be:	b8 3e 01 00 00       	mov    $0x13e,%eax
 8c3:	e9 ed 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_DISPLAY_VGA:               return "VGA-Compatible Controller";
 8c8:	b8 51 01 00 00       	mov    $0x151,%eax
 8cd:	e9 e3 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_DISPLAY_XGA:               return "XGA-Compatible Controller";
 8d2:	b8 6b 01 00 00       	mov    $0x16b,%eax
 8d7:	e9 d9 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_DISPLAY_3D:                return "3D Controller";
 8dc:	b8 85 01 00 00       	mov    $0x185,%eax
 8e1:	e9 cf 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_DISPLAY_OTHER:             return "Display Controller";
 8e6:	b8 93 01 00 00       	mov    $0x193,%eax
 8eb:	e9 c5 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_MULTIMEDIA_VIDEO:          return "Multimedia Video Controller";
 8f0:	b8 a6 01 00 00       	mov    $0x1a6,%eax
 8f5:	e9 bb 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_MULTIMEDIA_AUDIO:          return "Multimedia Audio Controller";
 8fa:	b8 c2 01 00 00       	mov    $0x1c2,%eax
 8ff:	e9 b1 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_MULTIMEDIA_PHONE:          return "Computer Telephony Device";
 904:	b8 de 01 00 00       	mov    $0x1de,%eax
 909:	e9 a7 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_MULTIMEDIA_AUDIO_DEVICE:   return "Audio Device";
 90e:	b8 f8 01 00 00       	mov    $0x1f8,%eax
 913:	e9 9d 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_MULTIMEDIA_OTHER:          return "Multimedia Controller";
 918:	b8 05 02 00 00       	mov    $0x205,%eax
 91d:	e9 93 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_MEMORY_RAM:                return "RAM Memory";
 922:	b8 1b 02 00 00       	mov    $0x21b,%eax
 927:	e9 89 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_MEMORY_FLASH:              return "Flash Memory";
 92c:	b8 26 02 00 00       	mov    $0x226,%eax
 931:	e9 7f 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_MEMORY_OTHER:              return "Memory Controller";
 936:	b8 33 02 00 00       	mov    $0x233,%eax
 93b:	e9 75 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_HOST:               return "Host Bridge";
 940:	b8 45 02 00 00       	mov    $0x245,%eax
 945:	e9 6b 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_ISA:                return "ISA Bridge";
 94a:	b8 51 02 00 00       	mov    $0x251,%eax
 94f:	e9 61 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_EISA:               return "EISA Bridge";
 954:	b8 5c 02 00 00       	mov    $0x25c,%eax
 959:	e9 57 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_MCA:                return "MicroChannel Bridge";
 95e:	b8 68 02 00 00       	mov    $0x268,%eax
 963:	e9 4d 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_PCI:                return "PCI Bridge";
 968:	b8 7c 02 00 00       	mov    $0x27c,%eax
 96d:	e9 43 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_PCMCIA:             return "PCMCIA Bridge";
 972:	b8 87 02 00 00       	mov    $0x287,%eax
 977:	e9 39 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_NUBUS:              return "NuBus Bridge";
 97c:	b8 95 02 00 00       	mov    $0x295,%eax
 981:	e9 2f 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_CARDBUS:            return "CardBus Bridge";
 986:	b8 a2 02 00 00       	mov    $0x2a2,%eax
 98b:	e9 25 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_RACEWAY:            return "RACEway Bridge";
 990:	b8 b1 02 00 00       	mov    $0x2b1,%eax
 995:	e9 1b 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_BRIDGE_OTHER:              return "Bridge Device";
 99a:	b8 c0 02 00 00       	mov    $0x2c0,%eax
 99f:	e9 11 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_COMM_SERIAL:               return "Serial Controller";
 9a4:	b8 ce 02 00 00       	mov    $0x2ce,%eax
 9a9:	e9 07 02 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_COMM_PARALLEL:             return "Parallel Controller";
 9ae:	b8 e0 02 00 00       	mov    $0x2e0,%eax
 9b3:	e9 fd 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_COMM_MULTIPORT:            return "Multiport Serial Controller";
 9b8:	b8 f4 02 00 00       	mov    $0x2f4,%eax
 9bd:	e9 f3 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_COMM_MODEM:                return "Modem";
 9c2:	b8 10 03 00 00       	mov    $0x310,%eax
 9c7:	e9 e9 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_COMM_OTHER:                return "Communication Controller";
 9cc:	b8 16 03 00 00       	mov    $0x316,%eax
 9d1:	e9 df 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SYSTEM_PIC:                return "PIC";
 9d6:	b8 2f 03 00 00       	mov    $0x32f,%eax
 9db:	e9 d5 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SYSTEM_DMA:                return "DMA Controller";
 9e0:	b8 33 03 00 00       	mov    $0x333,%eax
 9e5:	e9 cb 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SYSTEM_TIMER:              return "Timer";
 9ea:	b8 42 03 00 00       	mov    $0x342,%eax
 9ef:	e9 c1 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SYSTEM_RTC:                return "RTC";
 9f4:	b8 48 03 00 00       	mov    $0x348,%eax
 9f9:	e9 b7 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SYSTEM_PCI_HOTPLUG:        return "PCI Hot-Plug Controller";
 9fe:	b8 4c 03 00 00       	mov    $0x34c,%eax
 a03:	e9 ad 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SYSTEM_SD:                 return "SD Host Controller";
 a08:	b8 64 03 00 00       	mov    $0x364,%eax
 a0d:	e9 a3 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SYSTEM_OTHER:              return "System Peripheral";
 a12:	b8 77 03 00 00       	mov    $0x377,%eax
 a17:	e9 99 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_INPUT_KEYBOARD:            return "Keyboard Controller";
 a1c:	b8 89 03 00 00       	mov    $0x389,%eax
 a21:	e9 8f 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_INPUT_PEN:                 return "Pen Controller";
 a26:	b8 9d 03 00 00       	mov    $0x39d,%eax
 a2b:	e9 85 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_INPUT_MOUSE:               return "Mouse Controller";
 a30:	b8 ac 03 00 00       	mov    $0x3ac,%eax
 a35:	e9 7b 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_INPUT_SCANNER:             return "Scanner Controller";
 a3a:	b8 bd 03 00 00       	mov    $0x3bd,%eax
 a3f:	e9 71 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_INPUT_GAMEPORT:            return "Gameport Controller";
 a44:	b8 d0 03 00 00       	mov    $0x3d0,%eax
 a49:	e9 67 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_INPUT_OTHER:               return "Input Controller";
 a4e:	b8 e4 03 00 00       	mov    $0x3e4,%eax
 a53:	e9 5d 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_DOCKING_GENERIC:           return "Generic Docking Station";
 a58:	b8 f5 03 00 00       	mov    $0x3f5,%eax
 a5d:	e9 53 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_DOCKING_OTHER:             return "Docking Station";
 a62:	b8 0d 04 00 00       	mov    $0x40d,%eax
 a67:	e9 49 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_PROCESSOR_386:             return "386";
 a6c:	b8 1d 04 00 00       	mov    $0x41d,%eax
 a71:	e9 3f 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_PROCESSOR_486:             return "486";
 a76:	b8 21 04 00 00       	mov    $0x421,%eax
 a7b:	e9 35 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_PROCESSOR_PENTIUM:         return "Pentium";
 a80:	b8 25 04 00 00       	mov    $0x425,%eax
 a85:	e9 2b 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_PROCESSOR_ALPHA:           return "Alpha";
 a8a:	b8 2d 04 00 00       	mov    $0x42d,%eax
 a8f:	e9 21 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_PROCESSOR_MIPS:            return "MIPS";
 a94:	b8 33 04 00 00       	mov    $0x433,%eax
 a99:	e9 17 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_PROCESSOR_CO:              return "CO-Processor";
 a9e:	b8 38 04 00 00       	mov    $0x438,%eax
 aa3:	e9 0d 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SERIAL_FIREWIRE:           return "FireWire (IEEE 1394)";
 aa8:	b8 45 04 00 00       	mov    $0x445,%eax
 aad:	e9 03 01 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SERIAL_SSA:                return "SSA";
 ab2:	b8 5a 04 00 00       	mov    $0x45a,%eax
 ab7:	e9 f9 00 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SERIAL_USB:
		switch (progIntf)
 abc:	8b 45 10             	mov    0x10(%ebp),%eax
 abf:	83 f8 20             	cmp    $0x20,%eax
 ac2:	74 32                	je     af6 <pci_class_name+0x81b>
 ac4:	83 f8 20             	cmp    $0x20,%eax
 ac7:	77 0b                	ja     ad4 <pci_class_name+0x7f9>
 ac9:	85 c0                	test   %eax,%eax
 acb:	74 15                	je     ae2 <pci_class_name+0x807>
 acd:	83 f8 10             	cmp    $0x10,%eax
 ad0:	74 1a                	je     aec <pci_class_name+0x811>
 ad2:	eb 40                	jmp    b14 <pci_class_name+0x839>
 ad4:	83 f8 30             	cmp    $0x30,%eax
 ad7:	74 27                	je     b00 <pci_class_name+0x825>
 ad9:	3d 80 00 00 00       	cmp    $0x80,%eax
 ade:	74 2a                	je     b0a <pci_class_name+0x82f>
 ae0:	eb 32                	jmp    b14 <pci_class_name+0x839>
		{
		case PCI_SERIAL_USB_UHCI:       return "USB (UHCI)";
 ae2:	b8 5e 04 00 00       	mov    $0x45e,%eax
 ae7:	e9 c9 00 00 00       	jmp    bb5 <pci_class_name+0x8da>
		case PCI_SERIAL_USB_OHCI:       return "USB (OHCI)";
 aec:	b8 69 04 00 00       	mov    $0x469,%eax
 af1:	e9 bf 00 00 00       	jmp    bb5 <pci_class_name+0x8da>
		case PCI_SERIAL_USB_EHCI:       return "USB2";
 af6:	b8 74 04 00 00       	mov    $0x474,%eax
 afb:	e9 b5 00 00 00       	jmp    bb5 <pci_class_name+0x8da>
		case PCI_SERIAL_USB_XHCI:       return "USB3";
 b00:	b8 79 04 00 00       	mov    $0x479,%eax
 b05:	e9 ab 00 00 00       	jmp    bb5 <pci_class_name+0x8da>
		case PCI_SERIAL_USB_OTHER:      return "USB Controller";
 b0a:	b8 7e 04 00 00       	mov    $0x47e,%eax
 b0f:	e9 a1 00 00 00       	jmp    bb5 <pci_class_name+0x8da>
		default:                        return "Unknown USB Class";
 b14:	b8 8d 04 00 00       	mov    $0x48d,%eax
 b19:	e9 97 00 00 00       	jmp    bb5 <pci_class_name+0x8da>
		}
		break;
	case PCI_SERIAL_FIBER:              return "Fiber Channel";
 b1e:	b8 9f 04 00 00       	mov    $0x49f,%eax
 b23:	e9 8d 00 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SERIAL_SMBUS:              return "SMBus";
 b28:	b8 ad 04 00 00       	mov    $0x4ad,%eax
 b2d:	e9 83 00 00 00       	jmp    bb5 <pci_class_name+0x8da>
	case PCI_WIRELESS_IRDA:             return "iRDA Compatible Controller";
 b32:	b8 b3 04 00 00       	mov    $0x4b3,%eax
 b37:	eb 7c                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_WIRLESSS_IR:               return "Consumer IR Controller";
 b39:	b8 ce 04 00 00       	mov    $0x4ce,%eax
 b3e:	eb 75                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_WIRLESSS_RF:               return "RF Controller";
 b40:	b8 e5 04 00 00       	mov    $0x4e5,%eax
 b45:	eb 6e                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_WIRLESSS_BLUETOOTH:        return "Bluetooth";
 b47:	b8 f3 04 00 00       	mov    $0x4f3,%eax
 b4c:	eb 67                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_WIRLESSS_BROADBAND:        return "Broadband";
 b4e:	b8 fd 04 00 00       	mov    $0x4fd,%eax
 b53:	eb 60                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_WIRLESSS_ETHERNET_A:       return "802.1a Controller";
 b55:	b8 07 05 00 00       	mov    $0x507,%eax
 b5a:	eb 59                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_WIRLESSS_ETHERNET_B:       return "802.1b Controller";
 b5c:	b8 19 05 00 00       	mov    $0x519,%eax
 b61:	eb 52                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_WIRELESS_OTHER:            return "Wireless Controller";
 b63:	b8 2b 05 00 00       	mov    $0x52b,%eax
 b68:	eb 4b                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_INTELLIGENT_I2O:           return "I2O Controller";
 b6a:	b8 3f 05 00 00       	mov    $0x53f,%eax
 b6f:	eb 44                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SATELLITE_TV:              return "Satellite TV Controller";
 b71:	b8 4e 05 00 00       	mov    $0x54e,%eax
 b76:	eb 3d                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SATELLITE_AUDIO:           return "Satellite Audio Controller";
 b78:	b8 66 05 00 00       	mov    $0x566,%eax
 b7d:	eb 36                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SATELLITE_VOICE:           return "Satellite Voice Controller";
 b7f:	b8 81 05 00 00       	mov    $0x581,%eax
 b84:	eb 2f                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SATELLITE_DATA:            return "Satellite Data Controller";
 b86:	b8 9c 05 00 00       	mov    $0x59c,%eax
 b8b:	eb 28                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_CRYPT_NETWORK:             return "Network and Computing Encryption Device";
 b8d:	b8 b8 05 00 00       	mov    $0x5b8,%eax
 b92:	eb 21                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_CRYPT_ENTERTAINMENT:       return "Entertainment Encryption Device";
 b94:	b8 e0 05 00 00       	mov    $0x5e0,%eax
 b99:	eb 1a                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_CRYPT_OTHER:               return "Encryption Device";
 b9b:	b8 00 06 00 00       	mov    $0x600,%eax
 ba0:	eb 13                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SP_DPIO:                   return "DPIO Modules";
 ba2:	b8 12 06 00 00       	mov    $0x612,%eax
 ba7:	eb 0c                	jmp    bb5 <pci_class_name+0x8da>
	case PCI_SP_OTHER:                  return "Signal Processing Controller";
 ba9:	b8 1f 06 00 00       	mov    $0x61f,%eax
 bae:	eb 05                	jmp    bb5 <pci_class_name+0x8da>
	}
	return "Unknown PCI Class";
 bb0:	b8 3c 06 00 00       	mov    $0x63c,%eax
 bb5:	5d                   	pop    %ebp
 bb6:	c3                   	ret    

pci_io.o:     file format elf32-i386


Disassembly of section .text:

00000000 <pci_read_b>:

#define PCI_CONFIG_ADDR					0xCF8
#define PCI_CONFIG_DATA					0xCFC

uint8_t pci_read_b(uint32_t id, uint32_t reg)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 18             	sub    $0x18,%esp
	uint32_t addr = MAKE_ADDR(id, reg);
   6:	8b 45 0c             	mov    0xc(%ebp),%eax
   9:	25 fc 00 00 00       	and    $0xfc,%eax
   e:	0b 45 08             	or     0x8(%ebp),%eax
  11:	0d 00 00 00 80       	or     $0x80000000,%eax
  16:	89 45 f4             	mov    %eax,-0xc(%ebp)

	outportl(PCI_CONFIG_ADDR, addr);
  19:	83 ec 08             	sub    $0x8,%esp
  1c:	ff 75 f4             	pushl  -0xc(%ebp)
  1f:	68 f8 0c 00 00       	push   $0xcf8
  24:	e8 fc ff ff ff       	call   25 <pci_read_b+0x25>
  29:	83 c4 10             	add    $0x10,%esp

	return inportb(PCI_CONFIG_DATA + (reg & 0x03));
  2c:	8b 45 0c             	mov    0xc(%ebp),%eax
  2f:	83 e0 03             	and    $0x3,%eax
  32:	66 05 fc 0c          	add    $0xcfc,%ax
  36:	0f b7 c0             	movzwl %ax,%eax
  39:	83 ec 0c             	sub    $0xc,%esp
  3c:	50                   	push   %eax
  3d:	e8 fc ff ff ff       	call   3e <pci_read_b+0x3e>
  42:	83 c4 10             	add    $0x10,%esp
}
  45:	c9                   	leave  
  46:	c3                   	ret    

00000047 <pci_read_w>:

uint16_t pci_read_w(uint32_t id, uint32_t reg)
{
  47:	55                   	push   %ebp
  48:	89 e5                	mov    %esp,%ebp
  4a:	83 ec 18             	sub    $0x18,%esp
	uint32_t addr = MAKE_ADDR(id, reg);
  4d:	8b 45 0c             	mov    0xc(%ebp),%eax
  50:	25 fc 00 00 00       	and    $0xfc,%eax
  55:	0b 45 08             	or     0x8(%ebp),%eax
  58:	0d 00 00 00 80       	or     $0x80000000,%eax
  5d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	outportl(PCI_CONFIG_ADDR, addr);
  60:	83 ec 08             	sub    $0x8,%esp
  63:	ff 75 f4             	pushl  -0xc(%ebp)
  66:	68 f8 0c 00 00       	push   $0xcf8
  6b:	e8 fc ff ff ff       	call   6c <pci_read_w+0x25>
  70:	83 c4 10             	add    $0x10,%esp

	return inportw(PCI_CONFIG_DATA + (reg & 0x02));
  73:	8b 45 0c             	mov    0xc(%ebp),%eax
  76:	83 e0 02             	and    $0x2,%eax
  79:	66 05 fc 0c          	add    $0xcfc,%ax
  7d:	0f b7 c0             	movzwl %ax,%eax
  80:	83 ec 0c             	sub    $0xc,%esp
  83:	50                   	push   %eax
  84:	e8 fc ff ff ff       	call   85 <pci_read_w+0x3e>
  89:	83 c4 10             	add    $0x10,%esp
}
  8c:	c9                   	leave  
  8d:	c3                   	ret    

0000008e <pci_read_l>:

uint32_t pci_read_l(uint32_t id, uint32_t reg)
{
  8e:	55                   	push   %ebp
  8f:	89 e5                	mov    %esp,%ebp
  91:	83 ec 18             	sub    $0x18,%esp
	uint32_t addr = MAKE_ADDR(id, reg);
  94:	8b 45 0c             	mov    0xc(%ebp),%eax
  97:	25 fc 00 00 00       	and    $0xfc,%eax
  9c:	0b 45 08             	or     0x8(%ebp),%eax
  9f:	0d 00 00 00 80       	or     $0x80000000,%eax
  a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	outportl(PCI_CONFIG_ADDR, addr);
  a7:	83 ec 08             	sub    $0x8,%esp
  aa:	ff 75 f4             	pushl  -0xc(%ebp)
  ad:	68 f8 0c 00 00       	push   $0xcf8
  b2:	e8 fc ff ff ff       	call   b3 <pci_read_l+0x25>
  b7:	83 c4 10             	add    $0x10,%esp

	return inportw(PCI_CONFIG_DATA);
  ba:	83 ec 0c             	sub    $0xc,%esp
  bd:	68 fc 0c 00 00       	push   $0xcfc
  c2:	e8 fc ff ff ff       	call   c3 <pci_read_l+0x35>
  c7:	83 c4 10             	add    $0x10,%esp
  ca:	0f b7 c0             	movzwl %ax,%eax
}
  cd:	c9                   	leave  
  ce:	c3                   	ret    

000000cf <pci_write_b>:

void pci_write_b(uint32_t id, uint32_t reg, uint8_t data)
{
  cf:	55                   	push   %ebp
  d0:	89 e5                	mov    %esp,%ebp
  d2:	83 ec 28             	sub    $0x28,%esp
  d5:	8b 45 10             	mov    0x10(%ebp),%eax
  d8:	88 45 e4             	mov    %al,-0x1c(%ebp)
	uint32_t addr = MAKE_ADDR(id, reg);
  db:	8b 45 0c             	mov    0xc(%ebp),%eax
  de:	25 fc 00 00 00       	and    $0xfc,%eax
  e3:	0b 45 08             	or     0x8(%ebp),%eax
  e6:	0d 00 00 00 80       	or     $0x80000000,%eax
  eb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	outportl(PCI_CONFIG_ADDR, addr);
  ee:	83 ec 08             	sub    $0x8,%esp
  f1:	ff 75 f4             	pushl  -0xc(%ebp)
  f4:	68 f8 0c 00 00       	push   $0xcf8
  f9:	e8 fc ff ff ff       	call   fa <pci_write_b+0x2b>
  fe:	83 c4 10             	add    $0x10,%esp

	outportb(PCI_CONFIG_DATA + (reg & 0x03), data);
 101:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
 105:	8b 45 0c             	mov    0xc(%ebp),%eax
 108:	83 e0 03             	and    $0x3,%eax
 10b:	66 05 fc 0c          	add    $0xcfc,%ax
 10f:	0f b7 c0             	movzwl %ax,%eax
 112:	83 ec 08             	sub    $0x8,%esp
 115:	52                   	push   %edx
 116:	50                   	push   %eax
 117:	e8 fc ff ff ff       	call   118 <pci_write_b+0x49>
 11c:	83 c4 10             	add    $0x10,%esp
}
 11f:	90                   	nop
 120:	c9                   	leave  
 121:	c3                   	ret    

00000122 <pci_write_w>:

void pci_write_w(uint32_t id, uint32_t reg, uint16_t data)
{
 122:	55                   	push   %ebp
 123:	89 e5                	mov    %esp,%ebp
 125:	83 ec 28             	sub    $0x28,%esp
 128:	8b 45 10             	mov    0x10(%ebp),%eax
 12b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	uint32_t addr = MAKE_ADDR(id, reg);
 12f:	8b 45 0c             	mov    0xc(%ebp),%eax
 132:	25 fc 00 00 00       	and    $0xfc,%eax
 137:	0b 45 08             	or     0x8(%ebp),%eax
 13a:	0d 00 00 00 80       	or     $0x80000000,%eax
 13f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	outportl(PCI_CONFIG_ADDR, addr);
 142:	83 ec 08             	sub    $0x8,%esp
 145:	ff 75 f4             	pushl  -0xc(%ebp)
 148:	68 f8 0c 00 00       	push   $0xcf8
 14d:	e8 fc ff ff ff       	call   14e <pci_write_w+0x2c>
 152:	83 c4 10             	add    $0x10,%esp

	outportw(PCI_CONFIG_DATA + (reg & 0x02), data);
 155:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
 159:	8b 45 0c             	mov    0xc(%ebp),%eax
 15c:	83 e0 02             	and    $0x2,%eax
 15f:	66 05 fc 0c          	add    $0xcfc,%ax
 163:	0f b7 c0             	movzwl %ax,%eax
 166:	83 ec 08             	sub    $0x8,%esp
 169:	52                   	push   %edx
 16a:	50                   	push   %eax
 16b:	e8 fc ff ff ff       	call   16c <pci_write_w+0x4a>
 170:	83 c4 10             	add    $0x10,%esp
}
 173:	90                   	nop
 174:	c9                   	leave  
 175:	c3                   	ret    

00000176 <pci_write_l>:

void pci_write_l(uint32_t id, uint32_t reg, uint32_t data)
{
 176:	55                   	push   %ebp
 177:	89 e5                	mov    %esp,%ebp
 179:	83 ec 18             	sub    $0x18,%esp
	uint32_t addr = MAKE_ADDR(id, reg);
 17c:	8b 45 0c             	mov    0xc(%ebp),%eax
 17f:	25 fc 00 00 00       	and    $0xfc,%eax
 184:	0b 45 08             	or     0x8(%ebp),%eax
 187:	0d 00 00 00 80       	or     $0x80000000,%eax
 18c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	outportl(PCI_CONFIG_ADDR, addr);
 18f:	83 ec 08             	sub    $0x8,%esp
 192:	ff 75 f4             	pushl  -0xc(%ebp)
 195:	68 f8 0c 00 00       	push   $0xcf8
 19a:	e8 fc ff ff ff       	call   19b <pci_write_l+0x25>
 19f:	83 c4 10             	add    $0x10,%esp

	outportl(PCI_CONFIG_DATA, data);
 1a2:	83 ec 08             	sub    $0x8,%esp
 1a5:	ff 75 10             	pushl  0x10(%ebp)
 1a8:	68 fc 0c 00 00       	push   $0xcfc
 1ad:	e8 fc ff ff ff       	call   1ae <pci_write_l+0x38>
 1b2:	83 c4 10             	add    $0x10,%esp
 1b5:	90                   	nop
 1b6:	c9                   	leave  
 1b7:	c3                   	ret    

pci.o:     file format elf32-i386


Disassembly of section .text:

00000000 <pciCheckDevice>:
static int n_devices = 0;

void pciCheckDevice(uint32_t bus, uint32_t dev, uint32_t func);

void pciCheckDevice(uint32_t bus, uint32_t dev, uint32_t func)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	56                   	push   %esi
   5:	53                   	push   %ebx
   6:	81 ec ac 00 00 00    	sub    $0xac,%esp
	uint32_t id = PCI_MAKE_ID(bus, dev, func);
   c:	8b 45 08             	mov    0x8(%ebp),%eax
   f:	c1 e0 10             	shl    $0x10,%eax
  12:	89 c2                	mov    %eax,%edx
  14:	8b 45 0c             	mov    0xc(%ebp),%eax
  17:	c1 e0 0b             	shl    $0xb,%eax
  1a:	09 c2                	or     %eax,%edx
  1c:	8b 45 10             	mov    0x10(%ebp),%eax
  1f:	c1 e0 08             	shl    $0x8,%eax
  22:	09 d0                	or     %edx,%eax
  24:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	// No existing device
	if (pci_read_w(id, PCI_CONFIG_VENDOR_ID) == 0xFFFF)
  27:	83 ec 08             	sub    $0x8,%esp
  2a:	6a 00                	push   $0x0
  2c:	ff 75 e4             	pushl  -0x1c(%ebp)
  2f:	e8 fc ff ff ff       	call   30 <pciCheckDevice+0x30>
  34:	83 c4 10             	add    $0x10,%esp
  37:	66 83 f8 ff          	cmp    $0xffff,%ax
  3b:	74 4c                	je     89 <pciCheckDevice+0x89>
		return;
	}

	PciDeviceInfo_t info;

	info.present = 1;
  3d:	c6 85 4c ff ff ff 01 	movb   $0x1,-0xb4(%ebp)

	pci_read_device_info(id, &info);
  44:	83 ec 08             	sub    $0x8,%esp
  47:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
  4d:	50                   	push   %eax
  4e:	ff 75 e4             	pushl  -0x1c(%ebp)
  51:	e8 fc ff ff ff       	call   52 <pciCheckDevice+0x52>
  56:	83 c4 10             	add    $0x10,%esp

	devices[n_devices++] = info;
  59:	a1 e0 0b 00 00       	mov    0xbe0,%eax
  5e:	8d 50 01             	lea    0x1(%eax),%edx
  61:	89 15 e0 0b 00 00    	mov    %edx,0xbe0
  67:	69 c0 98 00 00 00    	imul   $0x98,%eax,%eax
  6d:	05 00 00 00 00       	add    $0x0,%eax
  72:	89 c3                	mov    %eax,%ebx
  74:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
  7a:	ba 26 00 00 00       	mov    $0x26,%edx
  7f:	89 df                	mov    %ebx,%edi
  81:	89 c6                	mov    %eax,%esi
  83:	89 d1                	mov    %edx,%ecx
  85:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  87:	eb 01                	jmp    8a <pciCheckDevice+0x8a>
	uint32_t id = PCI_MAKE_ID(bus, dev, func);

	// No existing device
	if (pci_read_w(id, PCI_CONFIG_VENDOR_ID) == 0xFFFF)
	{
		return;
  89:	90                   	nop
	info.present = 1;

	pci_read_device_info(id, &info);

	devices[n_devices++] = info;
}
  8a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8d:	5b                   	pop    %ebx
  8e:	5e                   	pop    %esi
  8f:	5f                   	pop    %edi
  90:	5d                   	pop    %ebp
  91:	c3                   	ret    

00000092 <pciInit>:

void pciInit()
{
  92:	55                   	push   %ebp
  93:	89 e5                	mov    %esp,%ebp
  95:	83 ec 28             	sub    $0x28,%esp
	for (uint32_t bus = 0; bus < 256; ++bus)
  98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  9f:	eb 7d                	jmp    11e <pciInit+0x8c>
	{
		for (uint32_t dev = 0; dev < 32; ++dev)
  a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  a8:	eb 6a                	jmp    114 <pciInit+0x82>
		{
			uint32_t baseID = PCI_MAKE_ID(bus, dev, 0);
  aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  ad:	c1 e0 10             	shl    $0x10,%eax
  b0:	89 c2                	mov    %eax,%edx
  b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  b5:	c1 e0 0b             	shl    $0xb,%eax
  b8:	09 d0                	or     %edx,%eax
  ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			uint8_t headerType = pci_read_b(baseID, PCI_CONFIG_HEADER_TYPE);
  bd:	83 ec 08             	sub    $0x8,%esp
  c0:	6a 0e                	push   $0xe
  c2:	ff 75 e4             	pushl  -0x1c(%ebp)
  c5:	e8 fc ff ff ff       	call   c6 <pciInit+0x34>
  ca:	83 c4 10             	add    $0x10,%esp
  cd:	88 45 e3             	mov    %al,-0x1d(%ebp)

			uint32_t funcCount = headerType & 0x80 ? 8 : 1;
  d0:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  d4:	84 c0                	test   %al,%al
  d6:	79 07                	jns    df <pciInit+0x4d>
  d8:	b8 08 00 00 00       	mov    $0x8,%eax
  dd:	eb 05                	jmp    e4 <pciInit+0x52>
  df:	b8 01 00 00 00       	mov    $0x1,%eax
  e4:	89 45 dc             	mov    %eax,-0x24(%ebp)

			for (uint8_t func = 0; func < funcCount; ++func)
  e7:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  eb:	eb 1a                	jmp    107 <pciInit+0x75>
			{
				pciCheckDevice(bus, dev, func);
  ed:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  f1:	83 ec 04             	sub    $0x4,%esp
  f4:	50                   	push   %eax
  f5:	ff 75 f0             	pushl  -0x10(%ebp)
  f8:	ff 75 f4             	pushl  -0xc(%ebp)
  fb:	e8 fc ff ff ff       	call   fc <pciInit+0x6a>
 100:	83 c4 10             	add    $0x10,%esp

			uint8_t headerType = pci_read_b(baseID, PCI_CONFIG_HEADER_TYPE);

			uint32_t funcCount = headerType & 0x80 ? 8 : 1;

			for (uint8_t func = 0; func < funcCount; ++func)
 103:	80 45 ef 01          	addb   $0x1,-0x11(%ebp)
 107:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
 10b:	3b 45 dc             	cmp    -0x24(%ebp),%eax
 10e:	72 dd                	jb     ed <pciInit+0x5b>

void pciInit()
{
	for (uint32_t bus = 0; bus < 256; ++bus)
	{
		for (uint32_t dev = 0; dev < 32; ++dev)
 110:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 114:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
 118:	76 90                	jbe    aa <pciInit+0x18>
	devices[n_devices++] = info;
}

void pciInit()
{
	for (uint32_t bus = 0; bus < 256; ++bus)
 11a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 11e:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
 125:	0f 86 76 ff ff ff    	jbe    a1 <pciInit+0xf>
				pciCheckDevice(bus, dev, func);
			}
		}
	}

	serial_printf(COM1, "\n==========================================\n");
 12b:	83 ec 08             	sub    $0x8,%esp
 12e:	68 00 00 00 00       	push   $0x0
 133:	6a 00                	push   $0x0
 135:	e8 fc ff ff ff       	call   136 <pciInit+0xa4>
 13a:	83 c4 10             	add    $0x10,%esp
	serial_printf(COM1,   "============ PCI Device List =============\n");
 13d:	83 ec 08             	sub    $0x8,%esp
 140:	68 30 00 00 00       	push   $0x30
 145:	6a 00                	push   $0x0
 147:	e8 fc ff ff ff       	call   148 <pciInit+0xb6>
 14c:	83 c4 10             	add    $0x10,%esp
	serial_printf(COM1,   "==========================================\n\n");
 14f:	83 ec 08             	sub    $0x8,%esp
 152:	68 5c 00 00 00       	push   $0x5c
 157:	6a 00                	push   $0x0
 159:	e8 fc ff ff ff       	call   15a <pciInit+0xc8>
 15e:	83 c4 10             	add    $0x10,%esp

	for (int i = 0; i < n_devices; ++i)
 161:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 168:	e9 0b 02 00 00       	jmp    378 <pciInit+0x2e6>
	{
		serial_printf(COM1, "Device %i:\n", i);
 16d:	83 ec 04             	sub    $0x4,%esp
 170:	ff 75 e8             	pushl  -0x18(%ebp)
 173:	68 89 00 00 00       	push   $0x89
 178:	6a 00                	push   $0x0
 17a:	e8 fc ff ff ff       	call   17b <pciInit+0xe9>
 17f:	83 c4 10             	add    $0x10,%esp

		PciDeviceInfo_t* dev = devices + i;
 182:	8b 45 e8             	mov    -0x18(%ebp),%eax
 185:	69 c0 98 00 00 00    	imul   $0x98,%eax,%eax
 18b:	05 00 00 00 00       	add    $0x0,%eax
 190:	89 45 d8             	mov    %eax,-0x28(%ebp)

		serial_printf(COM1, "Device Name: %s\n", pci_device_name(dev->vendorID, dev->deviceID));
 193:	8b 45 d8             	mov    -0x28(%ebp),%eax
 196:	0f b7 40 04          	movzwl 0x4(%eax),%eax
 19a:	0f b7 d0             	movzwl %ax,%edx
 19d:	8b 45 d8             	mov    -0x28(%ebp),%eax
 1a0:	0f b7 40 02          	movzwl 0x2(%eax),%eax
 1a4:	0f b7 c0             	movzwl %ax,%eax
 1a7:	83 ec 08             	sub    $0x8,%esp
 1aa:	52                   	push   %edx
 1ab:	50                   	push   %eax
 1ac:	e8 fc ff ff ff       	call   1ad <pciInit+0x11b>
 1b1:	83 c4 10             	add    $0x10,%esp
 1b4:	83 ec 04             	sub    $0x4,%esp
 1b7:	50                   	push   %eax
 1b8:	68 95 00 00 00       	push   $0x95
 1bd:	6a 00                	push   $0x0
 1bf:	e8 fc ff ff ff       	call   1c0 <pciInit+0x12e>
 1c4:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Class Name: %s\n", pci_class_name(dev->classCode, dev->subClass, dev->progIntf));
 1c7:	8b 45 d8             	mov    -0x28(%ebp),%eax
 1ca:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
 1ce:	0f b6 c8             	movzbl %al,%ecx
 1d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 1d4:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
 1d8:	0f b6 d0             	movzbl %al,%edx
 1db:	8b 45 d8             	mov    -0x28(%ebp),%eax
 1de:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
 1e2:	0f b6 c0             	movzbl %al,%eax
 1e5:	83 ec 04             	sub    $0x4,%esp
 1e8:	51                   	push   %ecx
 1e9:	52                   	push   %edx
 1ea:	50                   	push   %eax
 1eb:	e8 fc ff ff ff       	call   1ec <pciInit+0x15a>
 1f0:	83 c4 10             	add    $0x10,%esp
 1f3:	83 ec 04             	sub    $0x4,%esp
 1f6:	50                   	push   %eax
 1f7:	68 a6 00 00 00       	push   $0xa6
 1fc:	6a 00                	push   $0x0
 1fe:	e8 fc ff ff ff       	call   1ff <pciInit+0x16d>
 203:	83 c4 10             	add    $0x10,%esp

		serial_printf(COM1, "Vendor ID: %x\n", dev->vendorID);
 206:	8b 45 d8             	mov    -0x28(%ebp),%eax
 209:	0f b7 40 02          	movzwl 0x2(%eax),%eax
 20d:	0f b7 c0             	movzwl %ax,%eax
 210:	83 ec 04             	sub    $0x4,%esp
 213:	50                   	push   %eax
 214:	68 b6 00 00 00       	push   $0xb6
 219:	6a 00                	push   $0x0
 21b:	e8 fc ff ff ff       	call   21c <pciInit+0x18a>
 220:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Device ID: %x\n", dev->deviceID);
 223:	8b 45 d8             	mov    -0x28(%ebp),%eax
 226:	0f b7 40 04          	movzwl 0x4(%eax),%eax
 22a:	0f b7 c0             	movzwl %ax,%eax
 22d:	83 ec 04             	sub    $0x4,%esp
 230:	50                   	push   %eax
 231:	68 c5 00 00 00       	push   $0xc5
 236:	6a 00                	push   $0x0
 238:	e8 fc ff ff ff       	call   239 <pciInit+0x1a7>
 23d:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Command: %x\n", dev->command_w); // TODO Print bit for bit
 240:	8b 45 d8             	mov    -0x28(%ebp),%eax
 243:	0f b7 40 06          	movzwl 0x6(%eax),%eax
 247:	0f b7 c0             	movzwl %ax,%eax
 24a:	83 ec 04             	sub    $0x4,%esp
 24d:	50                   	push   %eax
 24e:	68 d4 00 00 00       	push   $0xd4
 253:	6a 00                	push   $0x0
 255:	e8 fc ff ff ff       	call   256 <pciInit+0x1c4>
 25a:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Status: %x\n", dev->status_w); // TODO Print bit for bit
 25d:	8b 45 d8             	mov    -0x28(%ebp),%eax
 260:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 264:	0f b7 c0             	movzwl %ax,%eax
 267:	83 ec 04             	sub    $0x4,%esp
 26a:	50                   	push   %eax
 26b:	68 e1 00 00 00       	push   $0xe1
 270:	6a 00                	push   $0x0
 272:	e8 fc ff ff ff       	call   273 <pciInit+0x1e1>
 277:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Revision ID: %x\n", dev->revisionID);
 27a:	8b 45 d8             	mov    -0x28(%ebp),%eax
 27d:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
 281:	0f b6 c0             	movzbl %al,%eax
 284:	83 ec 04             	sub    $0x4,%esp
 287:	50                   	push   %eax
 288:	68 ed 00 00 00       	push   $0xed
 28d:	6a 00                	push   $0x0
 28f:	e8 fc ff ff ff       	call   290 <pciInit+0x1fe>
 294:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Prog IF: %x\n", dev->progIntf);
 297:	8b 45 d8             	mov    -0x28(%ebp),%eax
 29a:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
 29e:	0f b6 c0             	movzbl %al,%eax
 2a1:	83 ec 04             	sub    $0x4,%esp
 2a4:	50                   	push   %eax
 2a5:	68 fe 00 00 00       	push   $0xfe
 2aa:	6a 00                	push   $0x0
 2ac:	e8 fc ff ff ff       	call   2ad <pciInit+0x21b>
 2b1:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Subclass: %x\n", dev->subClass);
 2b4:	8b 45 d8             	mov    -0x28(%ebp),%eax
 2b7:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
 2bb:	0f b6 c0             	movzbl %al,%eax
 2be:	83 ec 04             	sub    $0x4,%esp
 2c1:	50                   	push   %eax
 2c2:	68 0b 01 00 00       	push   $0x10b
 2c7:	6a 00                	push   $0x0
 2c9:	e8 fc ff ff ff       	call   2ca <pciInit+0x238>
 2ce:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Class Code: %x\n", dev->classCode);
 2d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 2d4:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
 2d8:	0f b6 c0             	movzbl %al,%eax
 2db:	83 ec 04             	sub    $0x4,%esp
 2de:	50                   	push   %eax
 2df:	68 19 01 00 00       	push   $0x119
 2e4:	6a 00                	push   $0x0
 2e6:	e8 fc ff ff ff       	call   2e7 <pciInit+0x255>
 2eb:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Cache line size: %x\n", dev->cacheLineSize);
 2ee:	8b 45 d8             	mov    -0x28(%ebp),%eax
 2f1:	0f b6 40 0e          	movzbl 0xe(%eax),%eax
 2f5:	0f b6 c0             	movzbl %al,%eax
 2f8:	83 ec 04             	sub    $0x4,%esp
 2fb:	50                   	push   %eax
 2fc:	68 29 01 00 00       	push   $0x129
 301:	6a 00                	push   $0x0
 303:	e8 fc ff ff ff       	call   304 <pciInit+0x272>
 308:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Latency Timer: %x\n", dev->latencyTimer);
 30b:	8b 45 d8             	mov    -0x28(%ebp),%eax
 30e:	0f b6 40 0f          	movzbl 0xf(%eax),%eax
 312:	0f b6 c0             	movzbl %al,%eax
 315:	83 ec 04             	sub    $0x4,%esp
 318:	50                   	push   %eax
 319:	68 3e 01 00 00       	push   $0x13e
 31e:	6a 00                	push   $0x0
 320:	e8 fc ff ff ff       	call   321 <pciInit+0x28f>
 325:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "Header Type: %x\n", dev->headerType);
 328:	8b 45 d8             	mov    -0x28(%ebp),%eax
 32b:	0f b6 40 10          	movzbl 0x10(%eax),%eax
 32f:	0f b6 c0             	movzbl %al,%eax
 332:	83 ec 04             	sub    $0x4,%esp
 335:	50                   	push   %eax
 336:	68 51 01 00 00       	push   $0x151
 33b:	6a 00                	push   $0x0
 33d:	e8 fc ff ff ff       	call   33e <pciInit+0x2ac>
 342:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "BIST: %x\n", dev->BIST);
 345:	8b 45 d8             	mov    -0x28(%ebp),%eax
 348:	0f b6 40 11          	movzbl 0x11(%eax),%eax
 34c:	0f b6 c0             	movzbl %al,%eax
 34f:	83 ec 04             	sub    $0x4,%esp
 352:	50                   	push   %eax
 353:	68 62 01 00 00       	push   $0x162
 358:	6a 00                	push   $0x0
 35a:	e8 fc ff ff ff       	call   35b <pciInit+0x2c9>
 35f:	83 c4 10             	add    $0x10,%esp
		serial_printf(COM1, "\n");
 362:	83 ec 08             	sub    $0x8,%esp
 365:	68 6c 01 00 00       	push   $0x16c
 36a:	6a 00                	push   $0x0
 36c:	e8 fc ff ff ff       	call   36d <pciInit+0x2db>
 371:	83 c4 10             	add    $0x10,%esp

	serial_printf(COM1, "\n==========================================\n");
	serial_printf(COM1,   "============ PCI Device List =============\n");
	serial_printf(COM1,   "==========================================\n\n");

	for (int i = 0; i < n_devices; ++i)
 374:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
 378:	a1 e0 0b 00 00       	mov    0xbe0,%eax
 37d:	39 45 e8             	cmp    %eax,-0x18(%ebp)
 380:	0f 8c e7 fd ff ff    	jl     16d <pciInit+0xdb>
		serial_printf(COM1, "Latency Timer: %x\n", dev->latencyTimer);
		serial_printf(COM1, "Header Type: %x\n", dev->headerType);
		serial_printf(COM1, "BIST: %x\n", dev->BIST);
		serial_printf(COM1, "\n");
	}
 386:	90                   	nop
 387:	c9                   	leave  
 388:	c3                   	ret    

physmem.o:     file format elf32-i386


Disassembly of section .text:

00000000 <mmap_set>:

*/

#define BITS_PER_ENTRY 32

void mmap_set(const int bit){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	56                   	push   %esi
   4:	53                   	push   %ebx
	_mmngr_memory_map[bit/BITS_PER_ENTRY] |= (1<<(bit%BITS_PER_ENTRY));
   5:	8b 15 0c 00 00 00    	mov    0xc,%edx
   b:	8b 45 08             	mov    0x8(%ebp),%eax
   e:	8d 48 1f             	lea    0x1f(%eax),%ecx
  11:	85 c0                	test   %eax,%eax
  13:	0f 48 c1             	cmovs  %ecx,%eax
  16:	c1 f8 05             	sar    $0x5,%eax
  19:	c1 e0 02             	shl    $0x2,%eax
  1c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  1f:	8b 15 0c 00 00 00    	mov    0xc,%edx
  25:	8b 45 08             	mov    0x8(%ebp),%eax
  28:	8d 48 1f             	lea    0x1f(%eax),%ecx
  2b:	85 c0                	test   %eax,%eax
  2d:	0f 48 c1             	cmovs  %ecx,%eax
  30:	c1 f8 05             	sar    $0x5,%eax
  33:	c1 e0 02             	shl    $0x2,%eax
  36:	01 d0                	add    %edx,%eax
  38:	8b 30                	mov    (%eax),%esi
  3a:	8b 45 08             	mov    0x8(%ebp),%eax
  3d:	99                   	cltd   
  3e:	c1 ea 1b             	shr    $0x1b,%edx
  41:	01 d0                	add    %edx,%eax
  43:	83 e0 1f             	and    $0x1f,%eax
  46:	29 d0                	sub    %edx,%eax
  48:	ba 01 00 00 00       	mov    $0x1,%edx
  4d:	89 c1                	mov    %eax,%ecx
  4f:	d3 e2                	shl    %cl,%edx
  51:	89 d0                	mov    %edx,%eax
  53:	09 f0                	or     %esi,%eax
  55:	89 03                	mov    %eax,(%ebx)
}
  57:	90                   	nop
  58:	5b                   	pop    %ebx
  59:	5e                   	pop    %esi
  5a:	5d                   	pop    %ebp
  5b:	c3                   	ret    

0000005c <mmap_unset>:

void mmap_unset(const int bit){
  5c:	55                   	push   %ebp
  5d:	89 e5                	mov    %esp,%ebp
  5f:	56                   	push   %esi
  60:	53                   	push   %ebx
	_mmngr_memory_map[bit/BITS_PER_ENTRY] &= ~(1<<(bit%BITS_PER_ENTRY));
  61:	8b 15 0c 00 00 00    	mov    0xc,%edx
  67:	8b 45 08             	mov    0x8(%ebp),%eax
  6a:	8d 48 1f             	lea    0x1f(%eax),%ecx
  6d:	85 c0                	test   %eax,%eax
  6f:	0f 48 c1             	cmovs  %ecx,%eax
  72:	c1 f8 05             	sar    $0x5,%eax
  75:	c1 e0 02             	shl    $0x2,%eax
  78:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  7b:	8b 15 0c 00 00 00    	mov    0xc,%edx
  81:	8b 45 08             	mov    0x8(%ebp),%eax
  84:	8d 48 1f             	lea    0x1f(%eax),%ecx
  87:	85 c0                	test   %eax,%eax
  89:	0f 48 c1             	cmovs  %ecx,%eax
  8c:	c1 f8 05             	sar    $0x5,%eax
  8f:	c1 e0 02             	shl    $0x2,%eax
  92:	01 d0                	add    %edx,%eax
  94:	8b 30                	mov    (%eax),%esi
  96:	8b 45 08             	mov    0x8(%ebp),%eax
  99:	99                   	cltd   
  9a:	c1 ea 1b             	shr    $0x1b,%edx
  9d:	01 d0                	add    %edx,%eax
  9f:	83 e0 1f             	and    $0x1f,%eax
  a2:	29 d0                	sub    %edx,%eax
  a4:	ba 01 00 00 00       	mov    $0x1,%edx
  a9:	89 c1                	mov    %eax,%ecx
  ab:	d3 e2                	shl    %cl,%edx
  ad:	89 d0                	mov    %edx,%eax
  af:	f7 d0                	not    %eax
  b1:	21 f0                	and    %esi,%eax
  b3:	89 03                	mov    %eax,(%ebx)
}
  b5:	90                   	nop
  b6:	5b                   	pop    %ebx
  b7:	5e                   	pop    %esi
  b8:	5d                   	pop    %ebp
  b9:	c3                   	ret    

000000ba <mmap_test>:

int mmap_test(const int bit){
  ba:	55                   	push   %ebp
  bb:	89 e5                	mov    %esp,%ebp
  bd:	53                   	push   %ebx
	return _mmngr_memory_map[bit/BITS_PER_ENTRY] & (1<<(bit%BITS_PER_ENTRY));
  be:	8b 15 0c 00 00 00    	mov    0xc,%edx
  c4:	8b 45 08             	mov    0x8(%ebp),%eax
  c7:	8d 48 1f             	lea    0x1f(%eax),%ecx
  ca:	85 c0                	test   %eax,%eax
  cc:	0f 48 c1             	cmovs  %ecx,%eax
  cf:	c1 f8 05             	sar    $0x5,%eax
  d2:	c1 e0 02             	shl    $0x2,%eax
  d5:	01 d0                	add    %edx,%eax
  d7:	8b 18                	mov    (%eax),%ebx
  d9:	8b 45 08             	mov    0x8(%ebp),%eax
  dc:	99                   	cltd   
  dd:	c1 ea 1b             	shr    $0x1b,%edx
  e0:	01 d0                	add    %edx,%eax
  e2:	83 e0 1f             	and    $0x1f,%eax
  e5:	29 d0                	sub    %edx,%eax
  e7:	ba 01 00 00 00       	mov    $0x1,%edx
  ec:	89 c1                	mov    %eax,%ecx
  ee:	d3 e2                	shl    %cl,%edx
  f0:	89 d0                	mov    %edx,%eax
  f2:	21 d8                	and    %ebx,%eax
}
  f4:	5b                   	pop    %ebx
  f5:	5d                   	pop    %ebp
  f6:	c3                   	ret    

000000f7 <mmap_first_free>:

int mmap_first_free(){
  f7:	55                   	push   %ebp
  f8:	89 e5                	mov    %esp,%ebp
  fa:	53                   	push   %ebx
  fb:	83 ec 14             	sub    $0x14,%esp

	for(uint32_t entry = 0; 
  fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 105:	eb 60                	jmp    167 <mmap_first_free+0x70>
		entry < pmmngr_get_block_count() / BITS_PER_ENTRY; 
		++entry){

		// If the entry is full, go to the next one
		if(_mmngr_memory_map[entry] == 0xFFFFFFFF)
 107:	a1 0c 00 00 00       	mov    0xc,%eax
 10c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 10f:	c1 e2 02             	shl    $0x2,%edx
 112:	01 d0                	add    %edx,%eax
 114:	8b 00                	mov    (%eax),%eax
 116:	83 f8 ff             	cmp    $0xffffffff,%eax
 119:	74 47                	je     162 <mmap_first_free+0x6b>
			continue;

		// Check each bit in the entry
		for(int bit = 0; bit < BITS_PER_ENTRY;  ++bit){
 11b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 122:	eb 36                	jmp    15a <mmap_first_free+0x63>
			if(!(_mmngr_memory_map[entry] & (1<<bit))){
 124:	a1 0c 00 00 00       	mov    0xc,%eax
 129:	8b 55 f4             	mov    -0xc(%ebp),%edx
 12c:	c1 e2 02             	shl    $0x2,%edx
 12f:	01 d0                	add    %edx,%eax
 131:	8b 10                	mov    (%eax),%edx
 133:	8b 45 f0             	mov    -0x10(%ebp),%eax
 136:	bb 01 00 00 00       	mov    $0x1,%ebx
 13b:	89 c1                	mov    %eax,%ecx
 13d:	d3 e3                	shl    %cl,%ebx
 13f:	89 d8                	mov    %ebx,%eax
 141:	21 d0                	and    %edx,%eax
 143:	85 c0                	test   %eax,%eax
 145:	75 0f                	jne    156 <mmap_first_free+0x5f>
				return entry * BITS_PER_ENTRY + bit;
 147:	8b 45 f4             	mov    -0xc(%ebp),%eax
 14a:	c1 e0 05             	shl    $0x5,%eax
 14d:	89 c2                	mov    %eax,%edx
 14f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 152:	01 d0                	add    %edx,%eax
 154:	eb 23                	jmp    179 <mmap_first_free+0x82>
		// If the entry is full, go to the next one
		if(_mmngr_memory_map[entry] == 0xFFFFFFFF)
			continue;

		// Check each bit in the entry
		for(int bit = 0; bit < BITS_PER_ENTRY;  ++bit){
 156:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 15a:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
 15e:	7e c4                	jle    124 <mmap_first_free+0x2d>
 160:	eb 01                	jmp    163 <mmap_first_free+0x6c>
		entry < pmmngr_get_block_count() / BITS_PER_ENTRY; 
		++entry){

		// If the entry is full, go to the next one
		if(_mmngr_memory_map[entry] == 0xFFFFFFFF)
			continue;
 162:	90                   	nop

int mmap_first_free(){

	for(uint32_t entry = 0; 
		entry < pmmngr_get_block_count() / BITS_PER_ENTRY; 
		++entry){
 163:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
}

int mmap_first_free(){

	for(uint32_t entry = 0; 
		entry < pmmngr_get_block_count() / BITS_PER_ENTRY; 
 167:	e8 fc ff ff ff       	call   168 <mmap_first_free+0x71>
 16c:	c1 e8 05             	shr    $0x5,%eax
	return _mmngr_memory_map[bit/BITS_PER_ENTRY] & (1<<(bit%BITS_PER_ENTRY));
}

int mmap_first_free(){

	for(uint32_t entry = 0; 
 16f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 172:	77 93                	ja     107 <mmap_first_free+0x10>
				return entry * BITS_PER_ENTRY + bit;
			}
		}
	}

	return -1;
 174:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 179:	83 c4 14             	add    $0x14,%esp
 17c:	5b                   	pop    %ebx
 17d:	5d                   	pop    %ebp
 17e:	c3                   	ret    

0000017f <mmap_first_free_s>:

int mmap_first_free_s(size_t size){
 17f:	55                   	push   %ebp
 180:	89 e5                	mov    %esp,%ebp
 182:	83 ec 18             	sub    $0x18,%esp

	uint32_t firstFree = mmap_first_free();
 185:	e8 fc ff ff ff       	call   186 <mmap_first_free_s+0x7>
 18a:	89 45 e8             	mov    %eax,-0x18(%ebp)

	// We could not find any free blocks.
	if(firstFree == -1)
 18d:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%ebp)
 191:	75 07                	jne    19a <mmap_first_free_s+0x1b>
		return -1;
 193:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 198:	eb 79                	jmp    213 <mmap_first_free_s+0x94>

	// Don't allocate if there is nothing to allocate
	if(size == 0)
 19a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 19e:	75 07                	jne    1a7 <mmap_first_free_s+0x28>
		return -1;
 1a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 1a5:	eb 6c                	jmp    213 <mmap_first_free_s+0x94>

	// If we only want to allocate one block, we can pick first free
	if(size == 1)
 1a7:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
 1ab:	75 05                	jne    1b2 <mmap_first_free_s+0x33>
		return firstFree;
 1ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
 1b0:	eb 61                	jmp    213 <mmap_first_free_s+0x94>

	// Number of free contiguous blocks found.
	uint32_t free = 0;
 1b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// First free bit of chain
	uint32_t first_bit_in_chain = firstFree;
 1b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
 1bc:	89 45 f0             	mov    %eax,-0x10(%ebp)

	// Loop through each bit from firstFree to end of memory
	for(int bit = firstFree; bit < pmmngr_get_block_count(); ++bit){
 1bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
 1c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
 1c5:	eb 39                	jmp    200 <mmap_first_free_s+0x81>
		// If bit is set (memory not free)
		if(mmap_test(bit)){
 1c7:	83 ec 0c             	sub    $0xc,%esp
 1ca:	ff 75 ec             	pushl  -0x14(%ebp)
 1cd:	e8 fc ff ff ff       	call   1ce <mmap_first_free_s+0x4f>
 1d2:	83 c4 10             	add    $0x10,%esp
 1d5:	85 c0                	test   %eax,%eax
 1d7:	74 12                	je     1eb <mmap_first_free_s+0x6c>
			// Reset counter
			free = 0;
 1d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

			// Next bit is potential new start of chain.
			first_bit_in_chain = bit + 1;
 1e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
 1e3:	83 c0 01             	add    $0x1,%eax
 1e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
 1e9:	eb 04                	jmp    1ef <mmap_first_free_s+0x70>
		} else {
			// Bit is free. Increase counter
			++free;
 1eb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
		}

		// If we found enough bits, we are done
		if(free == size)
 1ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1f2:	3b 45 08             	cmp    0x8(%ebp),%eax
 1f5:	75 05                	jne    1fc <mmap_first_free_s+0x7d>
			return first_bit_in_chain;
 1f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 1fa:	eb 17                	jmp    213 <mmap_first_free_s+0x94>

	// First free bit of chain
	uint32_t first_bit_in_chain = firstFree;

	// Loop through each bit from firstFree to end of memory
	for(int bit = firstFree; bit < pmmngr_get_block_count(); ++bit){
 1fc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 200:	e8 fc ff ff ff       	call   201 <mmap_first_free_s+0x82>
 205:	89 c2                	mov    %eax,%edx
 207:	8b 45 ec             	mov    -0x14(%ebp),%eax
 20a:	39 c2                	cmp    %eax,%edx
 20c:	77 b9                	ja     1c7 <mmap_first_free_s+0x48>
		if(free == size)
			return first_bit_in_chain;
	}

	//We went through all blocks in memory and did not find a chain
	return -1;
 20e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 213:	c9                   	leave  
 214:	c3                   	ret    

00000215 <pmmngr_init>:
//===================================================================
// Physical memory manager
//===================================================================


void pmmngr_init(size_t memsize, physical_addr bitmap){
 215:	55                   	push   %ebp
 216:	89 e5                	mov    %esp,%ebp
 218:	83 ec 18             	sub    $0x18,%esp

	_mmngr_memory_size = memsize;
 21b:	8b 45 08             	mov    0x8(%ebp),%eax
 21e:	a3 00 00 00 00       	mov    %eax,0x0
	_mmngr_memory_map = (uint32_t*)bitmap;
 223:	8b 45 0c             	mov    0xc(%ebp),%eax
 226:	a3 0c 00 00 00       	mov    %eax,0xc
	_mmngr_max_blocks = (pmmngr_get_memory_size()*1024)/PMMNGR_BLOCK_SIZE;
 22b:	e8 fc ff ff ff       	call   22c <pmmngr_init+0x17>
 230:	c1 e0 0a             	shl    $0xa,%eax
 233:	c1 e8 0c             	shr    $0xc,%eax
 236:	a3 08 00 00 00       	mov    %eax,0x8
	_mmngr_used_blocks = _mmngr_max_blocks;
 23b:	a1 08 00 00 00       	mov    0x8,%eax
 240:	a3 04 00 00 00       	mov    %eax,0x4

	printf("PMM Bitmap Size: %i\n", pmmngr_get_block_count() / PMMNGR_BLOCKS_PER_BYTE);
 245:	e8 fc ff ff ff       	call   246 <pmmngr_init+0x31>
 24a:	c1 e8 03             	shr    $0x3,%eax
 24d:	83 ec 08             	sub    $0x8,%esp
 250:	50                   	push   %eax
 251:	68 00 00 00 00       	push   $0x0
 256:	e8 fc ff ff ff       	call   257 <pmmngr_init+0x42>
 25b:	83 c4 10             	add    $0x10,%esp
	//memset(
	//	_mmngr_memory_map,  
	//	0xFF, 
	//	pmmngr_get_block_count() / PMMNGR_BLOCKS_PER_BYTE); 

	int entries = pmmngr_get_block_count() / BITS_PER_ENTRY;
 25e:	e8 fc ff ff ff       	call   25f <pmmngr_init+0x4a>
 263:	c1 e8 05             	shr    $0x5,%eax
 266:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for(int i = 0; i < entries; ++i){
 269:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 270:	eb 17                	jmp    289 <pmmngr_init+0x74>
		
		_mmngr_memory_map[i] = 0xFFFFFFFF;
 272:	a1 0c 00 00 00       	mov    0xc,%eax
 277:	8b 55 f4             	mov    -0xc(%ebp),%edx
 27a:	c1 e2 02             	shl    $0x2,%edx
 27d:	01 d0                	add    %edx,%eax
 27f:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	//	0xFF, 
	//	pmmngr_get_block_count() / PMMNGR_BLOCKS_PER_BYTE); 

	int entries = pmmngr_get_block_count() / BITS_PER_ENTRY;

	for(int i = 0; i < entries; ++i){
 285:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 289:	8b 45 f4             	mov    -0xc(%ebp),%eax
 28c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 28f:	7c e1                	jl     272 <pmmngr_init+0x5d>
		
		_mmngr_memory_map[i] = 0xFFFFFFFF;
		//printf("%p\n", &_mmngr_memory_map[i]);
	}

	printf("PMM init. with bitmap at: %#p, (Entries: %i)\n",_mmngr_memory_map, entries);
 291:	a1 0c 00 00 00       	mov    0xc,%eax
 296:	83 ec 04             	sub    $0x4,%esp
 299:	ff 75 f0             	pushl  -0x10(%ebp)
 29c:	50                   	push   %eax
 29d:	68 18 00 00 00       	push   $0x18
 2a2:	e8 fc ff ff ff       	call   2a3 <pmmngr_init+0x8e>
 2a7:	83 c4 10             	add    $0x10,%esp
}
 2aa:	90                   	nop
 2ab:	c9                   	leave  
 2ac:	c3                   	ret    

000002ad <pmmngr_init_region>:

void pmmngr_init_region(physical_addr base, size_t size){
 2ad:	55                   	push   %ebp
 2ae:	89 e5                	mov    %esp,%ebp
 2b0:	83 ec 18             	sub    $0x18,%esp

	int align = (base - 0xC0000000)/ PMMNGR_BLOCK_SIZE;
 2b3:	8b 45 08             	mov    0x8(%ebp),%eax
 2b6:	05 00 00 00 40       	add    $0x40000000,%eax
 2bb:	c1 e8 0c             	shr    $0xc,%eax
 2be:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int blocks = size / PMMNGR_BLOCK_SIZE;
 2c1:	8b 45 0c             	mov    0xc(%ebp),%eax
 2c4:	c1 e8 0c             	shr    $0xc,%eax
 2c7:	89 45 f0             	mov    %eax,-0x10(%ebp)

	printf("[PHYSMEM] Initiating region with size: %i\n", size);
 2ca:	83 ec 08             	sub    $0x8,%esp
 2cd:	ff 75 0c             	pushl  0xc(%ebp)
 2d0:	68 48 00 00 00       	push   $0x48
 2d5:	e8 fc ff ff ff       	call   2d6 <pmmngr_init_region+0x29>
 2da:	83 c4 10             	add    $0x10,%esp
	

	for(;blocks>=0; blocks--){
 2dd:	eb 26                	jmp    305 <pmmngr_init_region+0x58>
		//printf("[PHYSMEM] Align: %#x, Blocks:%i\n", align, blocks);
		mmap_unset(align++);
 2df:	8b 45 f4             	mov    -0xc(%ebp),%eax
 2e2:	8d 50 01             	lea    0x1(%eax),%edx
 2e5:	89 55 f4             	mov    %edx,-0xc(%ebp)
 2e8:	83 ec 0c             	sub    $0xc,%esp
 2eb:	50                   	push   %eax
 2ec:	e8 fc ff ff ff       	call   2ed <pmmngr_init_region+0x40>
 2f1:	83 c4 10             	add    $0x10,%esp
		_mmngr_used_blocks--;
 2f4:	a1 04 00 00 00       	mov    0x4,%eax
 2f9:	83 e8 01             	sub    $0x1,%eax
 2fc:	a3 04 00 00 00       	mov    %eax,0x4
	int blocks = size / PMMNGR_BLOCK_SIZE;

	printf("[PHYSMEM] Initiating region with size: %i\n", size);
	

	for(;blocks>=0; blocks--){
 301:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
 305:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 309:	79 d4                	jns    2df <pmmngr_init_region+0x32>

	//asm volatile("xchgw %bx, %bx");

	//printf("[PHYSMEM] Done!\n");

	mmap_set(0);
 30b:	83 ec 0c             	sub    $0xc,%esp
 30e:	6a 00                	push   $0x0
 310:	e8 fc ff ff ff       	call   311 <pmmngr_init_region+0x64>
 315:	83 c4 10             	add    $0x10,%esp
}
 318:	90                   	nop
 319:	c9                   	leave  
 31a:	c3                   	ret    

0000031b <pmmngr_deinit_region>:

void pmmngr_deinit_region(physical_addr base, size_t size){
 31b:	55                   	push   %ebp
 31c:	89 e5                	mov    %esp,%ebp
 31e:	83 ec 10             	sub    $0x10,%esp

	int align = (base - 0xC0000000)/ PMMNGR_BLOCK_SIZE;
 321:	8b 45 08             	mov    0x8(%ebp),%eax
 324:	05 00 00 00 40       	add    $0x40000000,%eax
 329:	c1 e8 0c             	shr    $0xc,%eax
 32c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	int blocks = size / PMMNGR_BLOCK_SIZE;
 32f:	8b 45 0c             	mov    0xc(%ebp),%eax
 332:	c1 e8 0c             	shr    $0xc,%eax
 335:	89 45 f8             	mov    %eax,-0x8(%ebp)

	//printf("[PHYSMEM] Deinitiating region\n");

	for(;blocks>=0; blocks--){
 338:	eb 23                	jmp    35d <pmmngr_deinit_region+0x42>
		mmap_set(align++);
 33a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 33d:	8d 50 01             	lea    0x1(%eax),%edx
 340:	89 55 fc             	mov    %edx,-0x4(%ebp)
 343:	50                   	push   %eax
 344:	e8 fc ff ff ff       	call   345 <pmmngr_deinit_region+0x2a>
 349:	83 c4 04             	add    $0x4,%esp
		_mmngr_used_blocks++;
 34c:	a1 04 00 00 00       	mov    0x4,%eax
 351:	83 c0 01             	add    $0x1,%eax
 354:	a3 04 00 00 00       	mov    %eax,0x4
	int align = (base - 0xC0000000)/ PMMNGR_BLOCK_SIZE;
	int blocks = size / PMMNGR_BLOCK_SIZE;

	//printf("[PHYSMEM] Deinitiating region\n");

	for(;blocks>=0; blocks--){
 359:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
 35d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 361:	79 d7                	jns    33a <pmmngr_deinit_region+0x1f>
		mmap_set(align++);
		_mmngr_used_blocks++;
	}
}
 363:	90                   	nop
 364:	c9                   	leave  
 365:	c3                   	ret    

00000366 <pmmngr_alloc_block>:

void* pmmngr_alloc_block(){
 366:	55                   	push   %ebp
 367:	89 e5                	mov    %esp,%ebp
 369:	83 ec 18             	sub    $0x18,%esp

	// Check if we have memory left
	if(pmmngr_get_block_count() <= 0){
 36c:	e8 fc ff ff ff       	call   36d <pmmngr_alloc_block+0x7>
 371:	85 c0                	test   %eax,%eax
 373:	75 17                	jne    38c <pmmngr_alloc_block+0x26>
		printf("[PHYSMEM] No memory left(1)\n");
 375:	83 ec 0c             	sub    $0xc,%esp
 378:	68 73 00 00 00       	push   $0x73
 37d:	e8 fc ff ff ff       	call   37e <pmmngr_alloc_block+0x18>
 382:	83 c4 10             	add    $0x10,%esp
		return 0;
 385:	b8 00 00 00 00       	mov    $0x0,%eax
 38a:	eb 4c                	jmp    3d8 <pmmngr_alloc_block+0x72>
	}
		

	int frame = mmap_first_free();
 38c:	e8 fc ff ff ff       	call   38d <pmmngr_alloc_block+0x27>
 391:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Out of memory
	if(frame == -1){
 394:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
 398:	75 17                	jne    3b1 <pmmngr_alloc_block+0x4b>
		printf("\n[PHYSMEM] No memory left(2)\n");
 39a:	83 ec 0c             	sub    $0xc,%esp
 39d:	68 90 00 00 00       	push   $0x90
 3a2:	e8 fc ff ff ff       	call   3a3 <pmmngr_alloc_block+0x3d>
 3a7:	83 c4 10             	add    $0x10,%esp
		return 0;
 3aa:	b8 00 00 00 00       	mov    $0x0,%eax
 3af:	eb 27                	jmp    3d8 <pmmngr_alloc_block+0x72>
	}
		

	// Mark block as used
	mmap_set(frame);
 3b1:	83 ec 0c             	sub    $0xc,%esp
 3b4:	ff 75 f4             	pushl  -0xc(%ebp)
 3b7:	e8 fc ff ff ff       	call   3b8 <pmmngr_alloc_block+0x52>
 3bc:	83 c4 10             	add    $0x10,%esp

	physical_addr addr = frame * PMMNGR_BLOCK_SIZE;
 3bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
 3c2:	c1 e0 0c             	shl    $0xc,%eax
 3c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	_mmngr_used_blocks++;
 3c8:	a1 04 00 00 00       	mov    0x4,%eax
 3cd:	83 c0 01             	add    $0x1,%eax
 3d0:	a3 04 00 00 00       	mov    %eax,0x4

	// Return address of block start
	return (void*) addr;
 3d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 3d8:	c9                   	leave  
 3d9:	c3                   	ret    

000003da <pmmngr_alloc_block_z>:

void* pmmngr_alloc_block_z(){
 3da:	55                   	push   %ebp
 3db:	89 e5                	mov    %esp,%ebp
 3dd:	83 ec 18             	sub    $0x18,%esp

	// Check if we have memory left
	if(pmmngr_get_block_count() <= 0)
 3e0:	e8 fc ff ff ff       	call   3e1 <pmmngr_alloc_block_z+0x7>
 3e5:	85 c0                	test   %eax,%eax
 3e7:	75 07                	jne    3f0 <pmmngr_alloc_block_z+0x16>
		return 0;
 3e9:	b8 00 00 00 00       	mov    $0x0,%eax
 3ee:	eb 52                	jmp    442 <pmmngr_alloc_block_z+0x68>

	int frame = mmap_first_free();
 3f0:	e8 fc ff ff ff       	call   3f1 <pmmngr_alloc_block_z+0x17>
 3f5:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Out of memory
	if(frame == -1)
 3f8:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
 3fc:	75 07                	jne    405 <pmmngr_alloc_block_z+0x2b>
		return 0;
 3fe:	b8 00 00 00 00       	mov    $0x0,%eax
 403:	eb 3d                	jmp    442 <pmmngr_alloc_block_z+0x68>

	// Mark block as used
	mmap_set(frame);
 405:	83 ec 0c             	sub    $0xc,%esp
 408:	ff 75 f4             	pushl  -0xc(%ebp)
 40b:	e8 fc ff ff ff       	call   40c <pmmngr_alloc_block_z+0x32>
 410:	83 c4 10             	add    $0x10,%esp

	physical_addr addr = frame * PMMNGR_BLOCK_SIZE;
 413:	8b 45 f4             	mov    -0xc(%ebp),%eax
 416:	c1 e0 0c             	shl    $0xc,%eax
 419:	89 45 f0             	mov    %eax,-0x10(%ebp)
	_mmngr_used_blocks++;
 41c:	a1 04 00 00 00       	mov    0x4,%eax
 421:	83 c0 01             	add    $0x1,%eax
 424:	a3 04 00 00 00       	mov    %eax,0x4

	memset(addr, 0x00, PMMNGR_BLOCK_SIZE);
 429:	8b 45 f0             	mov    -0x10(%ebp),%eax
 42c:	83 ec 04             	sub    $0x4,%esp
 42f:	68 00 10 00 00       	push   $0x1000
 434:	6a 00                	push   $0x0
 436:	50                   	push   %eax
 437:	e8 fc ff ff ff       	call   438 <pmmngr_alloc_block_z+0x5e>
 43c:	83 c4 10             	add    $0x10,%esp

	// Return address of block start
	return (void*) addr;
 43f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 442:	c9                   	leave  
 443:	c3                   	ret    

00000444 <pmmngr_free_block>:

void pmmngr_free_block(void* p){
 444:	55                   	push   %ebp
 445:	89 e5                	mov    %esp,%ebp
 447:	83 ec 10             	sub    $0x10,%esp

	// Calculate frame of the address
	physical_addr addr = (physical_addr)p;
 44a:	8b 45 08             	mov    0x8(%ebp),%eax
 44d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	int frame = addr / PMMNGR_BLOCK_SIZE;
 450:	8b 45 fc             	mov    -0x4(%ebp),%eax
 453:	c1 e8 0c             	shr    $0xc,%eax
 456:	89 45 f8             	mov    %eax,-0x8(%ebp)

	// Mark as free
	mmap_unset(frame);
 459:	ff 75 f8             	pushl  -0x8(%ebp)
 45c:	e8 fc ff ff ff       	call   45d <pmmngr_free_block+0x19>
 461:	83 c4 04             	add    $0x4,%esp

	_mmngr_used_blocks--;
 464:	a1 04 00 00 00       	mov    0x4,%eax
 469:	83 e8 01             	sub    $0x1,%eax
 46c:	a3 04 00 00 00       	mov    %eax,0x4
}
 471:	90                   	nop
 472:	c9                   	leave  
 473:	c3                   	ret    

00000474 <pmmngr_alloc_blocks>:

void* pmmngr_alloc_blocks(size_t size){
 474:	55                   	push   %ebp
 475:	89 e5                	mov    %esp,%ebp
 477:	83 ec 18             	sub    $0x18,%esp

	// Out of memory
	if(pmmngr_get_block_count() <= size)
 47a:	e8 fc ff ff ff       	call   47b <pmmngr_alloc_blocks+0x7>
 47f:	3b 45 08             	cmp    0x8(%ebp),%eax
 482:	77 07                	ja     48b <pmmngr_alloc_blocks+0x17>
		return 0;
 484:	b8 00 00 00 00       	mov    $0x0,%eax
 489:	eb 63                	jmp    4ee <pmmngr_alloc_blocks+0x7a>

	int frame = mmap_first_free_s(size);
 48b:	83 ec 0c             	sub    $0xc,%esp
 48e:	ff 75 08             	pushl  0x8(%ebp)
 491:	e8 fc ff ff ff       	call   492 <pmmngr_alloc_blocks+0x1e>
 496:	83 c4 10             	add    $0x10,%esp
 499:	89 45 f0             	mov    %eax,-0x10(%ebp)

	// Out of memory
	if(frame == -1)
 49c:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
 4a0:	75 07                	jne    4a9 <pmmngr_alloc_blocks+0x35>
		return 0;
 4a2:	b8 00 00 00 00       	mov    $0x0,%eax
 4a7:	eb 45                	jmp    4ee <pmmngr_alloc_blocks+0x7a>

	for(uint32_t i = 0; i < size; ++i){
 4a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 4b0:	eb 18                	jmp    4ca <pmmngr_alloc_blocks+0x56>
		mmap_set(frame + i);
 4b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 4b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 4b8:	01 d0                	add    %edx,%eax
 4ba:	83 ec 0c             	sub    $0xc,%esp
 4bd:	50                   	push   %eax
 4be:	e8 fc ff ff ff       	call   4bf <pmmngr_alloc_blocks+0x4b>
 4c3:	83 c4 10             	add    $0x10,%esp

	// Out of memory
	if(frame == -1)
		return 0;

	for(uint32_t i = 0; i < size; ++i){
 4c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 4ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
 4cd:	3b 45 08             	cmp    0x8(%ebp),%eax
 4d0:	72 e0                	jb     4b2 <pmmngr_alloc_blocks+0x3e>
		mmap_set(frame + i);
	}

	physical_addr addr = frame * PMMNGR_BLOCK_SIZE;
 4d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 4d5:	c1 e0 0c             	shl    $0xc,%eax
 4d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	_mmngr_used_blocks += size;
 4db:	8b 15 04 00 00 00    	mov    0x4,%edx
 4e1:	8b 45 08             	mov    0x8(%ebp),%eax
 4e4:	01 d0                	add    %edx,%eax
 4e6:	a3 04 00 00 00       	mov    %eax,0x4

	return (void*) addr;
 4eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 4ee:	c9                   	leave  
 4ef:	c3                   	ret    

000004f0 <pmmngr_alloc_blocks_z>:

void* pmmngr_alloc_blocks_z(size_t size){
 4f0:	55                   	push   %ebp
 4f1:	89 e5                	mov    %esp,%ebp
 4f3:	83 ec 18             	sub    $0x18,%esp

	// Out of memory
	if(pmmngr_get_block_count() <= size)
 4f6:	e8 fc ff ff ff       	call   4f7 <pmmngr_alloc_blocks_z+0x7>
 4fb:	3b 45 08             	cmp    0x8(%ebp),%eax
 4fe:	77 07                	ja     507 <pmmngr_alloc_blocks_z+0x17>
		return 0;
 500:	b8 00 00 00 00       	mov    $0x0,%eax
 505:	eb 7d                	jmp    584 <pmmngr_alloc_blocks_z+0x94>

	int frame = mmap_first_free_s(size);
 507:	83 ec 0c             	sub    $0xc,%esp
 50a:	ff 75 08             	pushl  0x8(%ebp)
 50d:	e8 fc ff ff ff       	call   50e <pmmngr_alloc_blocks_z+0x1e>
 512:	83 c4 10             	add    $0x10,%esp
 515:	89 45 f0             	mov    %eax,-0x10(%ebp)

	// Out of memory
	if(frame == -1)
 518:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
 51c:	75 07                	jne    525 <pmmngr_alloc_blocks_z+0x35>
		return 0;
 51e:	b8 00 00 00 00       	mov    $0x0,%eax
 523:	eb 5f                	jmp    584 <pmmngr_alloc_blocks_z+0x94>

	for(uint32_t i = 0; i < size; ++i){
 525:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 52c:	eb 18                	jmp    546 <pmmngr_alloc_blocks_z+0x56>
		mmap_set(frame + i);
 52e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 531:	8b 45 f4             	mov    -0xc(%ebp),%eax
 534:	01 d0                	add    %edx,%eax
 536:	83 ec 0c             	sub    $0xc,%esp
 539:	50                   	push   %eax
 53a:	e8 fc ff ff ff       	call   53b <pmmngr_alloc_blocks_z+0x4b>
 53f:	83 c4 10             	add    $0x10,%esp

	// Out of memory
	if(frame == -1)
		return 0;

	for(uint32_t i = 0; i < size; ++i){
 542:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 546:	8b 45 f4             	mov    -0xc(%ebp),%eax
 549:	3b 45 08             	cmp    0x8(%ebp),%eax
 54c:	72 e0                	jb     52e <pmmngr_alloc_blocks_z+0x3e>
		mmap_set(frame + i);
	}

	physical_addr addr = frame * PMMNGR_BLOCK_SIZE;
 54e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 551:	c1 e0 0c             	shl    $0xc,%eax
 554:	89 45 ec             	mov    %eax,-0x14(%ebp)
	_mmngr_used_blocks += size;
 557:	8b 15 04 00 00 00    	mov    0x4,%edx
 55d:	8b 45 08             	mov    0x8(%ebp),%eax
 560:	01 d0                	add    %edx,%eax
 562:	a3 04 00 00 00       	mov    %eax,0x4

	memset(addr, 0x00, PMMNGR_BLOCK_SIZE * size);
 567:	8b 45 08             	mov    0x8(%ebp),%eax
 56a:	c1 e0 0c             	shl    $0xc,%eax
 56d:	89 c2                	mov    %eax,%edx
 56f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 572:	83 ec 04             	sub    $0x4,%esp
 575:	52                   	push   %edx
 576:	6a 00                	push   $0x0
 578:	50                   	push   %eax
 579:	e8 fc ff ff ff       	call   57a <pmmngr_alloc_blocks_z+0x8a>
 57e:	83 c4 10             	add    $0x10,%esp

	return (void*) addr;
 581:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 584:	c9                   	leave  
 585:	c3                   	ret    

00000586 <pmmngr_free_blocks>:

void pmmngr_free_blocks(void* p, size_t size){
 586:	55                   	push   %ebp
 587:	89 e5                	mov    %esp,%ebp
 589:	83 ec 10             	sub    $0x10,%esp

	// Calculate start frame from the address
	physical_addr addr = (physical_addr)p;
 58c:	8b 45 08             	mov    0x8(%ebp),%eax
 58f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	int frame = addr / PMMNGR_BLOCK_SIZE;
 592:	8b 45 f8             	mov    -0x8(%ebp),%eax
 595:	c1 e8 0c             	shr    $0xc,%eax
 598:	89 45 f4             	mov    %eax,-0xc(%ebp)

	for(uint32_t i = 0; i < size; ++i){
 59b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 5a2:	eb 15                	jmp    5b9 <pmmngr_free_blocks+0x33>
		mmap_unset(frame + i);
 5a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
 5a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 5aa:	01 d0                	add    %edx,%eax
 5ac:	50                   	push   %eax
 5ad:	e8 fc ff ff ff       	call   5ae <pmmngr_free_blocks+0x28>
 5b2:	83 c4 04             	add    $0x4,%esp

	// Calculate start frame from the address
	physical_addr addr = (physical_addr)p;
	int frame = addr / PMMNGR_BLOCK_SIZE;

	for(uint32_t i = 0; i < size; ++i){
 5b5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 5b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
 5bc:	3b 45 0c             	cmp    0xc(%ebp),%eax
 5bf:	72 e3                	jb     5a4 <pmmngr_free_blocks+0x1e>
		mmap_unset(frame + i);
	}

	_mmngr_used_blocks -= size;
 5c1:	a1 04 00 00 00       	mov    0x4,%eax
 5c6:	2b 45 0c             	sub    0xc(%ebp),%eax
 5c9:	a3 04 00 00 00       	mov    %eax,0x4
}
 5ce:	90                   	nop
 5cf:	c9                   	leave  
 5d0:	c3                   	ret    

000005d1 <pmmngr_get_memory_size>:

size_t pmmngr_get_memory_size(){
 5d1:	55                   	push   %ebp
 5d2:	89 e5                	mov    %esp,%ebp
	return _mmngr_memory_size;
 5d4:	a1 00 00 00 00       	mov    0x0,%eax
}
 5d9:	5d                   	pop    %ebp
 5da:	c3                   	ret    

000005db <pmmngr_get_block_count>:

uint32_t pmmngr_get_block_count(){
 5db:	55                   	push   %ebp
 5dc:	89 e5                	mov    %esp,%ebp
	return _mmngr_max_blocks;
 5de:	a1 08 00 00 00       	mov    0x8,%eax
}
 5e3:	5d                   	pop    %ebp
 5e4:	c3                   	ret    

000005e5 <pmmngr_get_use_block_count>:

uint32_t pmmngr_get_use_block_count(){
 5e5:	55                   	push   %ebp
 5e6:	89 e5                	mov    %esp,%ebp
	return _mmngr_used_blocks;
 5e8:	a1 04 00 00 00       	mov    0x4,%eax
}
 5ed:	5d                   	pop    %ebp
 5ee:	c3                   	ret    

000005ef <pmmngr_get_free_block_count>:

uint32_t pmmngr_get_free_block_count(){
 5ef:	55                   	push   %ebp
 5f0:	89 e5                	mov    %esp,%ebp
	return _mmngr_max_blocks - _mmngr_used_blocks;
 5f2:	8b 15 08 00 00 00    	mov    0x8,%edx
 5f8:	a1 04 00 00 00       	mov    0x4,%eax
 5fd:	29 c2                	sub    %eax,%edx
 5ff:	89 d0                	mov    %edx,%eax
}
 601:	5d                   	pop    %ebp
 602:	c3                   	ret    

00000603 <pmmngr_get_block_size>:

uint32_t pmmngr_get_block_size(){
 603:	55                   	push   %ebp
 604:	89 e5                	mov    %esp,%ebp
	return PMMNGR_BLOCK_SIZE;
 606:	b8 00 10 00 00       	mov    $0x1000,%eax
}
 60b:	5d                   	pop    %ebp
 60c:	c3                   	ret    

0000060d <pmmngr_paging_enable>:

void pmmngr_paging_enable(int b){
 60d:	55                   	push   %ebp
 60e:	89 e5                	mov    %esp,%ebp
 610:	83 ec 10             	sub    $0x10,%esp

	uint32_t cr0_reg;

	// Fetch data in cr0
	asm volatile ("mov %%cr0, %0" : "=r"(cr0_reg));
 613:	0f 20 c0             	mov    %cr0,%eax
 616:	89 45 fc             	mov    %eax,-0x4(%ebp)

	
	if(b){ // If we should enable paging
 619:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 61d:	74 09                	je     628 <pmmngr_paging_enable+0x1b>
		cr0_reg |= 0x80000000;
 61f:	81 4d fc 00 00 00 80 	orl    $0x80000000,-0x4(%ebp)
 626:	eb 07                	jmp    62f <pmmngr_paging_enable+0x22>
	} else {// If we should disable paging
		cr0_reg &= 0x7FFFFFFF;
 628:	81 65 fc ff ff ff 7f 	andl   $0x7fffffff,-0x4(%ebp)
	}

	// Store new data in cr0
	asm volatile ("mov %0, %%cr0" :: "r"(cr0_reg));
 62f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 632:	0f 22 c0             	mov    %eax,%cr0
}
 635:	90                   	nop
 636:	c9                   	leave  
 637:	c3                   	ret    

00000638 <pmmngr_is_paging>:

int pmmngr_is_paging(){
 638:	55                   	push   %ebp
 639:	89 e5                	mov    %esp,%ebp
 63b:	83 ec 10             	sub    $0x10,%esp

	uint32_t cr0_reg;

	// Fetch data in cr0
	asm volatile ("mov %%cr0, %0" : "=r"(cr0_reg));
 63e:	0f 20 c0             	mov    %cr0,%eax
 641:	89 45 fc             	mov    %eax,-0x4(%ebp)

	return (cr0_reg & 0x80000000) ? 1 : 0;
 644:	8b 45 fc             	mov    -0x4(%ebp),%eax
 647:	c1 e8 1f             	shr    $0x1f,%eax
 64a:	0f b6 c0             	movzbl %al,%eax
}
 64d:	c9                   	leave  
 64e:	c3                   	ret    

0000064f <pmmngr_load_PBDR>:

void pmmngr_load_PBDR(physical_addr addr){
 64f:	55                   	push   %ebp
 650:	89 e5                	mov    %esp,%ebp
	asm volatile ("mov %0, %%cr3" :: "r"(addr));
 652:	8b 45 08             	mov    0x8(%ebp),%eax
 655:	0f 22 d8             	mov    %eax,%cr3
}
 658:	90                   	nop
 659:	5d                   	pop    %ebp
 65a:	c3                   	ret    

0000065b <pmmngr_get_PBDR>:

physical_addr pmmngr_get_PBDR(){
 65b:	55                   	push   %ebp
 65c:	89 e5                	mov    %esp,%ebp
 65e:	83 ec 10             	sub    $0x10,%esp
	physical_addr PBDR;

	// Fetch data in cr3
	asm volatile ("mov %%cr3, %0" : "=r"(PBDR));
 661:	0f 20 d8             	mov    %cr3,%eax
 664:	89 45 fc             	mov    %eax,-0x4(%ebp)

	return PBDR;
 667:	8b 45 fc             	mov    -0x4(%ebp),%eax
 66a:	c9                   	leave  
 66b:	c3                   	ret    

pic.o:     file format elf32-i386


Disassembly of section .text:

00000000 <i86_pic_read_data>:
#define I86_PIC_ICW4_BUF_MODEYES		8			//1000
#define I86_PIC_ICW4_BUF_MODENO			0			//0
#define I86_PIC_ICW4_SFNM_NESTEDMODE	0x10		//10000
#define I86_PIC_ICW4_SFNM_NOTNESTED		0			//0

uint8_t i86_pic_read_data(uint8_t picNum){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if(picNum > 1)
   c:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
  10:	76 07                	jbe    19 <i86_pic_read_data+0x19>
		return 0;
  12:	b8 00 00 00 00       	mov    $0x0,%eax
  17:	eb 25                	jmp    3e <i86_pic_read_data+0x3e>

	uint8_t reg = (picNum == 1) ? I86_PIC2_REG_DATA : I86_PIC1_REG_DATA;
  19:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
  1d:	75 07                	jne    26 <i86_pic_read_data+0x26>
  1f:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
  24:	eb 05                	jmp    2b <i86_pic_read_data+0x2b>
  26:	b8 21 00 00 00       	mov    $0x21,%eax
  2b:	88 45 f7             	mov    %al,-0x9(%ebp)
	return inportb(reg);
  2e:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  32:	83 ec 0c             	sub    $0xc,%esp
  35:	50                   	push   %eax
  36:	e8 fc ff ff ff       	call   37 <i86_pic_read_data+0x37>
  3b:	83 c4 10             	add    $0x10,%esp
}
  3e:	c9                   	leave  
  3f:	c3                   	ret    

00000040 <i86_pic_send_data>:

void i86_pic_send_data(uint8_t data, uint8_t picNum){
  40:	55                   	push   %ebp
  41:	89 e5                	mov    %esp,%ebp
  43:	83 ec 28             	sub    $0x28,%esp
  46:	8b 55 08             	mov    0x8(%ebp),%edx
  49:	8b 45 0c             	mov    0xc(%ebp),%eax
  4c:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  4f:	88 45 e0             	mov    %al,-0x20(%ebp)
	if(picNum > 1)
  52:	80 7d e0 01          	cmpb   $0x1,-0x20(%ebp)
  56:	77 2c                	ja     84 <i86_pic_send_data+0x44>
		return 0;

	uint8_t reg = (picNum == 1) ? I86_PIC2_REG_DATA : I86_PIC1_REG_DATA;
  58:	80 7d e0 01          	cmpb   $0x1,-0x20(%ebp)
  5c:	75 07                	jne    65 <i86_pic_send_data+0x25>
  5e:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
  63:	eb 05                	jmp    6a <i86_pic_send_data+0x2a>
  65:	b8 21 00 00 00       	mov    $0x21,%eax
  6a:	88 45 f7             	mov    %al,-0x9(%ebp)
	return outportb(reg, data);
  6d:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
  71:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  75:	83 ec 08             	sub    $0x8,%esp
  78:	52                   	push   %edx
  79:	50                   	push   %eax
  7a:	e8 fc ff ff ff       	call   7b <i86_pic_send_data+0x3b>
  7f:	83 c4 10             	add    $0x10,%esp
  82:	eb 01                	jmp    85 <i86_pic_send_data+0x45>
	return inportb(reg);
}

void i86_pic_send_data(uint8_t data, uint8_t picNum){
	if(picNum > 1)
		return 0;
  84:	90                   	nop

	uint8_t reg = (picNum == 1) ? I86_PIC2_REG_DATA : I86_PIC1_REG_DATA;
	return outportb(reg, data);
}
  85:	c9                   	leave  
  86:	c3                   	ret    

00000087 <i86_pic_send_command>:

void i86_pic_send_command(uint8_t cmd, uint8_t picNum){
  87:	55                   	push   %ebp
  88:	89 e5                	mov    %esp,%ebp
  8a:	83 ec 28             	sub    $0x28,%esp
  8d:	8b 55 08             	mov    0x8(%ebp),%edx
  90:	8b 45 0c             	mov    0xc(%ebp),%eax
  93:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  96:	88 45 e0             	mov    %al,-0x20(%ebp)
	if (picNum > 1)
  99:	80 7d e0 01          	cmpb   $0x1,-0x20(%ebp)
  9d:	77 2c                	ja     cb <i86_pic_send_command+0x44>
		return;

	uint8_t	reg = (picNum==1) ? I86_PIC2_REG_COMMAND : I86_PIC1_REG_COMMAND;
  9f:	80 7d e0 01          	cmpb   $0x1,-0x20(%ebp)
  a3:	75 07                	jne    ac <i86_pic_send_command+0x25>
  a5:	b8 a0 ff ff ff       	mov    $0xffffffa0,%eax
  aa:	eb 05                	jmp    b1 <i86_pic_send_command+0x2a>
  ac:	b8 20 00 00 00       	mov    $0x20,%eax
  b1:	88 45 f7             	mov    %al,-0x9(%ebp)
	outportb (reg, cmd);
  b4:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
  b8:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  bc:	83 ec 08             	sub    $0x8,%esp
  bf:	52                   	push   %edx
  c0:	50                   	push   %eax
  c1:	e8 fc ff ff ff       	call   c2 <i86_pic_send_command+0x3b>
  c6:	83 c4 10             	add    $0x10,%esp
  c9:	eb 01                	jmp    cc <i86_pic_send_command+0x45>
	return outportb(reg, data);
}

void i86_pic_send_command(uint8_t cmd, uint8_t picNum){
	if (picNum > 1)
		return;
  cb:	90                   	nop

	uint8_t	reg = (picNum==1) ? I86_PIC2_REG_COMMAND : I86_PIC1_REG_COMMAND;
	outportb (reg, cmd);
}
  cc:	c9                   	leave  
  cd:	c3                   	ret    

000000ce <i86_pic_initialize>:

void i86_pic_initialize(uint8_t base0, uint8_t base1){
  ce:	55                   	push   %ebp
  cf:	89 e5                	mov    %esp,%ebp
  d1:	83 ec 28             	sub    $0x28,%esp
  d4:	8b 55 08             	mov    0x8(%ebp),%edx
  d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  da:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  dd:	88 45 e0             	mov    %al,-0x20(%ebp)
	uint8_t icw = 0;
  e0:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	
	disable();
  e4:	e8 fc ff ff ff       	call   e5 <i86_pic_initialize+0x17>

	icw = (icw & ~I86_PIC_ICW1_MASK_INIT) | I86_PIC_ICW1_INIT_YES;
  e9:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
	icw = (icw & ~I86_PIC_ICW1_MASK_IC4) | I86_PIC_ICW1_IC4_EXPECT;
  ed:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)

	// Send ICW1
	i86_pic_send_command (icw, 0);
  f1:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  f5:	83 ec 08             	sub    $0x8,%esp
  f8:	6a 00                	push   $0x0
  fa:	50                   	push   %eax
  fb:	e8 fc ff ff ff       	call   fc <i86_pic_initialize+0x2e>
 100:	83 c4 10             	add    $0x10,%esp
	i86_pic_send_command (icw, 1);
 103:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
 107:	83 ec 08             	sub    $0x8,%esp
 10a:	6a 01                	push   $0x1
 10c:	50                   	push   %eax
 10d:	e8 fc ff ff ff       	call   10e <i86_pic_initialize+0x40>
 112:	83 c4 10             	add    $0x10,%esp

	// Send ICW2
	i86_pic_send_data (base0, 0);
 115:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 119:	83 ec 08             	sub    $0x8,%esp
 11c:	6a 00                	push   $0x0
 11e:	50                   	push   %eax
 11f:	e8 fc ff ff ff       	call   120 <i86_pic_initialize+0x52>
 124:	83 c4 10             	add    $0x10,%esp
	i86_pic_send_data (base1, 1);
 127:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
 12b:	83 ec 08             	sub    $0x8,%esp
 12e:	6a 01                	push   $0x1
 130:	50                   	push   %eax
 131:	e8 fc ff ff ff       	call   132 <i86_pic_initialize+0x64>
 136:	83 c4 10             	add    $0x10,%esp

	// Send ICW3
	i86_pic_send_data (0x04, 0);
 139:	83 ec 08             	sub    $0x8,%esp
 13c:	6a 00                	push   $0x0
 13e:	6a 04                	push   $0x4
 140:	e8 fc ff ff ff       	call   141 <i86_pic_initialize+0x73>
 145:	83 c4 10             	add    $0x10,%esp
	i86_pic_send_data (0x02, 1);
 148:	83 ec 08             	sub    $0x8,%esp
 14b:	6a 01                	push   $0x1
 14d:	6a 02                	push   $0x2
 14f:	e8 fc ff ff ff       	call   150 <i86_pic_initialize+0x82>
 154:	83 c4 10             	add    $0x10,%esp

	icw = (icw & ~I86_PIC_ICW4_MASK_UPM) | I86_PIC_ICW4_UPM_86MODE;
 157:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)

	// Send ICW4
	i86_pic_send_data (icw, 0);
 15b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
 15f:	83 ec 08             	sub    $0x8,%esp
 162:	6a 00                	push   $0x0
 164:	50                   	push   %eax
 165:	e8 fc ff ff ff       	call   166 <i86_pic_initialize+0x98>
 16a:	83 c4 10             	add    $0x10,%esp
	i86_pic_send_data (icw, 1);
 16d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
 171:	83 ec 08             	sub    $0x8,%esp
 174:	6a 01                	push   $0x1
 176:	50                   	push   %eax
 177:	e8 fc ff ff ff       	call   178 <i86_pic_initialize+0xaa>
 17c:	83 c4 10             	add    $0x10,%esp
 17f:	90                   	nop
 180:	c9                   	leave  
 181:	c3                   	ret    

pit.o:     file format elf32-i386


Disassembly of section .text:

00000000 <i86_pit_irq>:

int _pit_bIsInit = 0;

void i86_pit_irq();

void i86_pit_irq(){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	asm volatile ("add $12, %esp");
   6:	83 c4 0c             	add    $0xc,%esp
	__asm__("pushal");
   9:	60                   	pusha  

	_pit_ticks++;
   a:	a1 00 00 00 00       	mov    0x0,%eax
   f:	83 c0 01             	add    $0x1,%eax
  12:	a3 00 00 00 00       	mov    %eax,0x0
	interruptdone(0);
  17:	83 ec 0c             	sub    $0xc,%esp
  1a:	6a 00                	push   $0x0
  1c:	e8 fc ff ff ff       	call   1d <i86_pit_irq+0x1d>
  21:	83 c4 10             	add    $0x10,%esp
	__asm__("popal; leave; iret");
  24:	61                   	popa   
  25:	c9                   	leave  
  26:	cf                   	iret   
}
  27:	90                   	nop
  28:	c9                   	leave  
  29:	c3                   	ret    

0000002a <i86_pit_send_command>:

void i86_pit_send_command(uint8_t cmd){
  2a:	55                   	push   %ebp
  2b:	89 e5                	mov    %esp,%ebp
  2d:	83 ec 18             	sub    $0x18,%esp
  30:	8b 45 08             	mov    0x8(%ebp),%eax
  33:	88 45 f4             	mov    %al,-0xc(%ebp)
	outportb(I86_PIT_REG_COMMAND, cmd);
  36:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  3a:	83 ec 08             	sub    $0x8,%esp
  3d:	50                   	push   %eax
  3e:	6a 43                	push   $0x43
  40:	e8 fc ff ff ff       	call   41 <i86_pit_send_command+0x17>
  45:	83 c4 10             	add    $0x10,%esp
}
  48:	90                   	nop
  49:	c9                   	leave  
  4a:	c3                   	ret    

0000004b <i86_pit_send_data>:

// TODO: clean up
void i86_pit_send_data(uint16_t data, uint8_t counter){
  4b:	55                   	push   %ebp
  4c:	89 e5                	mov    %esp,%ebp
  4e:	83 ec 28             	sub    $0x28,%esp
  51:	8b 55 08             	mov    0x8(%ebp),%edx
  54:	8b 45 0c             	mov    0xc(%ebp),%eax
  57:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  5b:	88 45 e0             	mov    %al,-0x20(%ebp)
	uint8_t	port= (counter==I86_PIT_OCW_COUNTER_0) ? I86_PIT_REG_COUNTER0 :
  5e:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
  62:	74 14                	je     78 <i86_pit_send_data+0x2d>
  64:	80 7d e0 40          	cmpb   $0x40,-0x20(%ebp)
  68:	75 07                	jne    71 <i86_pit_send_data+0x26>
  6a:	b8 41 00 00 00       	mov    $0x41,%eax
  6f:	eb 0c                	jmp    7d <i86_pit_send_data+0x32>
  71:	b8 42 00 00 00       	mov    $0x42,%eax
  76:	eb 05                	jmp    7d <i86_pit_send_data+0x32>
  78:	b8 40 00 00 00       	mov    $0x40,%eax
  7d:	88 45 f7             	mov    %al,-0x9(%ebp)
		((counter==I86_PIT_OCW_COUNTER_1) ? I86_PIT_REG_COUNTER1 : I86_PIT_REG_COUNTER2);

	outportb (port, (uint8_t)data);
  80:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  84:	0f b6 d0             	movzbl %al,%edx
  87:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  8b:	83 ec 08             	sub    $0x8,%esp
  8e:	52                   	push   %edx
  8f:	50                   	push   %eax
  90:	e8 fc ff ff ff       	call   91 <i86_pit_send_data+0x46>
  95:	83 c4 10             	add    $0x10,%esp
}
  98:	90                   	nop
  99:	c9                   	leave  
  9a:	c3                   	ret    

0000009b <i86_pit_read_data>:

// TODO: clean up
uint8_t i86_pit_read_data(uint16_t counter){
  9b:	55                   	push   %ebp
  9c:	89 e5                	mov    %esp,%ebp
  9e:	83 ec 28             	sub    $0x28,%esp
  a1:	8b 45 08             	mov    0x8(%ebp),%eax
  a4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	uint8_t	port= (counter==I86_PIT_OCW_COUNTER_0) ? I86_PIT_REG_COUNTER0 :
  a8:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  ad:	74 15                	je     c4 <i86_pit_read_data+0x29>
  af:	66 83 7d e4 40       	cmpw   $0x40,-0x1c(%ebp)
  b4:	75 07                	jne    bd <i86_pit_read_data+0x22>
  b6:	b8 41 00 00 00       	mov    $0x41,%eax
  bb:	eb 0c                	jmp    c9 <i86_pit_read_data+0x2e>
  bd:	b8 42 00 00 00       	mov    $0x42,%eax
  c2:	eb 05                	jmp    c9 <i86_pit_read_data+0x2e>
  c4:	b8 40 00 00 00       	mov    $0x40,%eax
  c9:	88 45 f7             	mov    %al,-0x9(%ebp)
		((counter==I86_PIT_OCW_COUNTER_1) ? I86_PIT_REG_COUNTER1 : I86_PIT_REG_COUNTER2);

	return inportb (port);
  cc:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  d0:	83 ec 0c             	sub    $0xc,%esp
  d3:	50                   	push   %eax
  d4:	e8 fc ff ff ff       	call   d5 <i86_pit_read_data+0x3a>
  d9:	83 c4 10             	add    $0x10,%esp
}
  dc:	c9                   	leave  
  dd:	c3                   	ret    

000000de <i86_pit_set_tick_count>:

uint32_t i86_pit_set_tick_count(uint32_t i){
  de:	55                   	push   %ebp
  df:	89 e5                	mov    %esp,%ebp
  e1:	83 ec 10             	sub    $0x10,%esp
	uint32_t ret = _pit_ticks;
  e4:	a1 00 00 00 00       	mov    0x0,%eax
  e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	_pit_ticks = i;
  ec:	8b 45 08             	mov    0x8(%ebp),%eax
  ef:	a3 00 00 00 00       	mov    %eax,0x0
	return ret;
  f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  f7:	c9                   	leave  
  f8:	c3                   	ret    

000000f9 <i86_pit_get_tick_count>:

uint32_t i86_pit_get_tick_count(){
  f9:	55                   	push   %ebp
  fa:	89 e5                	mov    %esp,%ebp
	return _pit_ticks;
  fc:	a1 00 00 00 00       	mov    0x0,%eax
}
 101:	5d                   	pop    %ebp
 102:	c3                   	ret    

00000103 <i86_pit_start_counter>:

void i86_pit_start_counter(uint32_t freq, uint8_t counter, uint8_t mode){
 103:	55                   	push   %ebp
 104:	89 e5                	mov    %esp,%ebp
 106:	83 ec 28             	sub    $0x28,%esp
 109:	8b 55 0c             	mov    0xc(%ebp),%edx
 10c:	8b 45 10             	mov    0x10(%ebp),%eax
 10f:	88 55 e4             	mov    %dl,-0x1c(%ebp)
 112:	88 45 e0             	mov    %al,-0x20(%ebp)
	if(freq == 0)
 115:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 119:	0f 84 88 00 00 00    	je     1a7 <i86_pit_start_counter+0xa4>
		return;

	uint16_t divisor = (uint16_t)(1193181/(uint16_t)freq);
 11f:	8b 45 08             	mov    0x8(%ebp),%eax
 122:	0f b7 c8             	movzwl %ax,%ecx
 125:	b8 dd 34 12 00       	mov    $0x1234dd,%eax
 12a:	99                   	cltd   
 12b:	f7 f9                	idiv   %ecx
 12d:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

	uint8_t ocw=0;
 131:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
	ocw = (ocw & ~I86_PIT_OCW_MASK_MODE) | mode;
 135:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
 139:	83 e0 f1             	and    $0xfffffff1,%eax
 13c:	89 c2                	mov    %eax,%edx
 13e:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
 142:	09 d0                	or     %edx,%eax
 144:	88 45 f5             	mov    %al,-0xb(%ebp)
	ocw = (ocw & ~I86_PIT_OCW_MASK_RL) | I86_PIT_OCW_RL_DATA;
 147:	80 4d f5 30          	orb    $0x30,-0xb(%ebp)
	ocw = (ocw & ~I86_PIT_OCW_MASK_COUNTER) | counter;
 14b:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
 14f:	83 e0 3f             	and    $0x3f,%eax
 152:	89 c2                	mov    %eax,%edx
 154:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 158:	09 d0                	or     %edx,%eax
 15a:	88 45 f5             	mov    %al,-0xb(%ebp)
	i86_pit_send_command (ocw);
 15d:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
 161:	83 ec 0c             	sub    $0xc,%esp
 164:	50                   	push   %eax
 165:	e8 fc ff ff ff       	call   166 <i86_pit_start_counter+0x63>
 16a:	83 c4 10             	add    $0x10,%esp

	i86_pit_send_data (divisor & 0xff, 0);
 16d:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 171:	0f b6 c0             	movzbl %al,%eax
 174:	83 ec 08             	sub    $0x8,%esp
 177:	6a 00                	push   $0x0
 179:	50                   	push   %eax
 17a:	e8 fc ff ff ff       	call   17b <i86_pit_start_counter+0x78>
 17f:	83 c4 10             	add    $0x10,%esp
	i86_pit_send_data ((divisor >> 8) & 0xff, 0);
 182:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 186:	66 c1 e8 08          	shr    $0x8,%ax
 18a:	0f b7 c0             	movzwl %ax,%eax
 18d:	83 ec 08             	sub    $0x8,%esp
 190:	6a 00                	push   $0x0
 192:	50                   	push   %eax
 193:	e8 fc ff ff ff       	call   194 <i86_pit_start_counter+0x91>
 198:	83 c4 10             	add    $0x10,%esp

	_pit_ticks=0;
 19b:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 1a2:	00 00 00 
 1a5:	eb 01                	jmp    1a8 <i86_pit_start_counter+0xa5>
	return _pit_ticks;
}

void i86_pit_start_counter(uint32_t freq, uint8_t counter, uint8_t mode){
	if(freq == 0)
		return;
 1a7:	90                   	nop

	i86_pit_send_data (divisor & 0xff, 0);
	i86_pit_send_data ((divisor >> 8) & 0xff, 0);

	_pit_ticks=0;
}
 1a8:	c9                   	leave  
 1a9:	c3                   	ret    

000001aa <i86_pit_initialize>:

void i86_pit_initialize(){
 1aa:	55                   	push   %ebp
 1ab:	89 e5                	mov    %esp,%ebp
 1ad:	83 ec 08             	sub    $0x8,%esp
	setvect (32, i86_pit_irq);
 1b0:	83 ec 08             	sub    $0x8,%esp
 1b3:	68 00 00 00 00       	push   $0x0
 1b8:	6a 20                	push   $0x20
 1ba:	e8 fc ff ff ff       	call   1bb <i86_pit_initialize+0x11>
 1bf:	83 c4 10             	add    $0x10,%esp

	_pit_bIsInit = 1;
 1c2:	c7 05 00 00 00 00 01 	movl   $0x1,0x0
 1c9:	00 00 00 
}
 1cc:	90                   	nop
 1cd:	c9                   	leave  
 1ce:	c3                   	ret    

000001cf <i86_pit_is_initialized>:

int i86_pit_is_initialized(){
 1cf:	55                   	push   %ebp
 1d0:	89 e5                	mov    %esp,%ebp
	return _pit_bIsInit;
 1d2:	a1 00 00 00 00       	mov    0x0,%eax
 1d7:	5d                   	pop    %ebp
 1d8:	c3                   	ret    

printf.o:     file format elf32-i386


Disassembly of section .text:

00000000 <printf>:
#include <lib/string.h>
#include <lib/stdarg.h>

#include <monitor/monitor.h>

int printf(const char* format, ...){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	81 ec 14 01 00 00    	sub    $0x114,%esp
	// Allocate a buffer
	char buf[256] = {0};
   a:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
  10:	b8 00 00 00 00       	mov    $0x0,%eax
  15:	b9 40 00 00 00       	mov    $0x40,%ecx
  1a:	89 d7                	mov    %edx,%edi
  1c:	f3 ab                	rep stos %eax,%es:(%edi)

	va_list ap;

	va_start(ap, format);
  1e:	8d 45 0c             	lea    0xc(%ebp),%eax
  21:	89 45 f4             	mov    %eax,-0xc(%ebp)

	vsprintf(buf, format, ap);
  24:	8b 45 08             	mov    0x8(%ebp),%eax
  27:	83 ec 04             	sub    $0x4,%esp
  2a:	ff 75 f4             	pushl  -0xc(%ebp)
  2d:	50                   	push   %eax
  2e:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
  34:	50                   	push   %eax
  35:	e8 fc ff ff ff       	call   36 <printf+0x36>
  3a:	83 c4 10             	add    $0x10,%esp

	monitor_puts(buf);
  3d:	83 ec 0c             	sub    $0xc,%esp
  40:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
  46:	50                   	push   %eax
  47:	e8 fc ff ff ff       	call   48 <printf+0x48>
  4c:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
  4f:	90                   	nop
  50:	8b 7d fc             	mov    -0x4(%ebp),%edi
  53:	c9                   	leave  
  54:	c3                   	ret    

putch.o:     file format elf32-i386


Disassembly of section .text:

00000000 <putch>:
#include <lib/stdio.h>

#include <monitor/monitor.h>

int putch(char c){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 18             	sub    $0x18,%esp
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	88 45 f4             	mov    %al,-0xc(%ebp)
	monitor_putch(c);
   c:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
  10:	83 ec 0c             	sub    $0xc,%esp
  13:	50                   	push   %eax
  14:	e8 fc ff ff ff       	call   15 <putch+0x15>
  19:	83 c4 10             	add    $0x10,%esp
  1c:	90                   	nop
  1d:	c9                   	leave  
  1e:	c3                   	ret    

puts.o:     file format elf32-i386


Disassembly of section .text:

00000000 <puts>:
#include <lib/stdio.h>

#include <monitor/monitor.h>

int puts(const char* s){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	monitor_puts(s);
   6:	83 ec 0c             	sub    $0xc,%esp
   9:	ff 75 08             	pushl  0x8(%ebp)
   c:	e8 fc ff ff ff       	call   d <puts+0xd>
  11:	83 c4 10             	add    $0x10,%esp
  14:	90                   	nop
  15:	c9                   	leave  
  16:	c3                   	ret    

serial.o:     file format elf32-i386


Disassembly of section .text:

00000000 <init_serial>:
	uint8_t DLAB_bit : 1;

} LineControlReg_t;

void init_serial(COM_port port, serial_baud_rate baud_rate, uint8_t data_bits, uint8_t stop_bits, serial_parity_mode parity)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
   6:	8b 55 10             	mov    0x10(%ebp),%edx
   9:	8b 45 14             	mov    0x14(%ebp),%eax
   c:	88 55 e4             	mov    %dl,-0x1c(%ebp)
   f:	88 45 e0             	mov    %al,-0x20(%ebp)

	// Determine port
	uint16_t port_base;
	switch (port)
  12:	8b 45 08             	mov    0x8(%ebp),%eax
  15:	83 f8 01             	cmp    $0x1,%eax
  18:	74 19                	je     33 <init_serial+0x33>
  1a:	83 f8 01             	cmp    $0x1,%eax
  1d:	72 0c                	jb     2b <init_serial+0x2b>
  1f:	83 f8 02             	cmp    $0x2,%eax
  22:	74 17                	je     3b <init_serial+0x3b>
  24:	83 f8 03             	cmp    $0x3,%eax
  27:	74 1a                	je     43 <init_serial+0x43>
  29:	eb 20                	jmp    4b <init_serial+0x4b>
	{
	case COM1:
		port_base = COM1_BASE;
  2b:	66 c7 45 f6 f8 03    	movw   $0x3f8,-0xa(%ebp)
		break;
  31:	eb 2d                	jmp    60 <init_serial+0x60>
	case COM2:
		port_base = COM2_BASE;
  33:	66 c7 45 f6 f8 02    	movw   $0x2f8,-0xa(%ebp)
		break;
  39:	eb 25                	jmp    60 <init_serial+0x60>
	case COM3:
		port_base = COM3_BASE;
  3b:	66 c7 45 f6 e8 03    	movw   $0x3e8,-0xa(%ebp)
		break;
  41:	eb 1d                	jmp    60 <init_serial+0x60>
	case COM4:
		port_base = COM4_BASE;
  43:	66 c7 45 f6 e8 02    	movw   $0x2e8,-0xa(%ebp)
		break;
  49:	eb 15                	jmp    60 <init_serial+0x60>
	default:
		printf("\nERROR: Invalid port");
  4b:	83 ec 0c             	sub    $0xc,%esp
  4e:	68 00 00 00 00       	push   $0x0
  53:	e8 fc ff ff ff       	call   54 <init_serial+0x54>
  58:	83 c4 10             	add    $0x10,%esp
		// ERROR: Invalid port
		return;
  5b:	e9 4c 02 00 00       	jmp    2ac <init_serial+0x2ac>
	}

	// Disable all interrupts
	outportb(SERIAL_INT_EN_REG(port_base), SERIAL_IER_DISABLE_INTS);
  60:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  64:	83 c0 01             	add    $0x1,%eax
  67:	0f b7 c0             	movzwl %ax,%eax
  6a:	83 ec 08             	sub    $0x8,%esp
  6d:	6a 00                	push   $0x0
  6f:	50                   	push   %eax
  70:	e8 fc ff ff ff       	call   71 <init_serial+0x71>
  75:	83 c4 10             	add    $0x10,%esp

	// Enable DLAB to be able to send divisor value
	outportb(SERIAL_LINE_CTRL_REG(port_base), SERIAL_LCR_DLAB_MASK);
  78:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  7c:	83 c0 03             	add    $0x3,%eax
  7f:	0f b7 c0             	movzwl %ax,%eax
  82:	83 ec 08             	sub    $0x8,%esp
  85:	68 80 00 00 00       	push   $0x80
  8a:	50                   	push   %eax
  8b:	e8 fc ff ff ff       	call   8c <init_serial+0x8c>
  90:	83 c4 10             	add    $0x10,%esp

	// Set baud rate divisor
	uint16_t baud = (uint16_t)baud_rate;
  93:	8b 45 0c             	mov    0xc(%ebp),%eax
  96:	66 89 45 f4          	mov    %ax,-0xc(%ebp)

	printf("Baud rate divisor: %x\n", baud);
  9a:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
  9e:	83 ec 08             	sub    $0x8,%esp
  a1:	50                   	push   %eax
  a2:	68 15 00 00 00       	push   $0x15
  a7:	e8 fc ff ff ff       	call   a8 <init_serial+0xa8>
  ac:	83 c4 10             	add    $0x10,%esp

	outportb(SERIAL_BAUD_RATE_LOW(port_base), baud & 0x00FF);
  af:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
  b3:	0f b6 d0             	movzbl %al,%edx
  b6:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  ba:	83 ec 08             	sub    $0x8,%esp
  bd:	52                   	push   %edx
  be:	50                   	push   %eax
  bf:	e8 fc ff ff ff       	call   c0 <init_serial+0xc0>
  c4:	83 c4 10             	add    $0x10,%esp
	outportb(SERIAL_BAUD_RATE_HIGH(port_base), (baud & 0xFF00) >> 8);
  c7:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
  cb:	66 c1 e8 08          	shr    $0x8,%ax
  cf:	0f b6 d0             	movzbl %al,%edx
  d2:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  d6:	83 c0 01             	add    $0x1,%eax
  d9:	0f b7 c0             	movzwl %ax,%eax
  dc:	83 ec 08             	sub    $0x8,%esp
  df:	52                   	push   %edx
  e0:	50                   	push   %eax
  e1:	e8 fc ff ff ff       	call   e2 <init_serial+0xe2>
  e6:	83 c4 10             	add    $0x10,%esp

	// Set line data
	LineControlReg_t line_ctrl_data;

	switch (data_bits)
  e9:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  ed:	83 f8 06             	cmp    $0x6,%eax
  f0:	74 24                	je     116 <init_serial+0x116>
  f2:	83 f8 06             	cmp    $0x6,%eax
  f5:	7f 07                	jg     fe <init_serial+0xfe>
  f7:	83 f8 05             	cmp    $0x5,%eax
  fa:	74 0e                	je     10a <init_serial+0x10a>
  fc:	eb 42                	jmp    140 <init_serial+0x140>
  fe:	83 f8 07             	cmp    $0x7,%eax
 101:	74 22                	je     125 <init_serial+0x125>
 103:	83 f8 08             	cmp    $0x8,%eax
 106:	74 2c                	je     134 <init_serial+0x134>
 108:	eb 36                	jmp    140 <init_serial+0x140>
	{
	case 5:
		line_ctrl_data.data_bits = 0;
 10a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 10e:	83 e0 fc             	and    $0xfffffffc,%eax
 111:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 114:	eb 3f                	jmp    155 <init_serial+0x155>
	case 6:
		line_ctrl_data.data_bits = 1;
 116:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 11a:	83 e0 fc             	and    $0xfffffffc,%eax
 11d:	83 c8 01             	or     $0x1,%eax
 120:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 123:	eb 30                	jmp    155 <init_serial+0x155>
	case 7:
		line_ctrl_data.data_bits = 2;
 125:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 129:	83 e0 fc             	and    $0xfffffffc,%eax
 12c:	83 c8 02             	or     $0x2,%eax
 12f:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 132:	eb 21                	jmp    155 <init_serial+0x155>
	case 8:
		line_ctrl_data.data_bits = 3;
 134:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 138:	83 c8 03             	or     $0x3,%eax
 13b:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 13e:	eb 15                	jmp    155 <init_serial+0x155>
	default:
		//ERROR, invalid settings
		printf("\nERROR: Invalid data bit setting");
 140:	83 ec 0c             	sub    $0xc,%esp
 143:	68 2c 00 00 00       	push   $0x2c
 148:	e8 fc ff ff ff       	call   149 <init_serial+0x149>
 14d:	83 c4 10             	add    $0x10,%esp
		return;
 150:	e9 57 01 00 00       	jmp    2ac <init_serial+0x2ac>
	}

	switch (stop_bits)
 155:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
 159:	83 f8 01             	cmp    $0x1,%eax
 15c:	74 07                	je     165 <init_serial+0x165>
 15e:	83 f8 02             	cmp    $0x2,%eax
 161:	74 15                	je     178 <init_serial+0x178>
 163:	eb 1d                	jmp    182 <init_serial+0x182>
	{
	case 1:
		line_ctrl_data.stop_bits = 0;
 165:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 169:	83 e0 fb             	and    $0xfffffffb,%eax
 16c:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 16f:	90                   	nop
		//ERROR, invalid settings
		printf("\nERROR: Invalid stop bit setting");
		return;
	}

	switch (parity)
 170:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
 174:	77 75                	ja     1eb <init_serial+0x1eb>
 176:	eb 1f                	jmp    197 <init_serial+0x197>
	{
	case 1:
		line_ctrl_data.stop_bits = 0;
		break;
	case 2:
		line_ctrl_data.stop_bits = 1;
 178:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 17c:	83 c8 04             	or     $0x4,%eax
 17f:	88 45 f3             	mov    %al,-0xd(%ebp)
	default:
		//ERROR, invalid settings
		printf("\nERROR: Invalid stop bit setting");
 182:	83 ec 0c             	sub    $0xc,%esp
 185:	68 50 00 00 00       	push   $0x50
 18a:	e8 fc ff ff ff       	call   18b <init_serial+0x18b>
 18f:	83 c4 10             	add    $0x10,%esp
		return;
 192:	e9 15 01 00 00       	jmp    2ac <init_serial+0x2ac>
	}

	switch (parity)
 197:	8b 45 18             	mov    0x18(%ebp),%eax
 19a:	c1 e0 02             	shl    $0x2,%eax
 19d:	05 94 00 00 00       	add    $0x94,%eax
 1a2:	8b 00                	mov    (%eax),%eax
 1a4:	ff e0                	jmp    *%eax
	{
	case SERIAL_PARITY_NONE:
		line_ctrl_data.parity_mode = 0b000;
 1a6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 1aa:	83 e0 c7             	and    $0xffffffc7,%eax
 1ad:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 1b0:	eb 4e                	jmp    200 <init_serial+0x200>
	case SERIAL_PARITY_ODD:
		line_ctrl_data.parity_mode = 0b001;
 1b2:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 1b6:	83 e0 c7             	and    $0xffffffc7,%eax
 1b9:	83 c8 08             	or     $0x8,%eax
 1bc:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 1bf:	eb 3f                	jmp    200 <init_serial+0x200>
	case SERIAL_PARITY_EVEN:
		line_ctrl_data.parity_mode = 0b011;
 1c1:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 1c5:	83 e0 c7             	and    $0xffffffc7,%eax
 1c8:	83 c8 18             	or     $0x18,%eax
 1cb:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 1ce:	eb 30                	jmp    200 <init_serial+0x200>
	case SERIAL_PARITY_MARK:
		line_ctrl_data.parity_mode = 0b101;
 1d0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 1d4:	83 e0 c7             	and    $0xffffffc7,%eax
 1d7:	83 c8 28             	or     $0x28,%eax
 1da:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 1dd:	eb 21                	jmp    200 <init_serial+0x200>
	case SERIAL_PARITY_SPACE:
		line_ctrl_data.parity_mode = 0b111;
 1df:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 1e3:	83 c8 38             	or     $0x38,%eax
 1e6:	88 45 f3             	mov    %al,-0xd(%ebp)
		break;
 1e9:	eb 15                	jmp    200 <init_serial+0x200>
	default:
		//ERROR, invalid settings
		printf("\nERROR: Invalid parity setting");
 1eb:	83 ec 0c             	sub    $0xc,%esp
 1ee:	68 74 00 00 00       	push   $0x74
 1f3:	e8 fc ff ff ff       	call   1f4 <init_serial+0x1f4>
 1f8:	83 c4 10             	add    $0x10,%esp
		return;
 1fb:	e9 ac 00 00 00       	jmp    2ac <init_serial+0x2ac>
	}

	// Disable DLAB
	line_ctrl_data.DLAB_bit = 0;
 200:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
 204:	83 e0 7f             	and    $0x7f,%eax
 207:	88 45 f3             	mov    %al,-0xd(%ebp)

	uint8_t line_ctrl_data_byte;
	
	memcpy(&line_ctrl_data_byte, &line_ctrl_data, 1);
 20a:	83 ec 04             	sub    $0x4,%esp
 20d:	6a 01                	push   $0x1
 20f:	8d 45 f3             	lea    -0xd(%ebp),%eax
 212:	50                   	push   %eax
 213:	8d 45 f2             	lea    -0xe(%ebp),%eax
 216:	50                   	push   %eax
 217:	e8 fc ff ff ff       	call   218 <init_serial+0x218>
 21c:	83 c4 10             	add    $0x10,%esp

	outportb(SERIAL_LINE_CTRL_REG(port_base), line_ctrl_data_byte);
 21f:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
 223:	0f b6 d0             	movzbl %al,%edx
 226:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 22a:	83 c0 03             	add    $0x3,%eax
 22d:	0f b7 c0             	movzwl %ax,%eax
 230:	83 ec 08             	sub    $0x8,%esp
 233:	52                   	push   %edx
 234:	50                   	push   %eax
 235:	e8 fc ff ff ff       	call   236 <init_serial+0x236>
 23a:	83 c4 10             	add    $0x10,%esp

	// Enable FIFO, clear, 14 byte threshold
	outportb(SERIAL_INT_ID_FIFO_CTRL_REG(port_base), SERIAL_IIR_FIFO_ENABLED | SERIAL_IIR_LINE_STATUS_INT | SERIAL_IIR_INT_PENDING_MASK);
 23d:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 241:	83 c0 02             	add    $0x2,%eax
 244:	0f b7 c0             	movzwl %ax,%eax
 247:	83 ec 08             	sub    $0x8,%esp
 24a:	68 c7 00 00 00       	push   $0xc7
 24f:	50                   	push   %eax
 250:	e8 fc ff ff ff       	call   251 <init_serial+0x251>
 255:	83 c4 10             	add    $0x10,%esp

	// IRQ enabled RTS/DSR set
	outportb(SERIAL_MODEM_CTRL_REG(port_base), SERIAL_MCR_DATA_TERMINAL_READY_MASK | SERIAL_MCR_REQUEST_TO_SEND_MASK | SERIAL_MCR_INT_ENABLE_MASK);
 258:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 25c:	83 c0 04             	add    $0x4,%eax
 25f:	0f b7 c0             	movzwl %ax,%eax
 262:	83 ec 08             	sub    $0x8,%esp
 265:	6a 0b                	push   $0xb
 267:	50                   	push   %eax
 268:	e8 fc ff ff ff       	call   269 <init_serial+0x269>
 26d:	83 c4 10             	add    $0x10,%esp

	switch (port)
 270:	8b 45 08             	mov    0x8(%ebp),%eax
 273:	83 f8 01             	cmp    $0x1,%eax
 276:	74 1a                	je     292 <init_serial+0x292>
 278:	83 f8 01             	cmp    $0x1,%eax
 27b:	72 0c                	jb     289 <init_serial+0x289>
 27d:	83 f8 02             	cmp    $0x2,%eax
 280:	74 19                	je     29b <init_serial+0x29b>
 282:	83 f8 03             	cmp    $0x3,%eax
 285:	74 1d                	je     2a4 <init_serial+0x2a4>
		_COM4_initiated = 1;
		break;
	default:
		// ERROR: Invalid port
		// Should not happen
		return;
 287:	eb 23                	jmp    2ac <init_serial+0x2ac>
	outportb(SERIAL_MODEM_CTRL_REG(port_base), SERIAL_MCR_DATA_TERMINAL_READY_MASK | SERIAL_MCR_REQUEST_TO_SEND_MASK | SERIAL_MCR_INT_ENABLE_MASK);

	switch (port)
	{
	case COM1:
		_COM1_initiated = 1;
 289:	c6 05 00 00 00 00 01 	movb   $0x1,0x0
		break;
 290:	eb 1a                	jmp    2ac <init_serial+0x2ac>
	case COM2:
		_COM2_initiated = 1;
 292:	c6 05 01 00 00 00 01 	movb   $0x1,0x1
		break;
 299:	eb 11                	jmp    2ac <init_serial+0x2ac>
	case COM3:
		_COM3_initiated = 1;
 29b:	c6 05 02 00 00 00 01 	movb   $0x1,0x2
		break;
 2a2:	eb 08                	jmp    2ac <init_serial+0x2ac>
	case COM4:
		_COM4_initiated = 1;
 2a4:	c6 05 03 00 00 00 01 	movb   $0x1,0x3
		break;
 2ab:	90                   	nop
	default:
		// ERROR: Invalid port
		// Should not happen
		return;
	}
}
 2ac:	c9                   	leave  
 2ad:	c3                   	ret    

000002ae <serial_recieved>:

int serial_recieved(COM_port port)
{
 2ae:	55                   	push   %ebp
 2af:	89 e5                	mov    %esp,%ebp
 2b1:	83 ec 08             	sub    $0x8,%esp
	switch (port)
 2b4:	8b 45 08             	mov    0x8(%ebp),%eax
 2b7:	83 f8 01             	cmp    $0x1,%eax
 2ba:	74 29                	je     2e5 <serial_recieved+0x37>
 2bc:	83 f8 01             	cmp    $0x1,%eax
 2bf:	72 0c                	jb     2cd <serial_recieved+0x1f>
 2c1:	83 f8 02             	cmp    $0x2,%eax
 2c4:	74 37                	je     2fd <serial_recieved+0x4f>
 2c6:	83 f8 03             	cmp    $0x3,%eax
 2c9:	74 4a                	je     315 <serial_recieved+0x67>
 2cb:	eb 60                	jmp    32d <serial_recieved+0x7f>
	{
	case COM1:
		return (inportb(SERIAL_LINE_STATUS_REG(COM1_BASE)) & SERIAL_LSR_DATA_AVAILABLE_MASK);
 2cd:	83 ec 0c             	sub    $0xc,%esp
 2d0:	68 fd 03 00 00       	push   $0x3fd
 2d5:	e8 fc ff ff ff       	call   2d6 <serial_recieved+0x28>
 2da:	83 c4 10             	add    $0x10,%esp
 2dd:	0f b6 c0             	movzbl %al,%eax
 2e0:	83 e0 01             	and    $0x1,%eax
 2e3:	eb 4d                	jmp    332 <serial_recieved+0x84>
	case COM2:
		return (inportb(SERIAL_LINE_STATUS_REG(COM2_BASE)) & SERIAL_LSR_DATA_AVAILABLE_MASK);
 2e5:	83 ec 0c             	sub    $0xc,%esp
 2e8:	68 fd 02 00 00       	push   $0x2fd
 2ed:	e8 fc ff ff ff       	call   2ee <serial_recieved+0x40>
 2f2:	83 c4 10             	add    $0x10,%esp
 2f5:	0f b6 c0             	movzbl %al,%eax
 2f8:	83 e0 01             	and    $0x1,%eax
 2fb:	eb 35                	jmp    332 <serial_recieved+0x84>
	case COM3:
		return (inportb(SERIAL_LINE_STATUS_REG(COM3_BASE)) & SERIAL_LSR_DATA_AVAILABLE_MASK);
 2fd:	83 ec 0c             	sub    $0xc,%esp
 300:	68 ed 03 00 00       	push   $0x3ed
 305:	e8 fc ff ff ff       	call   306 <serial_recieved+0x58>
 30a:	83 c4 10             	add    $0x10,%esp
 30d:	0f b6 c0             	movzbl %al,%eax
 310:	83 e0 01             	and    $0x1,%eax
 313:	eb 1d                	jmp    332 <serial_recieved+0x84>
	case COM4:
		return (inportb(SERIAL_LINE_STATUS_REG(COM4_BASE)) & SERIAL_LSR_DATA_AVAILABLE_MASK);
 315:	83 ec 0c             	sub    $0xc,%esp
 318:	68 ed 02 00 00       	push   $0x2ed
 31d:	e8 fc ff ff ff       	call   31e <serial_recieved+0x70>
 322:	83 c4 10             	add    $0x10,%esp
 325:	0f b6 c0             	movzbl %al,%eax
 328:	83 e0 01             	and    $0x1,%eax
 32b:	eb 05                	jmp    332 <serial_recieved+0x84>
	default:
		// ERROR: Invalid port
		return 1;
 32d:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
 332:	c9                   	leave  
 333:	c3                   	ret    

00000334 <serial_recieve_data>:

char serial_recieve_data(COM_port port)
{
 334:	55                   	push   %ebp
 335:	89 e5                	mov    %esp,%ebp
 337:	83 ec 08             	sub    $0x8,%esp
	// TODO check if initiated
	while (!serial_recieved(port));
 33a:	90                   	nop
 33b:	83 ec 0c             	sub    $0xc,%esp
 33e:	ff 75 08             	pushl  0x8(%ebp)
 341:	e8 fc ff ff ff       	call   342 <serial_recieve_data+0xe>
 346:	83 c4 10             	add    $0x10,%esp
 349:	85 c0                	test   %eax,%eax
 34b:	74 ee                	je     33b <serial_recieve_data+0x7>

	switch (port)
 34d:	8b 45 08             	mov    0x8(%ebp),%eax
 350:	83 f8 01             	cmp    $0x1,%eax
 353:	74 23                	je     378 <serial_recieve_data+0x44>
 355:	83 f8 01             	cmp    $0x1,%eax
 358:	72 0c                	jb     366 <serial_recieve_data+0x32>
 35a:	83 f8 02             	cmp    $0x2,%eax
 35d:	74 2b                	je     38a <serial_recieve_data+0x56>
 35f:	83 f8 03             	cmp    $0x3,%eax
 362:	74 38                	je     39c <serial_recieve_data+0x68>
 364:	eb 48                	jmp    3ae <serial_recieve_data+0x7a>
	{
	case COM1:
		return (inportb(SERIAL_DATA_REG(COM1_BASE)));
 366:	83 ec 0c             	sub    $0xc,%esp
 369:	68 f8 03 00 00       	push   $0x3f8
 36e:	e8 fc ff ff ff       	call   36f <serial_recieve_data+0x3b>
 373:	83 c4 10             	add    $0x10,%esp
 376:	eb 3b                	jmp    3b3 <serial_recieve_data+0x7f>
	case COM2:
		return (inportb(SERIAL_DATA_REG(COM2_BASE)));
 378:	83 ec 0c             	sub    $0xc,%esp
 37b:	68 f8 02 00 00       	push   $0x2f8
 380:	e8 fc ff ff ff       	call   381 <serial_recieve_data+0x4d>
 385:	83 c4 10             	add    $0x10,%esp
 388:	eb 29                	jmp    3b3 <serial_recieve_data+0x7f>
	case COM3:
		return (inportb(SERIAL_DATA_REG(COM3_BASE)));
 38a:	83 ec 0c             	sub    $0xc,%esp
 38d:	68 e8 03 00 00       	push   $0x3e8
 392:	e8 fc ff ff ff       	call   393 <serial_recieve_data+0x5f>
 397:	83 c4 10             	add    $0x10,%esp
 39a:	eb 17                	jmp    3b3 <serial_recieve_data+0x7f>
	case COM4:
		return (inportb(SERIAL_DATA_REG(COM4_BASE)));
 39c:	83 ec 0c             	sub    $0xc,%esp
 39f:	68 e8 02 00 00       	push   $0x2e8
 3a4:	e8 fc ff ff ff       	call   3a5 <serial_recieve_data+0x71>
 3a9:	83 c4 10             	add    $0x10,%esp
 3ac:	eb 05                	jmp    3b3 <serial_recieve_data+0x7f>
	default:
		// ERROR: Invalid port
		return 0;
 3ae:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
 3b3:	c9                   	leave  
 3b4:	c3                   	ret    

000003b5 <serial_is_transmit_ready>:

int serial_is_transmit_ready(COM_port port)
{
 3b5:	55                   	push   %ebp
 3b6:	89 e5                	mov    %esp,%ebp
 3b8:	83 ec 08             	sub    $0x8,%esp
	switch (port)
 3bb:	8b 45 08             	mov    0x8(%ebp),%eax
 3be:	83 f8 01             	cmp    $0x1,%eax
 3c1:	74 29                	je     3ec <serial_is_transmit_ready+0x37>
 3c3:	83 f8 01             	cmp    $0x1,%eax
 3c6:	72 0c                	jb     3d4 <serial_is_transmit_ready+0x1f>
 3c8:	83 f8 02             	cmp    $0x2,%eax
 3cb:	74 37                	je     404 <serial_is_transmit_ready+0x4f>
 3cd:	83 f8 03             	cmp    $0x3,%eax
 3d0:	74 4a                	je     41c <serial_is_transmit_ready+0x67>
 3d2:	eb 60                	jmp    434 <serial_is_transmit_ready+0x7f>
	{
	case COM1:
		return (inportb(SERIAL_LINE_STATUS_REG(COM1_BASE)) & SERIAL_LSR_TRANSMIT_READY_MASK);
 3d4:	83 ec 0c             	sub    $0xc,%esp
 3d7:	68 fd 03 00 00       	push   $0x3fd
 3dc:	e8 fc ff ff ff       	call   3dd <serial_is_transmit_ready+0x28>
 3e1:	83 c4 10             	add    $0x10,%esp
 3e4:	0f b6 c0             	movzbl %al,%eax
 3e7:	83 e0 20             	and    $0x20,%eax
 3ea:	eb 4d                	jmp    439 <serial_is_transmit_ready+0x84>
	case COM2:
		return (inportb(SERIAL_LINE_STATUS_REG(COM2_BASE)) & SERIAL_LSR_TRANSMIT_READY_MASK);
 3ec:	83 ec 0c             	sub    $0xc,%esp
 3ef:	68 fd 02 00 00       	push   $0x2fd
 3f4:	e8 fc ff ff ff       	call   3f5 <serial_is_transmit_ready+0x40>
 3f9:	83 c4 10             	add    $0x10,%esp
 3fc:	0f b6 c0             	movzbl %al,%eax
 3ff:	83 e0 20             	and    $0x20,%eax
 402:	eb 35                	jmp    439 <serial_is_transmit_ready+0x84>
	case COM3:
		return (inportb(SERIAL_LINE_STATUS_REG(COM3_BASE)) & SERIAL_LSR_TRANSMIT_READY_MASK);
 404:	83 ec 0c             	sub    $0xc,%esp
 407:	68 ed 03 00 00       	push   $0x3ed
 40c:	e8 fc ff ff ff       	call   40d <serial_is_transmit_ready+0x58>
 411:	83 c4 10             	add    $0x10,%esp
 414:	0f b6 c0             	movzbl %al,%eax
 417:	83 e0 20             	and    $0x20,%eax
 41a:	eb 1d                	jmp    439 <serial_is_transmit_ready+0x84>
	case COM4:
		return (inportb(SERIAL_LINE_STATUS_REG(COM4_BASE)) & SERIAL_LSR_TRANSMIT_READY_MASK);
 41c:	83 ec 0c             	sub    $0xc,%esp
 41f:	68 ed 02 00 00       	push   $0x2ed
 424:	e8 fc ff ff ff       	call   425 <serial_is_transmit_ready+0x70>
 429:	83 c4 10             	add    $0x10,%esp
 42c:	0f b6 c0             	movzbl %al,%eax
 42f:	83 e0 20             	and    $0x20,%eax
 432:	eb 05                	jmp    439 <serial_is_transmit_ready+0x84>
	default:
		// ERROR: Invalid port
		return 1;
 434:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
 439:	c9                   	leave  
 43a:	c3                   	ret    

0000043b <serial_send_data>:

void serial_send_data(COM_port port, char data)
{
 43b:	55                   	push   %ebp
 43c:	89 e5                	mov    %esp,%ebp
 43e:	83 ec 18             	sub    $0x18,%esp
 441:	8b 45 0c             	mov    0xc(%ebp),%eax
 444:	88 45 f4             	mov    %al,-0xc(%ebp)
	// TODO check if initiated

	while (!serial_is_transmit_ready(port));
 447:	90                   	nop
 448:	83 ec 0c             	sub    $0xc,%esp
 44b:	ff 75 08             	pushl  0x8(%ebp)
 44e:	e8 fc ff ff ff       	call   44f <serial_send_data+0x14>
 453:	83 c4 10             	add    $0x10,%esp
 456:	85 c0                	test   %eax,%eax
 458:	74 ee                	je     448 <serial_send_data+0xd>

	switch (port)
 45a:	8b 45 08             	mov    0x8(%ebp),%eax
 45d:	83 f8 01             	cmp    $0x1,%eax
 460:	74 29                	je     48b <serial_send_data+0x50>
 462:	83 f8 01             	cmp    $0x1,%eax
 465:	72 0c                	jb     473 <serial_send_data+0x38>
 467:	83 f8 02             	cmp    $0x2,%eax
 46a:	74 37                	je     4a3 <serial_send_data+0x68>
 46c:	83 f8 03             	cmp    $0x3,%eax
 46f:	74 4a                	je     4bb <serial_send_data+0x80>
		outportb(SERIAL_DATA_REG(COM3_BASE), data);
	case COM4:
		outportb(SERIAL_DATA_REG(COM4_BASE), data);
	default:
		// ERROR: Invalid port
		return;
 471:	eb 61                	jmp    4d4 <serial_send_data+0x99>
	while (!serial_is_transmit_ready(port));

	switch (port)
	{
	case COM1:
		outportb(SERIAL_DATA_REG(COM1_BASE), data);
 473:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 477:	0f b6 c0             	movzbl %al,%eax
 47a:	83 ec 08             	sub    $0x8,%esp
 47d:	50                   	push   %eax
 47e:	68 f8 03 00 00       	push   $0x3f8
 483:	e8 fc ff ff ff       	call   484 <serial_send_data+0x49>
 488:	83 c4 10             	add    $0x10,%esp
	case COM2:
		outportb(SERIAL_DATA_REG(COM2_BASE), data);
 48b:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 48f:	0f b6 c0             	movzbl %al,%eax
 492:	83 ec 08             	sub    $0x8,%esp
 495:	50                   	push   %eax
 496:	68 f8 02 00 00       	push   $0x2f8
 49b:	e8 fc ff ff ff       	call   49c <serial_send_data+0x61>
 4a0:	83 c4 10             	add    $0x10,%esp
	case COM3:
		outportb(SERIAL_DATA_REG(COM3_BASE), data);
 4a3:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 4a7:	0f b6 c0             	movzbl %al,%eax
 4aa:	83 ec 08             	sub    $0x8,%esp
 4ad:	50                   	push   %eax
 4ae:	68 e8 03 00 00       	push   $0x3e8
 4b3:	e8 fc ff ff ff       	call   4b4 <serial_send_data+0x79>
 4b8:	83 c4 10             	add    $0x10,%esp
	case COM4:
		outportb(SERIAL_DATA_REG(COM4_BASE), data);
 4bb:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 4bf:	0f b6 c0             	movzbl %al,%eax
 4c2:	83 ec 08             	sub    $0x8,%esp
 4c5:	50                   	push   %eax
 4c6:	68 e8 02 00 00       	push   $0x2e8
 4cb:	e8 fc ff ff ff       	call   4cc <serial_send_data+0x91>
 4d0:	83 c4 10             	add    $0x10,%esp
	default:
		// ERROR: Invalid port
		return;
 4d3:	90                   	nop
	}
 4d4:	c9                   	leave  
 4d5:	c3                   	ret    

serial_printf.o:     file format elf32-i386


Disassembly of section .text:

00000000 <serial_printf>:
#include <lib/stdio.h>

#include <lib/string.h>
#include <lib/stdarg.h>

int serial_printf(COM_port port, const char* format, ...){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	81 ec 14 01 00 00    	sub    $0x114,%esp
	// Allocate a buffer
	char buf[256] = {0};
   a:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
  10:	b8 00 00 00 00       	mov    $0x0,%eax
  15:	b9 40 00 00 00       	mov    $0x40,%ecx
  1a:	89 d7                	mov    %edx,%edi
  1c:	f3 ab                	rep stos %eax,%es:(%edi)

	va_list ap;

	va_start(ap, format);
  1e:	8d 45 0c             	lea    0xc(%ebp),%eax
  21:	83 c0 04             	add    $0x4,%eax
  24:	89 45 f4             	mov    %eax,-0xc(%ebp)

	vsprintf(buf, format, ap);
  27:	8b 45 0c             	mov    0xc(%ebp),%eax
  2a:	83 ec 04             	sub    $0x4,%esp
  2d:	ff 75 f4             	pushl  -0xc(%ebp)
  30:	50                   	push   %eax
  31:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
  37:	50                   	push   %eax
  38:	e8 fc ff ff ff       	call   39 <serial_printf+0x39>
  3d:	83 c4 10             	add    $0x10,%esp

	serial_puts(port, buf);
  40:	83 ec 08             	sub    $0x8,%esp
  43:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
  49:	50                   	push   %eax
  4a:	ff 75 08             	pushl  0x8(%ebp)
  4d:	e8 fc ff ff ff       	call   4e <serial_printf+0x4e>
  52:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
  55:	90                   	nop
  56:	8b 7d fc             	mov    -0x4(%ebp),%edi
  59:	c9                   	leave  
  5a:	c3                   	ret    

serial_putch.o:     file format elf32-i386


Disassembly of section .text:

00000000 <serial_putch>:
#include <lib/stdio.h>

void serial_putch(COM_port port, const char c)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 18             	sub    $0x18,%esp
   6:	8b 45 0c             	mov    0xc(%ebp),%eax
   9:	88 45 f4             	mov    %al,-0xc(%ebp)
	if (!c)
   c:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
  10:	74 15                	je     27 <serial_putch+0x27>
		return;
	serial_send_data(port, c);
  12:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
  16:	83 ec 08             	sub    $0x8,%esp
  19:	50                   	push   %eax
  1a:	ff 75 08             	pushl  0x8(%ebp)
  1d:	e8 fc ff ff ff       	call   1e <serial_putch+0x1e>
  22:	83 c4 10             	add    $0x10,%esp
  25:	eb 01                	jmp    28 <serial_putch+0x28>
#include <lib/stdio.h>

void serial_putch(COM_port port, const char c)
{
	if (!c)
		return;
  27:	90                   	nop
	serial_send_data(port, c);
  28:	c9                   	leave  
  29:	c3                   	ret    

serial_puts.o:     file format elf32-i386


Disassembly of section .text:

00000000 <serial_puts>:
#include <lib/stdio.h>

#include <lib/string.h>

void serial_puts(COM_port port, const char* str)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 18             	sub    $0x18,%esp
	if (!str)
   6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   a:	74 3f                	je     4b <serial_puts+0x4b>
		return;

	for (size_t i = 0; i < strlen(str); i++)
   c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  13:	eb 21                	jmp    36 <serial_puts+0x36>
		serial_putch(port, str[i]);
  15:	8b 55 0c             	mov    0xc(%ebp),%edx
  18:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1b:	01 d0                	add    %edx,%eax
  1d:	0f b6 00             	movzbl (%eax),%eax
  20:	0f be c0             	movsbl %al,%eax
  23:	83 ec 08             	sub    $0x8,%esp
  26:	50                   	push   %eax
  27:	ff 75 08             	pushl  0x8(%ebp)
  2a:	e8 fc ff ff ff       	call   2b <serial_puts+0x2b>
  2f:	83 c4 10             	add    $0x10,%esp
void serial_puts(COM_port port, const char* str)
{
	if (!str)
		return;

	for (size_t i = 0; i < strlen(str); i++)
  32:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  36:	83 ec 0c             	sub    $0xc,%esp
  39:	ff 75 0c             	pushl  0xc(%ebp)
  3c:	e8 fc ff ff ff       	call   3d <serial_puts+0x3d>
  41:	83 c4 10             	add    $0x10,%esp
  44:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  47:	77 cc                	ja     15 <serial_puts+0x15>
  49:	eb 01                	jmp    4c <serial_puts+0x4c>
#include <lib/string.h>

void serial_puts(COM_port port, const char* str)
{
	if (!str)
		return;
  4b:	90                   	nop

	for (size_t i = 0; i < strlen(str); i++)
		serial_putch(port, str[i]);
  4c:	c9                   	leave  
  4d:	c3                   	ret    

setCursor.o:     file format elf32-i386


Disassembly of section .text:

00000000 <setCursor>:
#include <lib/stdio.h>

void setCursor(uint32_t x, uint32_t y){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	monitor_setCursor(x,y);
   6:	83 ec 08             	sub    $0x8,%esp
   9:	ff 75 0c             	pushl  0xc(%ebp)
   c:	ff 75 08             	pushl  0x8(%ebp)
   f:	e8 fc ff ff ff       	call   10 <setCursor+0x10>
  14:	83 c4 10             	add    $0x10,%esp
  17:	90                   	nop
  18:	c9                   	leave  
  19:	c3                   	ret    

strcat.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strcat>:
#include <lib/string.h>

char* strcat(char* dest, const char* src){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	// Copy source string to the end of the existing dest string
	strcpy(dest + strlen(dest), src);
   6:	83 ec 0c             	sub    $0xc,%esp
   9:	ff 75 08             	pushl  0x8(%ebp)
   c:	e8 fc ff ff ff       	call   d <strcat+0xd>
  11:	83 c4 10             	add    $0x10,%esp
  14:	89 c2                	mov    %eax,%edx
  16:	8b 45 08             	mov    0x8(%ebp),%eax
  19:	01 d0                	add    %edx,%eax
  1b:	83 ec 08             	sub    $0x8,%esp
  1e:	ff 75 0c             	pushl  0xc(%ebp)
  21:	50                   	push   %eax
  22:	e8 fc ff ff ff       	call   23 <strcat+0x23>
  27:	83 c4 10             	add    $0x10,%esp
	return dest;
  2a:	8b 45 08             	mov    0x8(%ebp),%eax
  2d:	c9                   	leave  
  2e:	c3                   	ret    

strchr.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strchr>:
#include <lib/string.h>

char* strchr(const char* str, char c){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 04             	sub    $0x4,%esp
   6:	8b 45 0c             	mov    0xc(%ebp),%eax
   9:	88 45 fc             	mov    %al,-0x4(%ebp)

	do{
		if(*str == c)
   c:	8b 45 08             	mov    0x8(%ebp),%eax
   f:	0f b6 00             	movzbl (%eax),%eax
  12:	3a 45 fc             	cmp    -0x4(%ebp),%al
  15:	75 05                	jne    1c <strchr+0x1c>
			return (char*) str;
  17:	8b 45 08             	mov    0x8(%ebp),%eax
  1a:	eb 15                	jmp    31 <strchr+0x31>
	} while(*str++);
  1c:	8b 45 08             	mov    0x8(%ebp),%eax
  1f:	8d 50 01             	lea    0x1(%eax),%edx
  22:	89 55 08             	mov    %edx,0x8(%ebp)
  25:	0f b6 00             	movzbl (%eax),%eax
  28:	84 c0                	test   %al,%al
  2a:	75 e0                	jne    c <strchr+0xc>

	return 0;
  2c:	b8 00 00 00 00       	mov    $0x0,%eax
  31:	c9                   	leave  
  32:	c3                   	ret    

strcicmp.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strcicmp>:
#include <lib/string.h>

int strcicmp(const char* str1, const char* str2){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	53                   	push   %ebx
	while((*str1) && (tolower(*str1++) == tolower(*str2++)));
   4:	90                   	nop
   5:	8b 45 08             	mov    0x8(%ebp),%eax
   8:	0f b6 00             	movzbl (%eax),%eax
   b:	84 c0                	test   %al,%al
   d:	0f 84 89 00 00 00    	je     9c <strcicmp+0x9c>
  13:	8b 45 08             	mov    0x8(%ebp),%eax
  16:	8d 50 01             	lea    0x1(%eax),%edx
  19:	89 55 08             	mov    %edx,0x8(%ebp)
  1c:	0f b6 00             	movzbl (%eax),%eax
  1f:	0f be c8             	movsbl %al,%ecx
  22:	8b 45 08             	mov    0x8(%ebp),%eax
  25:	8d 50 01             	lea    0x1(%eax),%edx
  28:	89 55 08             	mov    %edx,0x8(%ebp)
  2b:	0f b6 00             	movzbl (%eax),%eax
  2e:	3c 40                	cmp    $0x40,%al
  30:	7e 17                	jle    49 <strcicmp+0x49>
  32:	8b 45 08             	mov    0x8(%ebp),%eax
  35:	8d 50 01             	lea    0x1(%eax),%edx
  38:	89 55 08             	mov    %edx,0x8(%ebp)
  3b:	0f b6 00             	movzbl (%eax),%eax
  3e:	3c 5a                	cmp    $0x5a,%al
  40:	7f 07                	jg     49 <strcicmp+0x49>
  42:	b8 01 00 00 00       	mov    $0x1,%eax
  47:	eb 05                	jmp    4e <strcicmp+0x4e>
  49:	b8 00 00 00 00       	mov    $0x0,%eax
  4e:	c1 e0 05             	shl    $0x5,%eax
  51:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  54:	8b 45 0c             	mov    0xc(%ebp),%eax
  57:	8d 50 01             	lea    0x1(%eax),%edx
  5a:	89 55 0c             	mov    %edx,0xc(%ebp)
  5d:	0f b6 00             	movzbl (%eax),%eax
  60:	0f be c8             	movsbl %al,%ecx
  63:	8b 45 0c             	mov    0xc(%ebp),%eax
  66:	8d 50 01             	lea    0x1(%eax),%edx
  69:	89 55 0c             	mov    %edx,0xc(%ebp)
  6c:	0f b6 00             	movzbl (%eax),%eax
  6f:	3c 40                	cmp    $0x40,%al
  71:	7e 17                	jle    8a <strcicmp+0x8a>
  73:	8b 45 0c             	mov    0xc(%ebp),%eax
  76:	8d 50 01             	lea    0x1(%eax),%edx
  79:	89 55 0c             	mov    %edx,0xc(%ebp)
  7c:	0f b6 00             	movzbl (%eax),%eax
  7f:	3c 5a                	cmp    $0x5a,%al
  81:	7f 07                	jg     8a <strcicmp+0x8a>
  83:	b8 01 00 00 00       	mov    $0x1,%eax
  88:	eb 05                	jmp    8f <strcicmp+0x8f>
  8a:	b8 00 00 00 00       	mov    $0x0,%eax
  8f:	c1 e0 05             	shl    $0x5,%eax
  92:	01 c8                	add    %ecx,%eax
  94:	39 c3                	cmp    %eax,%ebx
  96:	0f 84 69 ff ff ff    	je     5 <strcicmp+0x5>
	return (tolower(*str1) - tolower(*str2));
  9c:	8b 45 08             	mov    0x8(%ebp),%eax
  9f:	0f b6 00             	movzbl (%eax),%eax
  a2:	0f be d0             	movsbl %al,%edx
  a5:	8b 45 08             	mov    0x8(%ebp),%eax
  a8:	0f b6 00             	movzbl (%eax),%eax
  ab:	3c 40                	cmp    $0x40,%al
  ad:	7e 11                	jle    c0 <strcicmp+0xc0>
  af:	8b 45 08             	mov    0x8(%ebp),%eax
  b2:	0f b6 00             	movzbl (%eax),%eax
  b5:	3c 5a                	cmp    $0x5a,%al
  b7:	7f 07                	jg     c0 <strcicmp+0xc0>
  b9:	b8 01 00 00 00       	mov    $0x1,%eax
  be:	eb 05                	jmp    c5 <strcicmp+0xc5>
  c0:	b8 00 00 00 00       	mov    $0x0,%eax
  c5:	c1 e0 05             	shl    $0x5,%eax
  c8:	01 c2                	add    %eax,%edx
  ca:	8b 45 0c             	mov    0xc(%ebp),%eax
  cd:	0f b6 00             	movzbl (%eax),%eax
  d0:	3c 40                	cmp    $0x40,%al
  d2:	7e 11                	jle    e5 <strcicmp+0xe5>
  d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  d7:	0f b6 00             	movzbl (%eax),%eax
  da:	3c 5a                	cmp    $0x5a,%al
  dc:	7f 07                	jg     e5 <strcicmp+0xe5>
  de:	b9 01 00 00 00       	mov    $0x1,%ecx
  e3:	eb 05                	jmp    ea <strcicmp+0xea>
  e5:	b9 00 00 00 00       	mov    $0x0,%ecx
  ea:	b8 00 00 00 00       	mov    $0x0,%eax
  ef:	29 c8                	sub    %ecx,%eax
  f1:	c1 e0 05             	shl    $0x5,%eax
  f4:	89 c1                	mov    %eax,%ecx
  f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  f9:	0f b6 00             	movzbl (%eax),%eax
  fc:	0f be c0             	movsbl %al,%eax
  ff:	29 c1                	sub    %eax,%ecx
 101:	89 c8                	mov    %ecx,%eax
 103:	01 d0                	add    %edx,%eax
 105:	5b                   	pop    %ebx
 106:	5d                   	pop    %ebp
 107:	c3                   	ret    

strcmp.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strcmp>:
#include <lib/string.h>

int strcmp (const char* str1, const char* str2) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp

	int res=0;
   6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (!(res = *(unsigned char*)str1 - *(unsigned char*)str2) && *str2)
   d:	eb 08                	jmp    17 <strcmp+0x17>
		++str1, ++str2;
   f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  13:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
#include <lib/string.h>

int strcmp (const char* str1, const char* str2) {

	int res=0;
	while (!(res = *(unsigned char*)str1 - *(unsigned char*)str2) && *str2)
  17:	8b 45 08             	mov    0x8(%ebp),%eax
  1a:	0f b6 00             	movzbl (%eax),%eax
  1d:	0f b6 d0             	movzbl %al,%edx
  20:	8b 45 0c             	mov    0xc(%ebp),%eax
  23:	0f b6 00             	movzbl (%eax),%eax
  26:	0f b6 c0             	movzbl %al,%eax
  29:	29 c2                	sub    %eax,%edx
  2b:	89 d0                	mov    %edx,%eax
  2d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  30:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  34:	75 0a                	jne    40 <strcmp+0x40>
  36:	8b 45 0c             	mov    0xc(%ebp),%eax
  39:	0f b6 00             	movzbl (%eax),%eax
  3c:	84 c0                	test   %al,%al
  3e:	75 cf                	jne    f <strcmp+0xf>
		++str1, ++str2;

	if (res < 0)
  40:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  44:	79 07                	jns    4d <strcmp+0x4d>
		res = -1;
  46:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
	if (res > 0)
  4d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  51:	7e 07                	jle    5a <strcmp+0x5a>
		res = 1;
  53:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	return res;
  5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  5d:	c9                   	leave  
  5e:	c3                   	ret    

strcpy.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strcpy>:
#include <lib/string.h>

char* strcpy(char* s1, const char* s2){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
	char* s1_p = s1;
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while(*s1++ = *s2++);
   c:	90                   	nop
   d:	8b 45 08             	mov    0x8(%ebp),%eax
  10:	8d 50 01             	lea    0x1(%eax),%edx
  13:	89 55 08             	mov    %edx,0x8(%ebp)
  16:	8b 55 0c             	mov    0xc(%ebp),%edx
  19:	8d 4a 01             	lea    0x1(%edx),%ecx
  1c:	89 4d 0c             	mov    %ecx,0xc(%ebp)
  1f:	0f b6 12             	movzbl (%edx),%edx
  22:	88 10                	mov    %dl,(%eax)
  24:	0f b6 00             	movzbl (%eax),%eax
  27:	84 c0                	test   %al,%al
  29:	75 e2                	jne    d <strcpy+0xd>
	return s1_p;
  2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2e:	c9                   	leave  
  2f:	c3                   	ret    

strlen.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strlen>:
#include <lib/string.h>

size_t strlen(const char* str){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
	size_t len = 0;
   6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while(str[len])
   d:	eb 04                	jmp    13 <strlen+0x13>
		++len;
   f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
#include <lib/string.h>

size_t strlen(const char* str){
	size_t len = 0;
	while(str[len])
  13:	8b 55 08             	mov    0x8(%ebp),%edx
  16:	8b 45 fc             	mov    -0x4(%ebp),%eax
  19:	01 d0                	add    %edx,%eax
  1b:	0f b6 00             	movzbl (%eax),%eax
  1e:	84 c0                	test   %al,%al
  20:	75 ed                	jne    f <strlen+0xf>
		++len;
	return len;
  22:	8b 45 fc             	mov    -0x4(%ebp),%eax
  25:	c9                   	leave  
  26:	c3                   	ret    

strncat.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strncat>:
#include <lib/string.h>

char* strncat(char* dest, const char* src, size_t n){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
	strncpy(dest + strlen(dest), src, n);
   6:	83 ec 0c             	sub    $0xc,%esp
   9:	ff 75 08             	pushl  0x8(%ebp)
   c:	e8 fc ff ff ff       	call   d <strncat+0xd>
  11:	83 c4 10             	add    $0x10,%esp
  14:	89 c2                	mov    %eax,%edx
  16:	8b 45 08             	mov    0x8(%ebp),%eax
  19:	01 d0                	add    %edx,%eax
  1b:	83 ec 04             	sub    $0x4,%esp
  1e:	ff 75 10             	pushl  0x10(%ebp)
  21:	ff 75 0c             	pushl  0xc(%ebp)
  24:	50                   	push   %eax
  25:	e8 fc ff ff ff       	call   26 <strncat+0x26>
  2a:	83 c4 10             	add    $0x10,%esp
	return dest;
  2d:	8b 45 08             	mov    0x8(%ebp),%eax
  30:	c9                   	leave  
  31:	c3                   	ret    

strncicmp.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strncicmp>:
#include <lib/string.h>

int strncicmp(const char* str1, const char* str2, size_t n){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	53                   	push   %ebx

	// Sanity check
	if(n == 0) 
   4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   8:	75 0e                	jne    18 <strncicmp+0x18>
		return 0;
   a:	b8 00 00 00 00       	mov    $0x0,%eax
   f:	e9 0e 01 00 00       	jmp    122 <strncicmp+0x122>

	for(;*str1 && (n > 1) && (tolower(*str1++) == tolower(*str2++));--n);
  14:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  18:	8b 45 08             	mov    0x8(%ebp),%eax
  1b:	0f b6 00             	movzbl (%eax),%eax
  1e:	84 c0                	test   %al,%al
  20:	0f 84 93 00 00 00    	je     b9 <strncicmp+0xb9>
  26:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  2a:	0f 86 89 00 00 00    	jbe    b9 <strncicmp+0xb9>
  30:	8b 45 08             	mov    0x8(%ebp),%eax
  33:	8d 50 01             	lea    0x1(%eax),%edx
  36:	89 55 08             	mov    %edx,0x8(%ebp)
  39:	0f b6 00             	movzbl (%eax),%eax
  3c:	0f be c8             	movsbl %al,%ecx
  3f:	8b 45 08             	mov    0x8(%ebp),%eax
  42:	8d 50 01             	lea    0x1(%eax),%edx
  45:	89 55 08             	mov    %edx,0x8(%ebp)
  48:	0f b6 00             	movzbl (%eax),%eax
  4b:	3c 40                	cmp    $0x40,%al
  4d:	7e 17                	jle    66 <strncicmp+0x66>
  4f:	8b 45 08             	mov    0x8(%ebp),%eax
  52:	8d 50 01             	lea    0x1(%eax),%edx
  55:	89 55 08             	mov    %edx,0x8(%ebp)
  58:	0f b6 00             	movzbl (%eax),%eax
  5b:	3c 5a                	cmp    $0x5a,%al
  5d:	7f 07                	jg     66 <strncicmp+0x66>
  5f:	b8 01 00 00 00       	mov    $0x1,%eax
  64:	eb 05                	jmp    6b <strncicmp+0x6b>
  66:	b8 00 00 00 00       	mov    $0x0,%eax
  6b:	c1 e0 05             	shl    $0x5,%eax
  6e:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  71:	8b 45 0c             	mov    0xc(%ebp),%eax
  74:	8d 50 01             	lea    0x1(%eax),%edx
  77:	89 55 0c             	mov    %edx,0xc(%ebp)
  7a:	0f b6 00             	movzbl (%eax),%eax
  7d:	0f be c8             	movsbl %al,%ecx
  80:	8b 45 0c             	mov    0xc(%ebp),%eax
  83:	8d 50 01             	lea    0x1(%eax),%edx
  86:	89 55 0c             	mov    %edx,0xc(%ebp)
  89:	0f b6 00             	movzbl (%eax),%eax
  8c:	3c 40                	cmp    $0x40,%al
  8e:	7e 17                	jle    a7 <strncicmp+0xa7>
  90:	8b 45 0c             	mov    0xc(%ebp),%eax
  93:	8d 50 01             	lea    0x1(%eax),%edx
  96:	89 55 0c             	mov    %edx,0xc(%ebp)
  99:	0f b6 00             	movzbl (%eax),%eax
  9c:	3c 5a                	cmp    $0x5a,%al
  9e:	7f 07                	jg     a7 <strncicmp+0xa7>
  a0:	b8 01 00 00 00       	mov    $0x1,%eax
  a5:	eb 05                	jmp    ac <strncicmp+0xac>
  a7:	b8 00 00 00 00       	mov    $0x0,%eax
  ac:	c1 e0 05             	shl    $0x5,%eax
  af:	01 c8                	add    %ecx,%eax
  b1:	39 c3                	cmp    %eax,%ebx
  b3:	0f 84 5b ff ff ff    	je     14 <strncicmp+0x14>
	return (tolower(*str1) - tolower(*str2));
  b9:	8b 45 08             	mov    0x8(%ebp),%eax
  bc:	0f b6 00             	movzbl (%eax),%eax
  bf:	0f be d0             	movsbl %al,%edx
  c2:	8b 45 08             	mov    0x8(%ebp),%eax
  c5:	0f b6 00             	movzbl (%eax),%eax
  c8:	3c 40                	cmp    $0x40,%al
  ca:	7e 11                	jle    dd <strncicmp+0xdd>
  cc:	8b 45 08             	mov    0x8(%ebp),%eax
  cf:	0f b6 00             	movzbl (%eax),%eax
  d2:	3c 5a                	cmp    $0x5a,%al
  d4:	7f 07                	jg     dd <strncicmp+0xdd>
  d6:	b8 01 00 00 00       	mov    $0x1,%eax
  db:	eb 05                	jmp    e2 <strncicmp+0xe2>
  dd:	b8 00 00 00 00       	mov    $0x0,%eax
  e2:	c1 e0 05             	shl    $0x5,%eax
  e5:	01 c2                	add    %eax,%edx
  e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  ea:	0f b6 00             	movzbl (%eax),%eax
  ed:	3c 40                	cmp    $0x40,%al
  ef:	7e 11                	jle    102 <strncicmp+0x102>
  f1:	8b 45 0c             	mov    0xc(%ebp),%eax
  f4:	0f b6 00             	movzbl (%eax),%eax
  f7:	3c 5a                	cmp    $0x5a,%al
  f9:	7f 07                	jg     102 <strncicmp+0x102>
  fb:	b9 01 00 00 00       	mov    $0x1,%ecx
 100:	eb 05                	jmp    107 <strncicmp+0x107>
 102:	b9 00 00 00 00       	mov    $0x0,%ecx
 107:	b8 00 00 00 00       	mov    $0x0,%eax
 10c:	29 c8                	sub    %ecx,%eax
 10e:	c1 e0 05             	shl    $0x5,%eax
 111:	89 c1                	mov    %eax,%ecx
 113:	8b 45 0c             	mov    0xc(%ebp),%eax
 116:	0f b6 00             	movzbl (%eax),%eax
 119:	0f be c0             	movsbl %al,%eax
 11c:	29 c1                	sub    %eax,%ecx
 11e:	89 c8                	mov    %ecx,%eax
 120:	01 d0                	add    %edx,%eax
 122:	5b                   	pop    %ebx
 123:	5d                   	pop    %ebp
 124:	c3                   	ret    

strncmp.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strncmp>:
#include <lib/string.h>

int strncmp(const char* str1, const char* str2, size_t n){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp

	// Sanity check
	if(n == 0) 
   3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   7:	75 0b                	jne    14 <strncmp+0x14>
		return 0;
   9:	b8 00 00 00 00       	mov    $0x0,%eax
   e:	eb 46                	jmp    56 <strncmp+0x56>

	for(;*str1 && (n > 1) && (*str1++ == *str2++);--n);
  10:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
  14:	8b 45 08             	mov    0x8(%ebp),%eax
  17:	0f b6 00             	movzbl (%eax),%eax
  1a:	84 c0                	test   %al,%al
  1c:	74 22                	je     40 <strncmp+0x40>
  1e:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  22:	76 1c                	jbe    40 <strncmp+0x40>
  24:	8b 45 08             	mov    0x8(%ebp),%eax
  27:	8d 50 01             	lea    0x1(%eax),%edx
  2a:	89 55 08             	mov    %edx,0x8(%ebp)
  2d:	0f b6 08             	movzbl (%eax),%ecx
  30:	8b 45 0c             	mov    0xc(%ebp),%eax
  33:	8d 50 01             	lea    0x1(%eax),%edx
  36:	89 55 0c             	mov    %edx,0xc(%ebp)
  39:	0f b6 00             	movzbl (%eax),%eax
  3c:	38 c1                	cmp    %al,%cl
  3e:	74 d0                	je     10 <strncmp+0x10>
	return (*str1 - *str2);
  40:	8b 45 08             	mov    0x8(%ebp),%eax
  43:	0f b6 00             	movzbl (%eax),%eax
  46:	0f be d0             	movsbl %al,%edx
  49:	8b 45 0c             	mov    0xc(%ebp),%eax
  4c:	0f b6 00             	movzbl (%eax),%eax
  4f:	0f be c0             	movsbl %al,%eax
  52:	29 c2                	sub    %eax,%edx
  54:	89 d0                	mov    %edx,%eax
  56:	5d                   	pop    %ebp
  57:	c3                   	ret    

strncpy.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strncpy>:
#include <lib/string.h>

char* strncpy(char* dest, const char* src, size_t n){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp

	char* s1_p = dest;
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while((*dest++ = *src++) && n-- > 0);
   c:	90                   	nop
   d:	8b 45 08             	mov    0x8(%ebp),%eax
  10:	8d 50 01             	lea    0x1(%eax),%edx
  13:	89 55 08             	mov    %edx,0x8(%ebp)
  16:	8b 55 0c             	mov    0xc(%ebp),%edx
  19:	8d 4a 01             	lea    0x1(%edx),%ecx
  1c:	89 4d 0c             	mov    %ecx,0xc(%ebp)
  1f:	0f b6 12             	movzbl (%edx),%edx
  22:	88 10                	mov    %dl,(%eax)
  24:	0f b6 00             	movzbl (%eax),%eax
  27:	84 c0                	test   %al,%al
  29:	74 0d                	je     38 <strncpy+0x38>
  2b:	8b 45 10             	mov    0x10(%ebp),%eax
  2e:	8d 50 ff             	lea    -0x1(%eax),%edx
  31:	89 55 10             	mov    %edx,0x10(%ebp)
  34:	85 c0                	test   %eax,%eax
  36:	75 d5                	jne    d <strncpy+0xd>
	*dest = '\0'; // Null terminate
  38:	8b 45 08             	mov    0x8(%ebp),%eax
  3b:	c6 00 00             	movb   $0x0,(%eax)
	return s1_p;
  3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  41:	c9                   	leave  
  42:	c3                   	ret    

strtol.o:     file format elf32-i386


Disassembly of section .text:

00000000 <strtol>:
#include <lib/string.h>

long strtol(const char* nptr, char** endptr, int base){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 20             	sub    $0x20,%esp
	const char* s = nptr; // Pointer to next char to process
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	unsigned long acc; // Accumulator for the value
	int c; // Currentrly processed char.
	unsigned long cutoff; 	// Largest possible number that fit into a long in
							// a given base divided by the base.
	int neg = 0; // Indicates whether the string represents a negative number
   c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int cutlim; // Last digit of cutoff value

	// Skip whitespace
	do{

		c = *s++;
  13:	8b 45 fc             	mov    -0x4(%ebp),%eax
  16:	8d 50 01             	lea    0x1(%eax),%edx
  19:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1c:	0f b6 00             	movzbl (%eax),%eax
  1f:	0f be c0             	movsbl %al,%eax
  22:	89 45 f4             	mov    %eax,-0xc(%ebp)

	} while (isspace(c));
  25:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
  29:	74 e8                	je     13 <strtol+0x13>
  2b:	83 7d f4 08          	cmpl   $0x8,-0xc(%ebp)
  2f:	7e 06                	jle    37 <strtol+0x37>
  31:	83 7d f4 0d          	cmpl   $0xd,-0xc(%ebp)
  35:	7e dc                	jle    13 <strtol+0x13>

	// Check the sign (if any) passed in the string.
	if(c == '-'){
  37:	83 7d f4 2d          	cmpl   $0x2d,-0xc(%ebp)
  3b:	75 1b                	jne    58 <strtol+0x58>

		neg = 1;
  3d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		c = *s++;
  44:	8b 45 fc             	mov    -0x4(%ebp),%eax
  47:	8d 50 01             	lea    0x1(%eax),%edx
  4a:	89 55 fc             	mov    %edx,-0x4(%ebp)
  4d:	0f b6 00             	movzbl (%eax),%eax
  50:	0f be c0             	movsbl %al,%eax
  53:	89 45 f4             	mov    %eax,-0xc(%ebp)
  56:	eb 18                	jmp    70 <strtol+0x70>

	} else if(c == '+') {
  58:	83 7d f4 2b          	cmpl   $0x2b,-0xc(%ebp)
  5c:	75 12                	jne    70 <strtol+0x70>

		c = *s++;
  5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  61:	8d 50 01             	lea    0x1(%eax),%edx
  64:	89 55 fc             	mov    %edx,-0x4(%ebp)
  67:	0f b6 00             	movzbl (%eax),%eax
  6a:	0f be c0             	movsbl %al,%eax
  6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	// If the base is either unspecified(0) or 16, allow "0x" or "0X" to
	// precede number. This will set base to 16 if it were unspecified.
	if((base == 0 || base == 16) && c == '0' && (*s == 'x'|| *s == 'X')){
  70:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  74:	74 06                	je     7c <strtol+0x7c>
  76:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  7a:	75 36                	jne    b2 <strtol+0xb2>
  7c:	83 7d f4 30          	cmpl   $0x30,-0xc(%ebp)
  80:	75 30                	jne    b2 <strtol+0xb2>
  82:	8b 45 fc             	mov    -0x4(%ebp),%eax
  85:	0f b6 00             	movzbl (%eax),%eax
  88:	3c 78                	cmp    $0x78,%al
  8a:	74 0a                	je     96 <strtol+0x96>
  8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  8f:	0f b6 00             	movzbl (%eax),%eax
  92:	3c 58                	cmp    $0x58,%al
  94:	75 1c                	jne    b2 <strtol+0xb2>

		c = s[1];
  96:	8b 45 fc             	mov    -0x4(%ebp),%eax
  99:	83 c0 01             	add    $0x1,%eax
  9c:	0f b6 00             	movzbl (%eax),%eax
  9f:	0f be c0             	movsbl %al,%eax
  a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		s += 2;
  a5:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
		base = 16;
  a9:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
  b0:	eb 5e                	jmp    110 <strtol+0x110>
	} 

	// If the base is either unspecified(0) or 2, allow "0b" or "0B" to
	// precede number. This will set base to 2 if it were unspecified.
	else if ((base == 0 || base == 2) && c == '0' && (*s == 'b'|| *s == 'B')){
  b2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  b6:	74 06                	je     be <strtol+0xbe>
  b8:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  bc:	75 36                	jne    f4 <strtol+0xf4>
  be:	83 7d f4 30          	cmpl   $0x30,-0xc(%ebp)
  c2:	75 30                	jne    f4 <strtol+0xf4>
  c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  c7:	0f b6 00             	movzbl (%eax),%eax
  ca:	3c 62                	cmp    $0x62,%al
  cc:	74 0a                	je     d8 <strtol+0xd8>
  ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
  d1:	0f b6 00             	movzbl (%eax),%eax
  d4:	3c 42                	cmp    $0x42,%al
  d6:	75 1c                	jne    f4 <strtol+0xf4>

		c = s[1];
  d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  db:	83 c0 01             	add    $0x1,%eax
  de:	0f b6 00             	movzbl (%eax),%eax
  e1:	0f be c0             	movsbl %al,%eax
  e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		s += 2;
  e7:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
		base = 2;
  eb:	c7 45 10 02 00 00 00 	movl   $0x2,0x10(%ebp)
  f2:	eb 1c                	jmp    110 <strtol+0x110>
	}

	// If the base still is unspecified, assume octal if number starts with a 0,
	// else decimal
	else if(base == 0){
  f4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  f8:	75 16                	jne    110 <strtol+0x110>

		if(c == '0'){
  fa:	83 7d f4 30          	cmpl   $0x30,-0xc(%ebp)
  fe:	75 09                	jne    109 <strtol+0x109>

			base = 8;
 100:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
 107:	eb 07                	jmp    110 <strtol+0x110>
		} else {

			base = 10;
 109:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
		}
	}

	// Calculate cutoff and offset
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
 110:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 114:	74 07                	je     11d <strtol+0x11d>
 116:	b8 00 00 00 80       	mov    $0x80000000,%eax
 11b:	eb 05                	jmp    122 <strtol+0x122>
 11d:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
 122:	89 45 e8             	mov    %eax,-0x18(%ebp)
	cutlim = cutoff % (unsigned long)base;
 125:	8b 4d 10             	mov    0x10(%ebp),%ecx
 128:	8b 45 e8             	mov    -0x18(%ebp),%eax
 12b:	ba 00 00 00 00       	mov    $0x0,%edx
 130:	f7 f1                	div    %ecx
 132:	89 d0                	mov    %edx,%eax
 134:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	cutoff /= (unsigned long)base;
 137:	8b 4d 10             	mov    0x10(%ebp),%ecx
 13a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 13d:	ba 00 00 00 00       	mov    $0x0,%edx
 142:	f7 f1                	div    %ecx
 144:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for(acc = 0, any = 0;; c = *s++){
 147:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
 14e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		// Find numerical value of given char
		if(isdigit(c)){
 155:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
 159:	7e 0c                	jle    167 <strtol+0x167>
 15b:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
 15f:	7f 06                	jg     167 <strtol+0x167>

			c -= '0';
 161:	83 6d f4 30          	subl   $0x30,-0xc(%ebp)
 165:	eb 2e                	jmp    195 <strtol+0x195>
		} else if(isalpha(c)){
 167:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
 16b:	7e 06                	jle    173 <strtol+0x173>
 16d:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
 171:	7e 0c                	jle    17f <strtol+0x17f>
 173:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
 177:	7e 7c                	jle    1f5 <strtol+0x1f5>
 179:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
 17d:	7f 76                	jg     1f5 <strtol+0x1f5>

			if(isupper(c)){
 17f:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
 183:	7e 0c                	jle    191 <strtol+0x191>
 185:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
 189:	7f 06                	jg     191 <strtol+0x191>

				c -= 'A' - 10;
 18b:	83 6d f4 37          	subl   $0x37,-0xc(%ebp)
 18f:	eb 04                	jmp    195 <strtol+0x195>
			} else {

				c -= 'a' - 10;
 191:	83 6d f4 57          	subl   $0x57,-0xc(%ebp)
		} else {

			break; // Char is not number or alphabetical char.
		}

		if(c >= base){
 195:	8b 45 f4             	mov    -0xc(%ebp),%eax
 198:	3b 45 10             	cmp    0x10(%ebp),%eax
 19b:	7d 57                	jge    1f4 <strtol+0x1f4>

			break; // Digit is larger than base
		}

		// Check if appending the next character will result in an overflow.
		if(any < 0 || acc > cutoff || acc == cutoff && c > cutlim){
 19d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 1a1:	78 18                	js     1bb <strtol+0x1bb>
 1a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
 1a6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 1a9:	77 10                	ja     1bb <strtol+0x1bb>
 1ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
 1ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 1b1:	75 11                	jne    1c4 <strtol+0x1c4>
 1b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1b6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 1b9:	7e 09                	jle    1c4 <strtol+0x1c4>
			
			any = -1;
 1bb:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
 1c2:	eb 19                	jmp    1dd <strtol+0x1dd>
		} else {

			any = 1;
 1c4:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			acc *= base;
 1cb:	8b 45 10             	mov    0x10(%ebp),%eax
 1ce:	8b 55 f8             	mov    -0x8(%ebp),%edx
 1d1:	0f af c2             	imul   %edx,%eax
 1d4:	89 45 f8             	mov    %eax,-0x8(%ebp)
			acc += c;
 1d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1da:	01 45 f8             	add    %eax,-0x8(%ebp)
	// Calculate cutoff and offset
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;

	for(acc = 0, any = 0;; c = *s++){
 1dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
 1e0:	8d 50 01             	lea    0x1(%eax),%edx
 1e3:	89 55 fc             	mov    %edx,-0x4(%ebp)
 1e6:	0f b6 00             	movzbl (%eax),%eax
 1e9:	0f be c0             	movsbl %al,%eax
 1ec:	89 45 f4             	mov    %eax,-0xc(%ebp)

			any = 1;
			acc *= base;
			acc += c;
		}
	}
 1ef:	e9 61 ff ff ff       	jmp    155 <strtol+0x155>
			break; // Char is not number or alphabetical char.
		}

		if(c >= base){

			break; // Digit is larger than base
 1f4:	90                   	nop
			acc += c;
		}
	}

	// If overflow occured, set accumulator to maximum value 
	if(any < 0){
 1f5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 1f9:	79 17                	jns    212 <strtol+0x212>

		acc = neg ? LONG_MIN : LONG_MAX;
 1fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 1ff:	74 07                	je     208 <strtol+0x208>
 201:	b8 00 00 00 80       	mov    $0x80000000,%eax
 206:	eb 05                	jmp    20d <strtol+0x20d>
 208:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
 20d:	89 45 f8             	mov    %eax,-0x8(%ebp)
 210:	eb 09                	jmp    21b <strtol+0x21b>
	} else if(neg){
 212:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 216:	74 03                	je     21b <strtol+0x21b>

		acc = -acc;
 218:	f7 5d f8             	negl   -0x8(%ebp)
	}

	// If endptr point to a valid address, store terminating character there.
	if(endptr != 0){
 21b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 21f:	74 16                	je     237 <strtol+0x237>

		*endptr = (char*)(any ? (s - 1) : nptr);
 221:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 225:	74 08                	je     22f <strtol+0x22f>
 227:	8b 45 fc             	mov    -0x4(%ebp),%eax
 22a:	83 e8 01             	sub    $0x1,%eax
 22d:	eb 03                	jmp    232 <strtol+0x232>
 22f:	8b 45 08             	mov    0x8(%ebp),%eax
 232:	8b 55 0c             	mov    0xc(%ebp),%edx
 235:	89 02                	mov    %eax,(%edx)
	}

	// Return the calculated value
	return (acc);
 237:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 23a:	c9                   	leave  
 23b:	c3                   	ret    

0000023c <strtoul>:

unsigned long strtoul(const char* nptr, char** endptr, int base){
 23c:	55                   	push   %ebp
 23d:	89 e5                	mov    %esp,%ebp
 23f:	83 ec 20             	sub    $0x20,%esp
	const char* s = nptr; // Pointer to next char to process
 242:	8b 45 08             	mov    0x8(%ebp),%eax
 245:	89 45 fc             	mov    %eax,-0x4(%ebp)
	unsigned long acc; // Accumulator for the value
	int c; // Currentrly processed char.
	unsigned long cutoff; 	// Largest possible number that fit into a long in
							// a given base divided by the base.
	int neg = 0; // Indicates whether the string represents a negative number
 248:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int cutlim; // Last digit of cutoff value

	// Skip whitespace
	do{

		c = *s++;
 24f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 252:	8d 50 01             	lea    0x1(%eax),%edx
 255:	89 55 fc             	mov    %edx,-0x4(%ebp)
 258:	0f b6 00             	movzbl (%eax),%eax
 25b:	0f be c0             	movsbl %al,%eax
 25e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	} while (isspace(c));
 261:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
 265:	74 e8                	je     24f <strtoul+0x13>
 267:	83 7d f4 08          	cmpl   $0x8,-0xc(%ebp)
 26b:	7e 06                	jle    273 <strtoul+0x37>
 26d:	83 7d f4 0d          	cmpl   $0xd,-0xc(%ebp)
 271:	7e dc                	jle    24f <strtoul+0x13>

	// Check the sign (if any) passed in the string.
	if(c == '-'){
 273:	83 7d f4 2d          	cmpl   $0x2d,-0xc(%ebp)
 277:	75 1b                	jne    294 <strtoul+0x58>

		neg = 1;
 279:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		c = *s++;
 280:	8b 45 fc             	mov    -0x4(%ebp),%eax
 283:	8d 50 01             	lea    0x1(%eax),%edx
 286:	89 55 fc             	mov    %edx,-0x4(%ebp)
 289:	0f b6 00             	movzbl (%eax),%eax
 28c:	0f be c0             	movsbl %al,%eax
 28f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 292:	eb 18                	jmp    2ac <strtoul+0x70>

	} else if(c == '+') {
 294:	83 7d f4 2b          	cmpl   $0x2b,-0xc(%ebp)
 298:	75 12                	jne    2ac <strtoul+0x70>

		c = *s++;
 29a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 29d:	8d 50 01             	lea    0x1(%eax),%edx
 2a0:	89 55 fc             	mov    %edx,-0x4(%ebp)
 2a3:	0f b6 00             	movzbl (%eax),%eax
 2a6:	0f be c0             	movsbl %al,%eax
 2a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	// If the base is either unspecified(0) or 16, allow "0x" or "0X" to
	// precede number. This will set base to 16 if it were unspecified.
	if((base == 0 || base == 16) && c == '0' && (*s == 'x'|| *s == 'X')){
 2ac:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 2b0:	74 06                	je     2b8 <strtoul+0x7c>
 2b2:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
 2b6:	75 36                	jne    2ee <strtoul+0xb2>
 2b8:	83 7d f4 30          	cmpl   $0x30,-0xc(%ebp)
 2bc:	75 30                	jne    2ee <strtoul+0xb2>
 2be:	8b 45 fc             	mov    -0x4(%ebp),%eax
 2c1:	0f b6 00             	movzbl (%eax),%eax
 2c4:	3c 78                	cmp    $0x78,%al
 2c6:	74 0a                	je     2d2 <strtoul+0x96>
 2c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
 2cb:	0f b6 00             	movzbl (%eax),%eax
 2ce:	3c 58                	cmp    $0x58,%al
 2d0:	75 1c                	jne    2ee <strtoul+0xb2>

		c = s[1];
 2d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
 2d5:	83 c0 01             	add    $0x1,%eax
 2d8:	0f b6 00             	movzbl (%eax),%eax
 2db:	0f be c0             	movsbl %al,%eax
 2de:	89 45 f4             	mov    %eax,-0xc(%ebp)
		s += 2;
 2e1:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
		base = 16;
 2e5:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
 2ec:	eb 5e                	jmp    34c <strtoul+0x110>
	} 

	// If the base is either unspecified(0) or 2, allow "0b" or "0B" to
	// precede number. This will set base to 2 if it were unspecified.
	else if ((base == 0 || base == 2) && c == '0' && (*s == 'b'|| *s == 'B')){
 2ee:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 2f2:	74 06                	je     2fa <strtoul+0xbe>
 2f4:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
 2f8:	75 36                	jne    330 <strtoul+0xf4>
 2fa:	83 7d f4 30          	cmpl   $0x30,-0xc(%ebp)
 2fe:	75 30                	jne    330 <strtoul+0xf4>
 300:	8b 45 fc             	mov    -0x4(%ebp),%eax
 303:	0f b6 00             	movzbl (%eax),%eax
 306:	3c 62                	cmp    $0x62,%al
 308:	74 0a                	je     314 <strtoul+0xd8>
 30a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 30d:	0f b6 00             	movzbl (%eax),%eax
 310:	3c 42                	cmp    $0x42,%al
 312:	75 1c                	jne    330 <strtoul+0xf4>

		c = s[1];
 314:	8b 45 fc             	mov    -0x4(%ebp),%eax
 317:	83 c0 01             	add    $0x1,%eax
 31a:	0f b6 00             	movzbl (%eax),%eax
 31d:	0f be c0             	movsbl %al,%eax
 320:	89 45 f4             	mov    %eax,-0xc(%ebp)
		s += 2;
 323:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
		base = 2;
 327:	c7 45 10 02 00 00 00 	movl   $0x2,0x10(%ebp)
 32e:	eb 1c                	jmp    34c <strtoul+0x110>
	}

	// If the base still is unspecified, assume octal if number starts with a 0,
	// else decimal
	else if(base == 0){
 330:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 334:	75 16                	jne    34c <strtoul+0x110>

		if(c == '0'){
 336:	83 7d f4 30          	cmpl   $0x30,-0xc(%ebp)
 33a:	75 09                	jne    345 <strtoul+0x109>

			base = 8;
 33c:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
 343:	eb 07                	jmp    34c <strtoul+0x110>
		} else {

			base = 10;
 345:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
		}
	}

	// Calculate cutoff and offset
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
 34c:	8b 4d 10             	mov    0x10(%ebp),%ecx
 34f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 354:	ba 00 00 00 00       	mov    $0x0,%edx
 359:	f7 f1                	div    %ecx
 35b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
 35e:	8b 4d 10             	mov    0x10(%ebp),%ecx
 361:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 366:	ba 00 00 00 00       	mov    $0x0,%edx
 36b:	f7 f1                	div    %ecx
 36d:	89 d0                	mov    %edx,%eax
 36f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	for(acc = 0, any = 0;; c = *s++){
 372:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
 379:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		// Find numerical value of given char
		if(isdigit(c)){
 380:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
 384:	7e 0c                	jle    392 <strtoul+0x156>
 386:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
 38a:	7f 06                	jg     392 <strtoul+0x156>

			c -= '0';
 38c:	83 6d f4 30          	subl   $0x30,-0xc(%ebp)
 390:	eb 2e                	jmp    3c0 <strtoul+0x184>
		} else if(isalpha(c)){
 392:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
 396:	7e 06                	jle    39e <strtoul+0x162>
 398:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
 39c:	7e 0c                	jle    3aa <strtoul+0x16e>
 39e:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
 3a2:	7e 7c                	jle    420 <strtoul+0x1e4>
 3a4:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
 3a8:	7f 76                	jg     420 <strtoul+0x1e4>

			if(isupper(c)){
 3aa:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
 3ae:	7e 0c                	jle    3bc <strtoul+0x180>
 3b0:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
 3b4:	7f 06                	jg     3bc <strtoul+0x180>

				c -= 'A' - 10;
 3b6:	83 6d f4 37          	subl   $0x37,-0xc(%ebp)
 3ba:	eb 04                	jmp    3c0 <strtoul+0x184>
			} else {

				c -= 'a' - 10;
 3bc:	83 6d f4 57          	subl   $0x57,-0xc(%ebp)
		} else {

			break; // Char is not number or alphabetical char.
		}

		if(c >= base){
 3c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 3c3:	3b 45 10             	cmp    0x10(%ebp),%eax
 3c6:	7d 57                	jge    41f <strtoul+0x1e3>

			break; // Digit is larger than base
		}

		// Check if appending the next character will result in an overflow.
		if(any < 0 || acc > cutoff || acc == cutoff && c > cutlim){
 3c8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 3cc:	78 18                	js     3e6 <strtoul+0x1aa>
 3ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
 3d1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 3d4:	77 10                	ja     3e6 <strtoul+0x1aa>
 3d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
 3d9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 3dc:	75 11                	jne    3ef <strtoul+0x1b3>
 3de:	8b 45 f4             	mov    -0xc(%ebp),%eax
 3e1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 3e4:	7e 09                	jle    3ef <strtoul+0x1b3>
			
			any = -1;
 3e6:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
 3ed:	eb 19                	jmp    408 <strtoul+0x1cc>
		} else {

			any = 1;
 3ef:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			acc *= base;
 3f6:	8b 45 10             	mov    0x10(%ebp),%eax
 3f9:	8b 55 f8             	mov    -0x8(%ebp),%edx
 3fc:	0f af c2             	imul   %edx,%eax
 3ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
			acc += c;
 402:	8b 45 f4             	mov    -0xc(%ebp),%eax
 405:	01 45 f8             	add    %eax,-0x8(%ebp)

	// Calculate cutoff and offset
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;

	for(acc = 0, any = 0;; c = *s++){
 408:	8b 45 fc             	mov    -0x4(%ebp),%eax
 40b:	8d 50 01             	lea    0x1(%eax),%edx
 40e:	89 55 fc             	mov    %edx,-0x4(%ebp)
 411:	0f b6 00             	movzbl (%eax),%eax
 414:	0f be c0             	movsbl %al,%eax
 417:	89 45 f4             	mov    %eax,-0xc(%ebp)

			any = 1;
			acc *= base;
			acc += c;
		}
	}
 41a:	e9 61 ff ff ff       	jmp    380 <strtoul+0x144>
			break; // Char is not number or alphabetical char.
		}

		if(c >= base){

			break; // Digit is larger than base
 41f:	90                   	nop
			acc += c;
		}
	}

	// If overflow occured, set accumulator to maximum value 
	if(any < 0){
 420:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 424:	79 09                	jns    42f <strtoul+0x1f3>

		acc = ULONG_MAX;
 426:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
 42d:	eb 09                	jmp    438 <strtoul+0x1fc>
	} else if(neg){
 42f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 433:	74 03                	je     438 <strtoul+0x1fc>

		acc = -acc;
 435:	f7 5d f8             	negl   -0x8(%ebp)
	}

	// If endptr point to a valid address, store terminating character there.
	if(endptr != 0){
 438:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 43c:	74 16                	je     454 <strtoul+0x218>

		*endptr = (char*)(any ? (s - 1) : nptr);
 43e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 442:	74 08                	je     44c <strtoul+0x210>
 444:	8b 45 fc             	mov    -0x4(%ebp),%eax
 447:	83 e8 01             	sub    $0x1,%eax
 44a:	eb 03                	jmp    44f <strtoul+0x213>
 44c:	8b 45 08             	mov    0x8(%ebp),%eax
 44f:	8b 55 0c             	mov    0xc(%ebp),%edx
 452:	89 02                	mov    %eax,(%edx)
	}

	// Return the calculated value
	return (acc);
 454:	8b 45 f8             	mov    -0x8(%ebp),%eax
 457:	c9                   	leave  
 458:	c3                   	ret    

virtmem.o:     file format elf32-i386


Disassembly of section .text:

00000000 <pt_entry_add_attrib>:

//===================================================================
// PTE (Page Table Entry)
//===================================================================

void pt_entry_add_attrib (pt_entry* e, uint32_t attrib){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
	*e |= attrib;
   3:	8b 45 08             	mov    0x8(%ebp),%eax
   6:	8b 00                	mov    (%eax),%eax
   8:	0b 45 0c             	or     0xc(%ebp),%eax
   b:	89 c2                	mov    %eax,%edx
   d:	8b 45 08             	mov    0x8(%ebp),%eax
  10:	89 10                	mov    %edx,(%eax)
}
  12:	90                   	nop
  13:	5d                   	pop    %ebp
  14:	c3                   	ret    

00000015 <pt_entry_del_attrib>:

void pt_entry_del_attrib (pt_entry* e, uint32_t attrib){
  15:	55                   	push   %ebp
  16:	89 e5                	mov    %esp,%ebp
	*e &= ~attrib;
  18:	8b 45 08             	mov    0x8(%ebp),%eax
  1b:	8b 00                	mov    (%eax),%eax
  1d:	8b 55 0c             	mov    0xc(%ebp),%edx
  20:	f7 d2                	not    %edx
  22:	21 c2                	and    %eax,%edx
  24:	8b 45 08             	mov    0x8(%ebp),%eax
  27:	89 10                	mov    %edx,(%eax)
}
  29:	90                   	nop
  2a:	5d                   	pop    %ebp
  2b:	c3                   	ret    

0000002c <pt_entry_set_frame>:

void pt_entry_set_frame (pt_entry* e, physical_addr addr){
  2c:	55                   	push   %ebp
  2d:	89 e5                	mov    %esp,%ebp
	*e = (*e & ~I86_PTE_FRAME) | addr;
  2f:	8b 45 08             	mov    0x8(%ebp),%eax
  32:	8b 00                	mov    (%eax),%eax
  34:	25 ff 0f 00 80       	and    $0x80000fff,%eax
  39:	0b 45 0c             	or     0xc(%ebp),%eax
  3c:	89 c2                	mov    %eax,%edx
  3e:	8b 45 08             	mov    0x8(%ebp),%eax
  41:	89 10                	mov    %edx,(%eax)
}
  43:	90                   	nop
  44:	5d                   	pop    %ebp
  45:	c3                   	ret    

00000046 <pt_entry_is_present>:

int pt_entry_is_present (pt_entry e){
  46:	55                   	push   %ebp
  47:	89 e5                	mov    %esp,%ebp
	return e & I86_PTE_PRESENT;
  49:	8b 45 08             	mov    0x8(%ebp),%eax
  4c:	83 e0 01             	and    $0x1,%eax
}
  4f:	5d                   	pop    %ebp
  50:	c3                   	ret    

00000051 <pt_entry_is_writable>:

int pt_entry_is_writable (pt_entry e){
  51:	55                   	push   %ebp
  52:	89 e5                	mov    %esp,%ebp
	return e & I86_PTE_WRITABLE;
  54:	8b 45 08             	mov    0x8(%ebp),%eax
  57:	83 e0 02             	and    $0x2,%eax
}
  5a:	5d                   	pop    %ebp
  5b:	c3                   	ret    

0000005c <pt_entry_pfn>:

physical_addr pt_entry_pfn (pt_entry e){
  5c:	55                   	push   %ebp
  5d:	89 e5                	mov    %esp,%ebp
	return e & I86_PTE_FRAME;
  5f:	8b 45 08             	mov    0x8(%ebp),%eax
  62:	25 00 f0 ff 7f       	and    $0x7ffff000,%eax
}
  67:	5d                   	pop    %ebp
  68:	c3                   	ret    

00000069 <pd_entry_add_attrib>:

//===================================================================
// PDE (Page Directory Entry)
//===================================================================

void pd_entry_add_attrib (pd_entry* e, uint32_t attrib){
  69:	55                   	push   %ebp
  6a:	89 e5                	mov    %esp,%ebp
	*e |= attrib;
  6c:	8b 45 08             	mov    0x8(%ebp),%eax
  6f:	8b 00                	mov    (%eax),%eax
  71:	0b 45 0c             	or     0xc(%ebp),%eax
  74:	89 c2                	mov    %eax,%edx
  76:	8b 45 08             	mov    0x8(%ebp),%eax
  79:	89 10                	mov    %edx,(%eax)
}
  7b:	90                   	nop
  7c:	5d                   	pop    %ebp
  7d:	c3                   	ret    

0000007e <pd_entry_del_attrib>:

void pd_entry_del_attrib (pd_entry* e, uint32_t attrib){
  7e:	55                   	push   %ebp
  7f:	89 e5                	mov    %esp,%ebp
	*e &= ~attrib;
  81:	8b 45 08             	mov    0x8(%ebp),%eax
  84:	8b 00                	mov    (%eax),%eax
  86:	8b 55 0c             	mov    0xc(%ebp),%edx
  89:	f7 d2                	not    %edx
  8b:	21 c2                	and    %eax,%edx
  8d:	8b 45 08             	mov    0x8(%ebp),%eax
  90:	89 10                	mov    %edx,(%eax)
}
  92:	90                   	nop
  93:	5d                   	pop    %ebp
  94:	c3                   	ret    

00000095 <pd_entry_set_frame>:

void pd_entry_set_frame (pd_entry* e, physical_addr addr){
  95:	55                   	push   %ebp
  96:	89 e5                	mov    %esp,%ebp
	*e = (*e & ~I86_PDE_FRAME) | addr;
  98:	8b 45 08             	mov    0x8(%ebp),%eax
  9b:	8b 00                	mov    (%eax),%eax
  9d:	25 ff 0f 00 80       	and    $0x80000fff,%eax
  a2:	0b 45 0c             	or     0xc(%ebp),%eax
  a5:	89 c2                	mov    %eax,%edx
  a7:	8b 45 08             	mov    0x8(%ebp),%eax
  aa:	89 10                	mov    %edx,(%eax)
}
  ac:	90                   	nop
  ad:	5d                   	pop    %ebp
  ae:	c3                   	ret    

000000af <pd_entry_is_present>:

int pd_entry_is_present (pd_entry e){
  af:	55                   	push   %ebp
  b0:	89 e5                	mov    %esp,%ebp
	return e & I86_PDE_PRESENT;
  b2:	8b 45 08             	mov    0x8(%ebp),%eax
  b5:	83 e0 01             	and    $0x1,%eax
}
  b8:	5d                   	pop    %ebp
  b9:	c3                   	ret    

000000ba <pd_entry_is_user>:

int pd_entry_is_user (pd_entry e){
  ba:	55                   	push   %ebp
  bb:	89 e5                	mov    %esp,%ebp
	return e & I86_PDE_USER;
  bd:	8b 45 08             	mov    0x8(%ebp),%eax
  c0:	83 e0 04             	and    $0x4,%eax
}
  c3:	5d                   	pop    %ebp
  c4:	c3                   	ret    

000000c5 <pd_entry_is_4mb>:

int pd_entry_is_4mb (pd_entry e){
  c5:	55                   	push   %ebp
  c6:	89 e5                	mov    %esp,%ebp
	return e & I86_PDE_4MB;
  c8:	8b 45 08             	mov    0x8(%ebp),%eax
  cb:	25 80 00 00 00       	and    $0x80,%eax
}
  d0:	5d                   	pop    %ebp
  d1:	c3                   	ret    

000000d2 <pd_entry_is_writable>:

int pd_entry_is_writable (pd_entry e){
  d2:	55                   	push   %ebp
  d3:	89 e5                	mov    %esp,%ebp
	return e & I86_PDE_WRITABLE;
  d5:	8b 45 08             	mov    0x8(%ebp),%eax
  d8:	83 e0 02             	and    $0x2,%eax
}
  db:	5d                   	pop    %ebp
  dc:	c3                   	ret    

000000dd <pd_entry_pfn>:

physical_addr pd_entry_pfn (pd_entry e){
  dd:	55                   	push   %ebp
  de:	89 e5                	mov    %esp,%ebp
	return e & I86_PDE_FRAME;
  e0:	8b 45 08             	mov    0x8(%ebp),%eax
  e3:	25 00 f0 ff 7f       	and    $0x7ffff000,%eax
}
  e8:	5d                   	pop    %ebp
  e9:	c3                   	ret    

000000ea <pd_entry_enable_global>:

void pd_entry_enable_global (pd_entry e){
  ea:	55                   	push   %ebp
  eb:	89 e5                	mov    %esp,%ebp
	// Empty for now.	
}
  ed:	90                   	nop
  ee:	5d                   	pop    %ebp
  ef:	c3                   	ret    

000000f0 <vmmngr_map_page>:
pdirectory* _cur_directory = 0;

// current page directory base register
physical_addr _cur_pdbr = 0;

void vmmngr_map_page(void* phys, void* virt){
  f0:	55                   	push   %ebp
  f1:	89 e5                	mov    %esp,%ebp
  f3:	83 ec 28             	sub    $0x28,%esp

	// Get page directory
	pdirectory* pageDirectory = vmmngr_get_directory();
  f6:	e8 fc ff ff ff       	call   f7 <vmmngr_map_page+0x7>
  fb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	pd_entry* e = 
		&pageDirectory->m_entries[PAGE_DIRECTORY_INDEX((uint32_t) virt)];
  fe:	8b 45 0c             	mov    0xc(%ebp),%eax
 101:	c1 e8 16             	shr    $0x16,%eax
void vmmngr_map_page(void* phys, void* virt){

	// Get page directory
	pdirectory* pageDirectory = vmmngr_get_directory();

	pd_entry* e = 
 104:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 10b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 10e:	01 d0                	add    %edx,%eax
 110:	89 45 f0             	mov    %eax,-0x10(%ebp)
		&pageDirectory->m_entries[PAGE_DIRECTORY_INDEX((uint32_t) virt)];

	if((*e & I86_PTE_PRESENT) != I86_PTE_PRESENT){
 113:	8b 45 f0             	mov    -0x10(%ebp),%eax
 116:	8b 00                	mov    (%eax),%eax
 118:	83 e0 01             	and    $0x1,%eax
 11b:	85 c0                	test   %eax,%eax
 11d:	75 6e                	jne    18d <vmmngr_map_page+0x9d>

		// Allocate page table
		ptable* table = (ptable*)pmmngr_alloc_block();
 11f:	e8 fc ff ff ff       	call   120 <vmmngr_map_page+0x30>
 124:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(!table)
 127:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 12b:	0f 84 a7 00 00 00    	je     1d8 <vmmngr_map_page+0xe8>
			return;

		memset(table,0,sizeof(ptable));
 131:	83 ec 04             	sub    $0x4,%esp
 134:	68 00 10 00 00       	push   $0x1000
 139:	6a 00                	push   $0x0
 13b:	ff 75 ec             	pushl  -0x14(%ebp)
 13e:	e8 fc ff ff ff       	call   13f <vmmngr_map_page+0x4f>
 143:	83 c4 10             	add    $0x10,%esp

		pd_entry* entry = 
			&pageDirectory->m_entries[PAGE_DIRECTORY_INDEX((uint32_t) virt)];
 146:	8b 45 0c             	mov    0xc(%ebp),%eax
 149:	c1 e8 16             	shr    $0x16,%eax
		if(!table)
			return;

		memset(table,0,sizeof(ptable));

		pd_entry* entry = 
 14c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 153:	8b 45 f4             	mov    -0xc(%ebp),%eax
 156:	01 d0                	add    %edx,%eax
 158:	89 45 e8             	mov    %eax,-0x18(%ebp)
			&pageDirectory->m_entries[PAGE_DIRECTORY_INDEX((uint32_t) virt)];

		pd_entry_add_attrib(entry, I86_PDE_PRESENT);
 15b:	83 ec 08             	sub    $0x8,%esp
 15e:	6a 01                	push   $0x1
 160:	ff 75 e8             	pushl  -0x18(%ebp)
 163:	e8 fc ff ff ff       	call   164 <vmmngr_map_page+0x74>
 168:	83 c4 10             	add    $0x10,%esp
		pd_entry_add_attrib(entry, I86_PDE_WRITABLE);
 16b:	83 ec 08             	sub    $0x8,%esp
 16e:	6a 02                	push   $0x2
 170:	ff 75 e8             	pushl  -0x18(%ebp)
 173:	e8 fc ff ff ff       	call   174 <vmmngr_map_page+0x84>
 178:	83 c4 10             	add    $0x10,%esp
		pd_entry_set_frame(entry, (physical_addr)table);
 17b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 17e:	83 ec 08             	sub    $0x8,%esp
 181:	50                   	push   %eax
 182:	ff 75 e8             	pushl  -0x18(%ebp)
 185:	e8 fc ff ff ff       	call   186 <vmmngr_map_page+0x96>
 18a:	83 c4 10             	add    $0x10,%esp
	}

	// Get table
	ptable* table = (ptable*) PAGE_GET_PHYSICAL_ADDRESS(e);
 18d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 190:	8b 00                	mov    (%eax),%eax
 192:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 197:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	// Get page
	pt_entry* page = &table->m_entries[PAGE_TABLE_INDEX((uint32_t) virt)];
 19a:	8b 45 0c             	mov    0xc(%ebp),%eax
 19d:	c1 e8 0c             	shr    $0xc,%eax
 1a0:	25 ff 03 00 00       	and    $0x3ff,%eax
 1a5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 1ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 1af:	01 d0                	add    %edx,%eax
 1b1:	89 45 e0             	mov    %eax,-0x20(%ebp)

	pt_entry_set_frame(page, (physical_addr)phys);
 1b4:	8b 45 08             	mov    0x8(%ebp),%eax
 1b7:	83 ec 08             	sub    $0x8,%esp
 1ba:	50                   	push   %eax
 1bb:	ff 75 e0             	pushl  -0x20(%ebp)
 1be:	e8 fc ff ff ff       	call   1bf <vmmngr_map_page+0xcf>
 1c3:	83 c4 10             	add    $0x10,%esp
	pt_entry_add_attrib(page, I86_PTE_PRESENT);
 1c6:	83 ec 08             	sub    $0x8,%esp
 1c9:	6a 01                	push   $0x1
 1cb:	ff 75 e0             	pushl  -0x20(%ebp)
 1ce:	e8 fc ff ff ff       	call   1cf <vmmngr_map_page+0xdf>
 1d3:	83 c4 10             	add    $0x10,%esp
 1d6:	eb 01                	jmp    1d9 <vmmngr_map_page+0xe9>

		// Allocate page table
		ptable* table = (ptable*)pmmngr_alloc_block();

		if(!table)
			return;
 1d8:	90                   	nop
	// Get page
	pt_entry* page = &table->m_entries[PAGE_TABLE_INDEX((uint32_t) virt)];

	pt_entry_set_frame(page, (physical_addr)phys);
	pt_entry_add_attrib(page, I86_PTE_PRESENT);
}
 1d9:	c9                   	leave  
 1da:	c3                   	ret    

000001db <vmmngr_initialize>:

void vmmngr_initialize(){
 1db:	55                   	push   %ebp
 1dc:	89 e5                	mov    %esp,%ebp
 1de:	83 ec 48             	sub    $0x48,%esp

	// allocate default page table
	ptable* table = (ptable*) pmmngr_alloc_block ();
 1e1:	e8 fc ff ff ff       	call   1e2 <vmmngr_initialize+0x7>
 1e6:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (!table){
 1e9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 1ed:	0f 84 d6 01 00 00    	je     3c9 <vmmngr_initialize+0x1ee>
		return;
	}
    	

	// allocates 3gb page table
	ptable* table2 = (ptable*) pmmngr_alloc_block ();
 1f3:	e8 fc ff ff ff       	call   1f4 <vmmngr_initialize+0x19>
 1f8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	if (!table2){
 1fb:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 1ff:	0f 84 c7 01 00 00    	je     3cc <vmmngr_initialize+0x1f1>
		return;
	}

	// clear page table
	memset (table, 0, sizeof (ptable));
 205:	83 ec 04             	sub    $0x4,%esp
 208:	68 00 10 00 00       	push   $0x1000
 20d:	6a 00                	push   $0x0
 20f:	ff 75 dc             	pushl  -0x24(%ebp)
 212:	e8 fc ff ff ff       	call   213 <vmmngr_initialize+0x38>
 217:	83 c4 10             	add    $0x10,%esp

	// 1st 4mb are idenitity mapped
	for (int i=0, frame=0x0, virt=0x00000000; i<1024; i++, frame+=4096, virt+=4096) {
 21a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 221:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 228:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 22f:	eb 53                	jmp    284 <vmmngr_initialize+0xa9>

		// create a new page
		pt_entry page=0;
 231:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
		pt_entry_add_attrib (&page, I86_PTE_PRESENT);
 238:	83 ec 08             	sub    $0x8,%esp
 23b:	6a 01                	push   $0x1
 23d:	8d 45 c8             	lea    -0x38(%ebp),%eax
 240:	50                   	push   %eax
 241:	e8 fc ff ff ff       	call   242 <vmmngr_initialize+0x67>
 246:	83 c4 10             	add    $0x10,%esp
		pt_entry_set_frame (&page, frame);
 249:	8b 45 f0             	mov    -0x10(%ebp),%eax
 24c:	83 ec 08             	sub    $0x8,%esp
 24f:	50                   	push   %eax
 250:	8d 45 c8             	lea    -0x38(%ebp),%eax
 253:	50                   	push   %eax
 254:	e8 fc ff ff ff       	call   255 <vmmngr_initialize+0x7a>
 259:	83 c4 10             	add    $0x10,%esp

		// ...and add it to the page table
		table2->m_entries [PAGE_TABLE_INDEX (virt) ] = page;
 25c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 25f:	c1 f8 0c             	sar    $0xc,%eax
 262:	25 ff 03 00 00       	and    $0x3ff,%eax
 267:	89 c1                	mov    %eax,%ecx
 269:	8b 55 c8             	mov    -0x38(%ebp),%edx
 26c:	8b 45 d8             	mov    -0x28(%ebp),%eax
 26f:	89 14 88             	mov    %edx,(%eax,%ecx,4)

	// clear page table
	memset (table, 0, sizeof (ptable));

	// 1st 4mb are idenitity mapped
	for (int i=0, frame=0x0, virt=0x00000000; i<1024; i++, frame+=4096, virt+=4096) {
 272:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 276:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
 27d:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
 284:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
 28b:	7e a4                	jle    231 <vmmngr_initialize+0x56>
		// ...and add it to the page table
		table2->m_entries [PAGE_TABLE_INDEX (virt) ] = page;
	}

	// map 1mb to 3gb (where we are at)
	for (int i=0, frame=0x100000, virt=0xc0000000; i<1024; i++, frame+=4096, virt+=4096) {
 28d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 294:	c7 45 e4 00 00 10 00 	movl   $0x100000,-0x1c(%ebp)
 29b:	c7 45 e0 00 00 00 c0 	movl   $0xc0000000,-0x20(%ebp)
 2a2:	eb 53                	jmp    2f7 <vmmngr_initialize+0x11c>

		// create a new page
		pt_entry page=0;
 2a4:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		pt_entry_add_attrib (&page, I86_PTE_PRESENT);
 2ab:	83 ec 08             	sub    $0x8,%esp
 2ae:	6a 01                	push   $0x1
 2b0:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 2b3:	50                   	push   %eax
 2b4:	e8 fc ff ff ff       	call   2b5 <vmmngr_initialize+0xda>
 2b9:	83 c4 10             	add    $0x10,%esp
		pt_entry_set_frame (&page, frame);
 2bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 2bf:	83 ec 08             	sub    $0x8,%esp
 2c2:	50                   	push   %eax
 2c3:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 2c6:	50                   	push   %eax
 2c7:	e8 fc ff ff ff       	call   2c8 <vmmngr_initialize+0xed>
 2cc:	83 c4 10             	add    $0x10,%esp

		// ...and add it to the page table
		table->m_entries [PAGE_TABLE_INDEX (virt) ] = page;
 2cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
 2d2:	c1 f8 0c             	sar    $0xc,%eax
 2d5:	25 ff 03 00 00       	and    $0x3ff,%eax
 2da:	89 c1                	mov    %eax,%ecx
 2dc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 2df:	8b 45 dc             	mov    -0x24(%ebp),%eax
 2e2:	89 14 88             	mov    %edx,(%eax,%ecx,4)
		// ...and add it to the page table
		table2->m_entries [PAGE_TABLE_INDEX (virt) ] = page;
	}

	// map 1mb to 3gb (where we are at)
	for (int i=0, frame=0x100000, virt=0xc0000000; i<1024; i++, frame+=4096, virt+=4096) {
 2e5:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
 2e9:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
 2f0:	81 45 e0 00 10 00 00 	addl   $0x1000,-0x20(%ebp)
 2f7:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
 2fe:	7e a4                	jle    2a4 <vmmngr_initialize+0xc9>
		// ...and add it to the page table
		table->m_entries [PAGE_TABLE_INDEX (virt) ] = page;
	}

	// create default directory table
	pdirectory*   dir = (pdirectory*) pmmngr_alloc_blocks (3);
 300:	83 ec 0c             	sub    $0xc,%esp
 303:	6a 03                	push   $0x3
 305:	e8 fc ff ff ff       	call   306 <vmmngr_initialize+0x12b>
 30a:	83 c4 10             	add    $0x10,%esp
 30d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!dir){
 310:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 314:	0f 84 b5 00 00 00    	je     3cf <vmmngr_initialize+0x1f4>
		return;
	}
		

	// clear directory table and set it as current
	memset (dir, 0, sizeof (pdirectory));
 31a:	83 ec 04             	sub    $0x4,%esp
 31d:	68 00 10 00 00       	push   $0x1000
 322:	6a 00                	push   $0x0
 324:	ff 75 d4             	pushl  -0x2c(%ebp)
 327:	e8 fc ff ff ff       	call   328 <vmmngr_initialize+0x14d>
 32c:	83 c4 10             	add    $0x10,%esp

	// get first entry in dir table and set it up to point to our table
	pd_entry* entry = &dir->m_entries [PAGE_DIRECTORY_INDEX (0xc0000000) ];
 32f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 332:	05 00 0c 00 00       	add    $0xc00,%eax
 337:	89 45 d0             	mov    %eax,-0x30(%ebp)
	pd_entry_add_attrib (entry, I86_PDE_PRESENT);
 33a:	83 ec 08             	sub    $0x8,%esp
 33d:	6a 01                	push   $0x1
 33f:	ff 75 d0             	pushl  -0x30(%ebp)
 342:	e8 fc ff ff ff       	call   343 <vmmngr_initialize+0x168>
 347:	83 c4 10             	add    $0x10,%esp
	pd_entry_add_attrib (entry, I86_PDE_WRITABLE);
 34a:	83 ec 08             	sub    $0x8,%esp
 34d:	6a 02                	push   $0x2
 34f:	ff 75 d0             	pushl  -0x30(%ebp)
 352:	e8 fc ff ff ff       	call   353 <vmmngr_initialize+0x178>
 357:	83 c4 10             	add    $0x10,%esp
	pd_entry_set_frame (entry, (physical_addr)table);
 35a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 35d:	83 ec 08             	sub    $0x8,%esp
 360:	50                   	push   %eax
 361:	ff 75 d0             	pushl  -0x30(%ebp)
 364:	e8 fc ff ff ff       	call   365 <vmmngr_initialize+0x18a>
 369:	83 c4 10             	add    $0x10,%esp

	pd_entry* entry2 = &dir->m_entries [PAGE_DIRECTORY_INDEX (0x00000000) ];
 36c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 36f:	89 45 cc             	mov    %eax,-0x34(%ebp)
	pd_entry_add_attrib (entry2, I86_PDE_PRESENT);
 372:	83 ec 08             	sub    $0x8,%esp
 375:	6a 01                	push   $0x1
 377:	ff 75 cc             	pushl  -0x34(%ebp)
 37a:	e8 fc ff ff ff       	call   37b <vmmngr_initialize+0x1a0>
 37f:	83 c4 10             	add    $0x10,%esp
	pd_entry_add_attrib (entry2, I86_PDE_WRITABLE);
 382:	83 ec 08             	sub    $0x8,%esp
 385:	6a 02                	push   $0x2
 387:	ff 75 cc             	pushl  -0x34(%ebp)
 38a:	e8 fc ff ff ff       	call   38b <vmmngr_initialize+0x1b0>
 38f:	83 c4 10             	add    $0x10,%esp
	pd_entry_set_frame (entry2, (physical_addr)table2);
 392:	8b 45 d8             	mov    -0x28(%ebp),%eax
 395:	83 ec 08             	sub    $0x8,%esp
 398:	50                   	push   %eax
 399:	ff 75 cc             	pushl  -0x34(%ebp)
 39c:	e8 fc ff ff ff       	call   39d <vmmngr_initialize+0x1c2>
 3a1:	83 c4 10             	add    $0x10,%esp

	// store current PDBR
	_cur_pdbr = (physical_addr) &dir->m_entries;
 3a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 3a7:	a3 00 00 00 00       	mov    %eax,0x0

	// switch to our page directory
	vmmngr_switch_pdirectory (dir);
 3ac:	83 ec 0c             	sub    $0xc,%esp
 3af:	ff 75 d4             	pushl  -0x2c(%ebp)
 3b2:	e8 fc ff ff ff       	call   3b3 <vmmngr_initialize+0x1d8>
 3b7:	83 c4 10             	add    $0x10,%esp

	// enable paging
	pmmngr_paging_enable (1);
 3ba:	83 ec 0c             	sub    $0xc,%esp
 3bd:	6a 01                	push   $0x1
 3bf:	e8 fc ff ff ff       	call   3c0 <vmmngr_initialize+0x1e5>
 3c4:	83 c4 10             	add    $0x10,%esp
 3c7:	eb 07                	jmp    3d0 <vmmngr_initialize+0x1f5>
void vmmngr_initialize(){

	// allocate default page table
	ptable* table = (ptable*) pmmngr_alloc_block ();
	if (!table){
		return;
 3c9:	90                   	nop
 3ca:	eb 04                	jmp    3d0 <vmmngr_initialize+0x1f5>
    	

	// allocates 3gb page table
	ptable* table2 = (ptable*) pmmngr_alloc_block ();
	if (!table2){
		return;
 3cc:	90                   	nop
 3cd:	eb 01                	jmp    3d0 <vmmngr_initialize+0x1f5>
	}

	// create default directory table
	pdirectory*   dir = (pdirectory*) pmmngr_alloc_blocks (3);
	if (!dir){
		return;
 3cf:	90                   	nop
	// switch to our page directory
	vmmngr_switch_pdirectory (dir);

	// enable paging
	pmmngr_paging_enable (1);
}
 3d0:	c9                   	leave  
 3d1:	c3                   	ret    

000003d2 <vmmngr_alloc_page>:

int vmmngr_alloc_page(pt_entry* e){
 3d2:	55                   	push   %ebp
 3d3:	89 e5                	mov    %esp,%ebp
 3d5:	83 ec 18             	sub    $0x18,%esp

	void* p = pmmngr_alloc_block();
 3d8:	e8 fc ff ff ff       	call   3d9 <vmmngr_alloc_page+0x7>
 3dd:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!p)
 3e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 3e4:	75 07                	jne    3ed <vmmngr_alloc_page+0x1b>
		return 0;
 3e6:	b8 00 00 00 00       	mov    $0x0,%eax
 3eb:	eb 27                	jmp    414 <vmmngr_alloc_page+0x42>

	pt_entry_set_frame (e, (physical_addr)p);
 3ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
 3f0:	83 ec 08             	sub    $0x8,%esp
 3f3:	50                   	push   %eax
 3f4:	ff 75 08             	pushl  0x8(%ebp)
 3f7:	e8 fc ff ff ff       	call   3f8 <vmmngr_alloc_page+0x26>
 3fc:	83 c4 10             	add    $0x10,%esp
	pt_entry_add_attrib (e, I86_PTE_PRESENT);
 3ff:	83 ec 08             	sub    $0x8,%esp
 402:	6a 01                	push   $0x1
 404:	ff 75 08             	pushl  0x8(%ebp)
 407:	e8 fc ff ff ff       	call   408 <vmmngr_alloc_page+0x36>
 40c:	83 c4 10             	add    $0x10,%esp
	return 1;
 40f:	b8 01 00 00 00       	mov    $0x1,%eax
}
 414:	c9                   	leave  
 415:	c3                   	ret    

00000416 <vmmngr_free_page>:

void vmmngr_free_page(pt_entry* e){
 416:	55                   	push   %ebp
 417:	89 e5                	mov    %esp,%ebp
 419:	83 ec 18             	sub    $0x18,%esp

	void* p = (void*)pt_entry_pfn (*e);
 41c:	8b 45 08             	mov    0x8(%ebp),%eax
 41f:	8b 00                	mov    (%eax),%eax
 421:	50                   	push   %eax
 422:	e8 fc ff ff ff       	call   423 <vmmngr_free_page+0xd>
 427:	83 c4 04             	add    $0x4,%esp
 42a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p)
 42d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 431:	74 0e                	je     441 <vmmngr_free_page+0x2b>
		pmmngr_free_block (p);
 433:	83 ec 0c             	sub    $0xc,%esp
 436:	ff 75 f4             	pushl  -0xc(%ebp)
 439:	e8 fc ff ff ff       	call   43a <vmmngr_free_page+0x24>
 43e:	83 c4 10             	add    $0x10,%esp

	pt_entry_del_attrib (e, I86_PTE_PRESENT);
 441:	83 ec 08             	sub    $0x8,%esp
 444:	6a 01                	push   $0x1
 446:	ff 75 08             	pushl  0x8(%ebp)
 449:	e8 fc ff ff ff       	call   44a <vmmngr_free_page+0x34>
 44e:	83 c4 10             	add    $0x10,%esp
}
 451:	90                   	nop
 452:	c9                   	leave  
 453:	c3                   	ret    

00000454 <vmmngr_switch_pdirectory>:

int vmmngr_switch_pdirectory(pdirectory* dir){
 454:	55                   	push   %ebp
 455:	89 e5                	mov    %esp,%ebp
 457:	83 ec 08             	sub    $0x8,%esp
	if(!dir)
 45a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 45e:	75 07                	jne    467 <vmmngr_switch_pdirectory+0x13>
		return 0;
 460:	b8 00 00 00 00       	mov    $0x0,%eax
 465:	eb 1e                	jmp    485 <vmmngr_switch_pdirectory+0x31>

	_cur_directory = dir;
 467:	8b 45 08             	mov    0x8(%ebp),%eax
 46a:	a3 00 00 00 00       	mov    %eax,0x0
	pmmngr_load_PBDR(_cur_pdbr);
 46f:	a1 00 00 00 00       	mov    0x0,%eax
 474:	83 ec 0c             	sub    $0xc,%esp
 477:	50                   	push   %eax
 478:	e8 fc ff ff ff       	call   479 <vmmngr_switch_pdirectory+0x25>
 47d:	83 c4 10             	add    $0x10,%esp

	return 1;
 480:	b8 01 00 00 00       	mov    $0x1,%eax
}
 485:	c9                   	leave  
 486:	c3                   	ret    

00000487 <vmmngr_get_directory>:

pdirectory* vmmngr_get_directory(){
 487:	55                   	push   %ebp
 488:	89 e5                	mov    %esp,%ebp
	return _cur_directory;
 48a:	a1 00 00 00 00       	mov    0x0,%eax
}
 48f:	5d                   	pop    %ebp
 490:	c3                   	ret    

00000491 <vmmngr_flush_tlb_entry>:

void vmmngr_flush_tlb_entry(virtual_addr addr){
 491:	55                   	push   %ebp
 492:	89 e5                	mov    %esp,%ebp
 494:	53                   	push   %ebx

	asm volatile ("cli");
 495:	fa                   	cli    
	asm volatile ("invlpg (%0)" ::"b"(addr): "memory");
 496:	8b 45 08             	mov    0x8(%ebp),%eax
 499:	89 c3                	mov    %eax,%ebx
 49b:	0f 01 3b             	invlpg (%ebx)
	asm volatile ("sti");
 49e:	fb                   	sti    
}
 49f:	90                   	nop
 4a0:	5b                   	pop    %ebx
 4a1:	5d                   	pop    %ebp
 4a2:	c3                   	ret    

000004a3 <vmmngr_ptable_clear>:

void vmmngr_ptable_clear(ptable* p) {
 4a3:	55                   	push   %ebp
 4a4:	89 e5                	mov    %esp,%ebp
 4a6:	83 ec 08             	sub    $0x8,%esp

	if (p)
 4a9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 4ad:	74 15                	je     4c4 <vmmngr_ptable_clear+0x21>
		memset(p, 0, sizeof(ptable));
 4af:	83 ec 04             	sub    $0x4,%esp
 4b2:	68 00 10 00 00       	push   $0x1000
 4b7:	6a 00                	push   $0x0
 4b9:	ff 75 08             	pushl  0x8(%ebp)
 4bc:	e8 fc ff ff ff       	call   4bd <vmmngr_ptable_clear+0x1a>
 4c1:	83 c4 10             	add    $0x10,%esp
}
 4c4:	90                   	nop
 4c5:	c9                   	leave  
 4c6:	c3                   	ret    

000004c7 <vmmngr_ptable_virt_to_index>:

uint32_t vmmngr_ptable_virt_to_index(virtual_addr addr) {
 4c7:	55                   	push   %ebp
 4c8:	89 e5                	mov    %esp,%ebp

	//! return index only if address doesnt exceed page table address space size
	return (addr >= PTABLE_ADDR_SPACE_SIZE) ? 0 : addr / PAGE_SIZE;
 4ca:	81 7d 08 ff ff 3f 00 	cmpl   $0x3fffff,0x8(%ebp)
 4d1:	77 08                	ja     4db <vmmngr_ptable_virt_to_index+0x14>
 4d3:	8b 45 08             	mov    0x8(%ebp),%eax
 4d6:	c1 e8 0c             	shr    $0xc,%eax
 4d9:	eb 05                	jmp    4e0 <vmmngr_ptable_virt_to_index+0x19>
 4db:	b8 00 00 00 00       	mov    $0x0,%eax
}
 4e0:	5d                   	pop    %ebp
 4e1:	c3                   	ret    

000004e2 <vmmngr_ptable_lookup_entry>:

pt_entry* vmmngr_ptable_lookup_entry(ptable* p,virtual_addr addr){
 4e2:	55                   	push   %ebp
 4e3:	89 e5                	mov    %esp,%ebp

	if(p)
 4e5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 4e9:	74 19                	je     504 <vmmngr_ptable_lookup_entry+0x22>
		return &p->m_entries[PAGE_TABLE_INDEX(addr)];
 4eb:	8b 45 0c             	mov    0xc(%ebp),%eax
 4ee:	c1 e8 0c             	shr    $0xc,%eax
 4f1:	25 ff 03 00 00       	and    $0x3ff,%eax
 4f6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 4fd:	8b 45 08             	mov    0x8(%ebp),%eax
 500:	01 d0                	add    %edx,%eax
 502:	eb 05                	jmp    509 <vmmngr_ptable_lookup_entry+0x27>
	return 0;
 504:	b8 00 00 00 00       	mov    $0x0,%eax
}
 509:	5d                   	pop    %ebp
 50a:	c3                   	ret    

0000050b <vmmngr_pdirectory_virt_to_index>:

uint32_t vmmngr_pdirectory_virt_to_index(virtual_addr addr) {
 50b:	55                   	push   %ebp
 50c:	89 e5                	mov    %esp,%ebp

	//! return index only if address doesnt exceed 4gb (page directory address space size)
	return (addr >= DTABLE_ADDR_SPACE_SIZE) ? 0 : addr / PAGE_SIZE;
 50e:	8b 45 08             	mov    0x8(%ebp),%eax
 511:	c1 e8 0c             	shr    $0xc,%eax
}
 514:	5d                   	pop    %ebp
 515:	c3                   	ret    

00000516 <vmmngr_pdirectory_clear>:

void vmmngr_pdirectory_clear(pdirectory* dir) {
 516:	55                   	push   %ebp
 517:	89 e5                	mov    %esp,%ebp
 519:	83 ec 08             	sub    $0x8,%esp

	if (dir)
 51c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 520:	74 15                	je     537 <vmmngr_pdirectory_clear+0x21>
		memset(dir, 0, sizeof(pdirectory));
 522:	83 ec 04             	sub    $0x4,%esp
 525:	68 00 10 00 00       	push   $0x1000
 52a:	6a 00                	push   $0x0
 52c:	ff 75 08             	pushl  0x8(%ebp)
 52f:	e8 fc ff ff ff       	call   530 <vmmngr_pdirectory_clear+0x1a>
 534:	83 c4 10             	add    $0x10,%esp
}
 537:	90                   	nop
 538:	c9                   	leave  
 539:	c3                   	ret    

0000053a <vmmngr_pdirectory_lookup_entry>:

pd_entry* vmmngr_pdirectory_lookup_entry(pdirectory* p, virtual_addr addr){
 53a:	55                   	push   %ebp
 53b:	89 e5                	mov    %esp,%ebp

	if(p)
 53d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
		&p->m_entries[PAGE_TABLE_INDEX(addr)];
	return 0;
 541:	b8 00 00 00 00       	mov    $0x0,%eax
}
 546:	5d                   	pop    %ebp
 547:	c3                   	ret    

00000548 <vmmngr_createPageTable>:

int vmmngr_createPageTable(pdirectory* dir, uint32_t virt, uint32_t flags) {
 548:	55                   	push   %ebp
 549:	89 e5                	mov    %esp,%ebp
 54b:	83 ec 18             	sub    $0x18,%esp

	pd_entry* pagedir = dir->m_entries;
 54e:	8b 45 08             	mov    0x8(%ebp),%eax
 551:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pagedir[virt >> 22] == 0) {
 554:	8b 45 0c             	mov    0xc(%ebp),%eax
 557:	c1 e8 16             	shr    $0x16,%eax
 55a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 561:	8b 45 f4             	mov    -0xc(%ebp),%eax
 564:	01 d0                	add    %edx,%eax
 566:	8b 00                	mov    (%eax),%eax
 568:	85 c0                	test   %eax,%eax
 56a:	75 6c                	jne    5d8 <vmmngr_createPageTable+0x90>
		void* block = pmmngr_alloc_block();
 56c:	e8 fc ff ff ff       	call   56d <vmmngr_createPageTable+0x25>
 571:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (!block)
 574:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 578:	75 07                	jne    581 <vmmngr_createPageTable+0x39>
			return 0; /* Should call debugger */
 57a:	b8 00 00 00 00       	mov    $0x0,%eax
 57f:	eb 5c                	jmp    5dd <vmmngr_createPageTable+0x95>
		pagedir[virt >> 22] = ((uint32_t)block) | flags;
 581:	8b 45 0c             	mov    0xc(%ebp),%eax
 584:	c1 e8 16             	shr    $0x16,%eax
 587:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 58e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 591:	01 c2                	add    %eax,%edx
 593:	8b 45 f0             	mov    -0x10(%ebp),%eax
 596:	0b 45 10             	or     0x10(%ebp),%eax
 599:	89 02                	mov    %eax,(%edx)
		memset((uint32_t*)pagedir[virt >> 22], 0, 4096);
 59b:	8b 45 0c             	mov    0xc(%ebp),%eax
 59e:	c1 e8 16             	shr    $0x16,%eax
 5a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 5a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 5ab:	01 d0                	add    %edx,%eax
 5ad:	8b 00                	mov    (%eax),%eax
 5af:	83 ec 04             	sub    $0x4,%esp
 5b2:	68 00 10 00 00       	push   $0x1000
 5b7:	6a 00                	push   $0x0
 5b9:	50                   	push   %eax
 5ba:	e8 fc ff ff ff       	call   5bb <vmmngr_createPageTable+0x73>
 5bf:	83 c4 10             	add    $0x10,%esp

		/* map page table into directory */
		vmmngr_mapPhysicalAddress(dir, (uint32_t)block, (uint32_t)block, flags);
 5c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 5c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 5c8:	ff 75 10             	pushl  0x10(%ebp)
 5cb:	52                   	push   %edx
 5cc:	50                   	push   %eax
 5cd:	ff 75 08             	pushl  0x8(%ebp)
 5d0:	e8 fc ff ff ff       	call   5d1 <vmmngr_createPageTable+0x89>
 5d5:	83 c4 10             	add    $0x10,%esp
	}
	return 1; /* success */
 5d8:	b8 01 00 00 00       	mov    $0x1,%eax
}
 5dd:	c9                   	leave  
 5de:	c3                   	ret    

000005df <vmmngr_mapPhysicalAddress>:

void vmmngr_mapPhysicalAddress(pdirectory* dir, uint32_t virt, uint32_t phys, uint32_t flags) {
 5df:	55                   	push   %ebp
 5e0:	89 e5                	mov    %esp,%ebp
 5e2:	83 ec 18             	sub    $0x18,%esp

	pd_entry* pagedir = dir->m_entries;
 5e5:	8b 45 08             	mov    0x8(%ebp),%eax
 5e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pagedir[virt >> 22] == 0)
 5eb:	8b 45 0c             	mov    0xc(%ebp),%eax
 5ee:	c1 e8 16             	shr    $0x16,%eax
 5f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 5f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 5fb:	01 d0                	add    %edx,%eax
 5fd:	8b 00                	mov    (%eax),%eax
 5ff:	85 c0                	test   %eax,%eax
 601:	75 14                	jne    617 <vmmngr_mapPhysicalAddress+0x38>
		vmmngr_createPageTable(dir, virt, flags);
 603:	83 ec 04             	sub    $0x4,%esp
 606:	ff 75 14             	pushl  0x14(%ebp)
 609:	ff 75 0c             	pushl  0xc(%ebp)
 60c:	ff 75 08             	pushl  0x8(%ebp)
 60f:	e8 fc ff ff ff       	call   610 <vmmngr_mapPhysicalAddress+0x31>
 614:	83 c4 10             	add    $0x10,%esp
	((uint32_t*)(pagedir[virt >> 22] & ~0xfff))[virt << 10 >> 10 >> 12] = phys | flags;
 617:	8b 45 0c             	mov    0xc(%ebp),%eax
 61a:	25 ff ff 3f 00       	and    $0x3fffff,%eax
 61f:	c1 e8 0c             	shr    $0xc,%eax
 622:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 629:	8b 45 0c             	mov    0xc(%ebp),%eax
 62c:	c1 e8 16             	shr    $0x16,%eax
 62f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 636:	8b 45 f4             	mov    -0xc(%ebp),%eax
 639:	01 c8                	add    %ecx,%eax
 63b:	8b 00                	mov    (%eax),%eax
 63d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 642:	01 d0                	add    %edx,%eax
 644:	89 c2                	mov    %eax,%edx
 646:	8b 45 10             	mov    0x10(%ebp),%eax
 649:	0b 45 14             	or     0x14(%ebp),%eax
 64c:	89 02                	mov    %eax,(%edx)
}
 64e:	90                   	nop
 64f:	c9                   	leave  
 650:	c3                   	ret    

00000651 <vmmngr_unmapPageTable>:

void vmmngr_unmapPageTable(pdirectory* dir, uint32_t virt) {
 651:	55                   	push   %ebp
 652:	89 e5                	mov    %esp,%ebp
 654:	83 ec 18             	sub    $0x18,%esp
	pd_entry* pagedir = dir->m_entries;
 657:	8b 45 08             	mov    0x8(%ebp),%eax
 65a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pagedir[virt >> 22] != 0) {
 65d:	8b 45 0c             	mov    0xc(%ebp),%eax
 660:	c1 e8 16             	shr    $0x16,%eax
 663:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 66a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 66d:	01 d0                	add    %edx,%eax
 66f:	8b 00                	mov    (%eax),%eax
 671:	85 c0                	test   %eax,%eax
 673:	74 42                	je     6b7 <vmmngr_unmapPageTable+0x66>

		/* get mapped frame */
		void* frame = (void*)(pagedir[virt >> 22] & 0x7FFFF000);
 675:	8b 45 0c             	mov    0xc(%ebp),%eax
 678:	c1 e8 16             	shr    $0x16,%eax
 67b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 682:	8b 45 f4             	mov    -0xc(%ebp),%eax
 685:	01 d0                	add    %edx,%eax
 687:	8b 00                	mov    (%eax),%eax
 689:	25 00 f0 ff 7f       	and    $0x7ffff000,%eax
 68e:	89 45 f0             	mov    %eax,-0x10(%ebp)

		/* unmap frame */
		pmmngr_free_block(frame);
 691:	83 ec 0c             	sub    $0xc,%esp
 694:	ff 75 f0             	pushl  -0x10(%ebp)
 697:	e8 fc ff ff ff       	call   698 <vmmngr_unmapPageTable+0x47>
 69c:	83 c4 10             	add    $0x10,%esp
		pagedir[virt >> 22] = 0;
 69f:	8b 45 0c             	mov    0xc(%ebp),%eax
 6a2:	c1 e8 16             	shr    $0x16,%eax
 6a5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 6ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
 6af:	01 d0                	add    %edx,%eax
 6b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
}
 6b7:	90                   	nop
 6b8:	c9                   	leave  
 6b9:	c3                   	ret    

000006ba <vmmngr_unmapPhysicalAddress>:

void vmmngr_unmapPhysicalAddress(pdirectory* dir, uint32_t virt) {
 6ba:	55                   	push   %ebp
 6bb:	89 e5                	mov    %esp,%ebp
 6bd:	83 ec 18             	sub    $0x18,%esp
	/* note: we don't unallocate physical address here; callee does that */
	pd_entry* pagedir = dir->m_entries;
 6c0:	8b 45 08             	mov    0x8(%ebp),%eax
 6c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pagedir[virt >> 22] != 0)
 6c6:	8b 45 0c             	mov    0xc(%ebp),%eax
 6c9:	c1 e8 16             	shr    $0x16,%eax
 6cc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 6d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 6d6:	01 d0                	add    %edx,%eax
 6d8:	8b 00                	mov    (%eax),%eax
 6da:	85 c0                	test   %eax,%eax
 6dc:	74 11                	je     6ef <vmmngr_unmapPhysicalAddress+0x35>
		vmmngr_unmapPageTable(dir, virt);
 6de:	83 ec 08             	sub    $0x8,%esp
 6e1:	ff 75 0c             	pushl  0xc(%ebp)
 6e4:	ff 75 08             	pushl  0x8(%ebp)
 6e7:	e8 fc ff ff ff       	call   6e8 <vmmngr_unmapPhysicalAddress+0x2e>
 6ec:	83 c4 10             	add    $0x10,%esp
	//      ((uint32_t*) (pagedir[virt >> 22] & ~0xfff))[virt << 10 >> 10 >> 12] = 0;
}
 6ef:	90                   	nop
 6f0:	c9                   	leave  
 6f1:	c3                   	ret    

000006f2 <vmmngr_createAddressSpace>:

pdirectory* vmmngr_createAddressSpace() {
 6f2:	55                   	push   %ebp
 6f3:	89 e5                	mov    %esp,%ebp
 6f5:	83 ec 18             	sub    $0x18,%esp
	pdirectory* dir = 0;
 6f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	/* allocate page directory */
	dir = (pdirectory*)pmmngr_alloc_block();
 6ff:	e8 fc ff ff ff       	call   700 <vmmngr_createAddressSpace+0xe>
 704:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!dir)
 707:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 70b:	75 07                	jne    714 <vmmngr_createAddressSpace+0x22>
		return 0;
 70d:	b8 00 00 00 00       	mov    $0x0,%eax
 712:	eb 18                	jmp    72c <vmmngr_createAddressSpace+0x3a>

	/* clear memory (marks all page tables as not present) */
	memset(dir, 0, sizeof(pdirectory));
 714:	83 ec 04             	sub    $0x4,%esp
 717:	68 00 10 00 00       	push   $0x1000
 71c:	6a 00                	push   $0x0
 71e:	ff 75 f4             	pushl  -0xc(%ebp)
 721:	e8 fc ff ff ff       	call   722 <vmmngr_createAddressSpace+0x30>
 726:	83 c4 10             	add    $0x10,%esp
	return dir;
 729:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 72c:	c9                   	leave  
 72d:	c3                   	ret    

0000072e <vmmngr_getPhysicalAddress>:

void* vmmngr_getPhysicalAddress(pdirectory* dir, uint32_t virt) {
 72e:	55                   	push   %ebp
 72f:	89 e5                	mov    %esp,%ebp
 731:	83 ec 10             	sub    $0x10,%esp
	pd_entry* pagedir = dir->m_entries;
 734:	8b 45 08             	mov    0x8(%ebp),%eax
 737:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (pagedir[virt >> 22] == 0)
 73a:	8b 45 0c             	mov    0xc(%ebp),%eax
 73d:	c1 e8 16             	shr    $0x16,%eax
 740:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 747:	8b 45 fc             	mov    -0x4(%ebp),%eax
 74a:	01 d0                	add    %edx,%eax
 74c:	8b 00                	mov    (%eax),%eax
 74e:	85 c0                	test   %eax,%eax
 750:	75 07                	jne    759 <vmmngr_getPhysicalAddress+0x2b>
		return 0;
 752:	b8 00 00 00 00       	mov    $0x0,%eax
 757:	eb 2f                	jmp    788 <vmmngr_getPhysicalAddress+0x5a>
	return (void*)((uint32_t*)(pagedir[virt >> 22] & ~0xfff))[virt << 10 >> 10 >> 12];
 759:	8b 45 0c             	mov    0xc(%ebp),%eax
 75c:	25 ff ff 3f 00       	and    $0x3fffff,%eax
 761:	c1 e8 0c             	shr    $0xc,%eax
 764:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 76b:	8b 45 0c             	mov    0xc(%ebp),%eax
 76e:	c1 e8 16             	shr    $0x16,%eax
 771:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 778:	8b 45 fc             	mov    -0x4(%ebp),%eax
 77b:	01 c8                	add    %ecx,%eax
 77d:	8b 00                	mov    (%eax),%eax
 77f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 784:	01 d0                	add    %edx,%eax
 786:	8b 00                	mov    (%eax),%eax
 788:	c9                   	leave  
 789:	c3                   	ret    

vsprintf.o:     file format elf32-i386


Disassembly of section .text:

00000000 <is_flag>:

int parseCommand(const char* format, flags_t* flags, uint32_t* length);

static char _flags[] = "-+ #0";

int is_flag(char c){
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	88 45 e4             	mov    %al,-0x1c(%ebp)
	for(size_t p = 0; p < strlen(_flags);++p){
   c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  13:	eb 1b                	jmp    30 <is_flag+0x30>
		if(_flags[p] == c){
  15:	8b 45 f4             	mov    -0xc(%ebp),%eax
  18:	05 00 00 00 00       	add    $0x0,%eax
  1d:	0f b6 00             	movzbl (%eax),%eax
  20:	3a 45 e4             	cmp    -0x1c(%ebp),%al
  23:	75 07                	jne    2c <is_flag+0x2c>
			return 1;
  25:	b8 01 00 00 00       	mov    $0x1,%eax
  2a:	eb 1e                	jmp    4a <is_flag+0x4a>
int parseCommand(const char* format, flags_t* flags, uint32_t* length);

static char _flags[] = "-+ #0";

int is_flag(char c){
	for(size_t p = 0; p < strlen(_flags);++p){
  2c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  30:	83 ec 0c             	sub    $0xc,%esp
  33:	68 00 00 00 00       	push   $0x0
  38:	e8 fc ff ff ff       	call   39 <is_flag+0x39>
  3d:	83 c4 10             	add    $0x10,%esp
  40:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  43:	77 d0                	ja     15 <is_flag+0x15>
		if(_flags[p] == c){
			return 1;
		}
	}
	return 0;
  45:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4a:	c9                   	leave  
  4b:	c3                   	ret    

0000004c <is_specifier>:

static char _specifiers[] = "cdiosuxXp%";

int is_specifier(char c){
  4c:	55                   	push   %ebp
  4d:	89 e5                	mov    %esp,%ebp
  4f:	83 ec 28             	sub    $0x28,%esp
  52:	8b 45 08             	mov    0x8(%ebp),%eax
  55:	88 45 e4             	mov    %al,-0x1c(%ebp)

	for(size_t p = 0; p < strlen(_specifiers);++p){
  58:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  5f:	eb 1b                	jmp    7c <is_specifier+0x30>
		if(_specifiers[p] == c){
  61:	8b 45 f4             	mov    -0xc(%ebp),%eax
  64:	05 08 00 00 00       	add    $0x8,%eax
  69:	0f b6 00             	movzbl (%eax),%eax
  6c:	3a 45 e4             	cmp    -0x1c(%ebp),%al
  6f:	75 07                	jne    78 <is_specifier+0x2c>
			return 1;
  71:	b8 01 00 00 00       	mov    $0x1,%eax
  76:	eb 1e                	jmp    96 <is_specifier+0x4a>

static char _specifiers[] = "cdiosuxXp%";

int is_specifier(char c){

	for(size_t p = 0; p < strlen(_specifiers);++p){
  78:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  7c:	83 ec 0c             	sub    $0xc,%esp
  7f:	68 08 00 00 00       	push   $0x8
  84:	e8 fc ff ff ff       	call   85 <is_specifier+0x39>
  89:	83 c4 10             	add    $0x10,%esp
  8c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  8f:	77 d0                	ja     61 <is_specifier+0x15>
		if(_specifiers[p] == c){
			return 1;
		}
	}
	return 0;
  91:	b8 00 00 00 00       	mov    $0x0,%eax
}
  96:	c9                   	leave  
  97:	c3                   	ret    

00000098 <parseCommand>:

int parseCommand(const char* format, flags_t* flags, uint32_t* length){
  98:	55                   	push   %ebp
  99:	89 e5                	mov    %esp,%ebp
  9b:	83 ec 38             	sub    $0x38,%esp

	char* currentChar = format;
  9e:	8b 45 08             	mov    0x8(%ebp),%eax
  a1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// First parse all non-specifier chars

	// Check all flags
	while(is_flag(*currentChar)){
  a4:	eb 75                	jmp    11b <parseCommand+0x83>
		switch(*currentChar){
  a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  a9:	0f b6 00             	movzbl (%eax),%eax
  ac:	0f be c0             	movsbl %al,%eax
  af:	83 e8 20             	sub    $0x20,%eax
  b2:	83 f8 10             	cmp    $0x10,%eax
  b5:	77 53                	ja     10a <parseCommand+0x72>
  b7:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
  be:	ff e0                	jmp    *%eax
			case '-':{ 
				flags->left_justify = 1;
  c0:	8b 45 0c             	mov    0xc(%ebp),%eax
  c3:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  c7:	83 ca 01             	or     $0x1,%edx
  ca:	88 50 05             	mov    %dl,0x5(%eax)
				break;
  cd:	eb 3b                	jmp    10a <parseCommand+0x72>
			}
			case '+':{
				flags->force_sign = 1;
  cf:	8b 45 0c             	mov    0xc(%ebp),%eax
  d2:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  d6:	83 ca 02             	or     $0x2,%edx
  d9:	88 50 05             	mov    %dl,0x5(%eax)
				break;
  dc:	eb 2c                	jmp    10a <parseCommand+0x72>
			}
			case ' ':{
				flags->space = 1;
  de:	8b 45 0c             	mov    0xc(%ebp),%eax
  e1:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  e5:	83 ca 04             	or     $0x4,%edx
  e8:	88 50 05             	mov    %dl,0x5(%eax)
				break;
  eb:	eb 1d                	jmp    10a <parseCommand+0x72>
			}
			case '#':{
				flags->print_prefix = 1;
  ed:	8b 45 0c             	mov    0xc(%ebp),%eax
  f0:	0f b6 50 05          	movzbl 0x5(%eax),%edx
  f4:	83 ca 08             	or     $0x8,%edx
  f7:	88 50 05             	mov    %dl,0x5(%eax)
				break;
  fa:	eb 0e                	jmp    10a <parseCommand+0x72>
			}
			case '0':{
				flags->zero_pad = 1;
  fc:	8b 45 0c             	mov    0xc(%ebp),%eax
  ff:	0f b6 50 05          	movzbl 0x5(%eax),%edx
 103:	83 ca 10             	or     $0x10,%edx
 106:	88 50 05             	mov    %dl,0x5(%eax)
				break;
 109:	90                   	nop
			}
		}
		// Advance to the next char
		++currentChar;
 10a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
		++(*length);
 10e:	8b 45 10             	mov    0x10(%ebp),%eax
 111:	8b 00                	mov    (%eax),%eax
 113:	8d 50 01             	lea    0x1(%eax),%edx
 116:	8b 45 10             	mov    0x10(%ebp),%eax
 119:	89 10                	mov    %edx,(%eax)
	char* currentChar = format;

	// First parse all non-specifier chars

	// Check all flags
	while(is_flag(*currentChar)){
 11b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 11e:	0f b6 00             	movzbl (%eax),%eax
 121:	0f be c0             	movsbl %al,%eax
 124:	83 ec 0c             	sub    $0xc,%esp
 127:	50                   	push   %eax
 128:	e8 fc ff ff ff       	call   129 <parseCommand+0x91>
 12d:	83 c4 10             	add    $0x10,%esp
 130:	85 c0                	test   %eax,%eax
 132:	0f 85 6e ff ff ff    	jne    a6 <parseCommand+0xe>
		++currentChar;
		++(*length);
	}

	// Check width arg(if any)
	if(*currentChar == '*'){
 138:	8b 45 f4             	mov    -0xc(%ebp),%eax
 13b:	0f b6 00             	movzbl (%eax),%eax
 13e:	3c 2a                	cmp    $0x2a,%al
 140:	75 23                	jne    165 <parseCommand+0xcd>
		flags->width_as_arg = 1;
 142:	8b 45 0c             	mov    0xc(%ebp),%eax
 145:	0f b6 50 05          	movzbl 0x5(%eax),%edx
 149:	83 ca 20             	or     $0x20,%edx
 14c:	88 50 05             	mov    %dl,0x5(%eax)
		// Advance to the next char
		++currentChar;
 14f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
		++(*length);
 153:	8b 45 10             	mov    0x10(%ebp),%eax
 156:	8b 00                	mov    (%eax),%eax
 158:	8d 50 01             	lea    0x1(%eax),%edx
 15b:	8b 45 10             	mov    0x10(%ebp),%eax
 15e:	89 10                	mov    %edx,(%eax)
 160:	e9 be 00 00 00       	jmp    223 <parseCommand+0x18b>
	} else if (*currentChar == '('){
 165:	8b 45 f4             	mov    -0xc(%ebp),%eax
 168:	0f b6 00             	movzbl (%eax),%eax
 16b:	3c 28                	cmp    $0x28,%al
 16d:	0f 85 b0 00 00 00    	jne    223 <parseCommand+0x18b>
		// Advance
		++currentChar;
 173:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)

		// Allocate a buffer for the number to be stored
		char buf[32] = {0};
 177:	b9 00 00 00 00       	mov    $0x0,%ecx
 17c:	b8 20 00 00 00       	mov    $0x20,%eax
 181:	83 e0 fc             	and    $0xfffffffc,%eax
 184:	89 c2                	mov    %eax,%edx
 186:	b8 00 00 00 00       	mov    $0x0,%eax
 18b:	89 4c 05 d0          	mov    %ecx,-0x30(%ebp,%eax,1)
 18f:	83 c0 04             	add    $0x4,%eax
 192:	39 d0                	cmp    %edx,%eax
 194:	72 f5                	jb     18b <parseCommand+0xf3>
		size_t i = 0;
 196:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

		while(isdigit(*currentChar)){
 19d:	eb 19                	jmp    1b8 <parseCommand+0x120>
			buf[i++] = *(currentChar++);
 19f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 1a2:	8d 50 01             	lea    0x1(%eax),%edx
 1a5:	89 55 f0             	mov    %edx,-0x10(%ebp)
 1a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
 1ab:	8d 4a 01             	lea    0x1(%edx),%ecx
 1ae:	89 4d f4             	mov    %ecx,-0xc(%ebp)
 1b1:	0f b6 12             	movzbl (%edx),%edx
 1b4:	88 54 05 d0          	mov    %dl,-0x30(%ebp,%eax,1)

		// Allocate a buffer for the number to be stored
		char buf[32] = {0};
		size_t i = 0;

		while(isdigit(*currentChar)){
 1b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1bb:	0f b6 00             	movzbl (%eax),%eax
 1be:	3c 2f                	cmp    $0x2f,%al
 1c0:	7e 0a                	jle    1cc <parseCommand+0x134>
 1c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1c5:	0f b6 00             	movzbl (%eax),%eax
 1c8:	3c 39                	cmp    $0x39,%al
 1ca:	7e d3                	jle    19f <parseCommand+0x107>
			buf[i++] = *(currentChar++);
		} 

		// If the next character isn't a ')', the format is wrong. Return error.
		if(*currentChar != ')'){
 1cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1cf:	0f b6 00             	movzbl (%eax),%eax
 1d2:	3c 29                	cmp    $0x29,%al
 1d4:	74 0a                	je     1e0 <parseCommand+0x148>
			return 1;
 1d6:	b8 01 00 00 00       	mov    $0x1,%eax
 1db:	e9 81 00 00 00       	jmp    261 <parseCommand+0x1c9>
		}
		++currentChar;
 1e0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
		buf[i] = '\0'; // Make sure to null terminate
 1e4:	8d 55 d0             	lea    -0x30(%ebp),%edx
 1e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 1ea:	01 d0                	add    %edx,%eax
 1ec:	c6 00 00             	movb   $0x0,(%eax)

		flags->width = atoi(buf);
 1ef:	83 ec 0c             	sub    $0xc,%esp
 1f2:	8d 45 d0             	lea    -0x30(%ebp),%eax
 1f5:	50                   	push   %eax
 1f6:	e8 fc ff ff ff       	call   1f7 <parseCommand+0x15f>
 1fb:	83 c4 10             	add    $0x10,%esp
 1fe:	89 c2                	mov    %eax,%edx
 200:	8b 45 0c             	mov    0xc(%ebp),%eax
 203:	89 10                	mov    %edx,(%eax)

		(*length) += strlen(buf) + 2; // Length of buffer + '(' and ')'
 205:	83 ec 0c             	sub    $0xc,%esp
 208:	8d 45 d0             	lea    -0x30(%ebp),%eax
 20b:	50                   	push   %eax
 20c:	e8 fc ff ff ff       	call   20d <parseCommand+0x175>
 211:	83 c4 10             	add    $0x10,%esp
 214:	8d 50 02             	lea    0x2(%eax),%edx
 217:	8b 45 10             	mov    0x10(%ebp),%eax
 21a:	8b 00                	mov    (%eax),%eax
 21c:	01 c2                	add    %eax,%edx
 21e:	8b 45 10             	mov    0x10(%ebp),%eax
 221:	89 10                	mov    %edx,(%eax)
	}

	// Then get the specifier

	if(is_specifier(*currentChar)){
 223:	8b 45 f4             	mov    -0xc(%ebp),%eax
 226:	0f b6 00             	movzbl (%eax),%eax
 229:	0f be c0             	movsbl %al,%eax
 22c:	83 ec 0c             	sub    $0xc,%esp
 22f:	50                   	push   %eax
 230:	e8 fc ff ff ff       	call   231 <parseCommand+0x199>
 235:	83 c4 10             	add    $0x10,%esp
 238:	85 c0                	test   %eax,%eax
 23a:	74 20                	je     25c <parseCommand+0x1c4>
		flags->specifier = *currentChar;
 23c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 23f:	0f b6 10             	movzbl (%eax),%edx
 242:	8b 45 0c             	mov    0xc(%ebp),%eax
 245:	88 50 04             	mov    %dl,0x4(%eax)
		++(*length);
 248:	8b 45 10             	mov    0x10(%ebp),%eax
 24b:	8b 00                	mov    (%eax),%eax
 24d:	8d 50 01             	lea    0x1(%eax),%edx
 250:	8b 45 10             	mov    0x10(%ebp),%eax
 253:	89 10                	mov    %edx,(%eax)
		return 0;
 255:	b8 00 00 00 00       	mov    $0x0,%eax
 25a:	eb 05                	jmp    261 <parseCommand+0x1c9>
	}

	// Specifier is mandatory, return error
	return 1;
 25c:	b8 01 00 00 00       	mov    $0x1,%eax
}
 261:	c9                   	leave  
 262:	c3                   	ret    

00000263 <vsprintf>:
		{for(int i_pad = 0; i_pad < width_delta; ++i_pad) 	\
		{ 													\
			output_char(pad_char); 							\
		}}

int vsprintf(char* str, const char* format, va_list ap){
 263:	55                   	push   %ebp
 264:	89 e5                	mov    %esp,%ebp
 266:	53                   	push   %ebx
 267:	81 ec b4 00 00 00    	sub    $0xb4,%esp

	// Sanity check
	if(!str)
 26d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 271:	75 0a                	jne    27d <vsprintf+0x1a>
		return 0;
 273:	b8 00 00 00 00       	mov    $0x0,%eax
 278:	e9 80 09 00 00       	jmp    bfd <vsprintf+0x99a>

	if(!format)
 27d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 281:	75 0a                	jne    28d <vsprintf+0x2a>
		return 0;
 283:	b8 00 00 00 00       	mov    $0x0,%eax
 288:	e9 70 09 00 00       	jmp    bfd <vsprintf+0x99a>

	// Position in output buffer
	size_t loc = 0;
 28d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// Position in format string
	size_t i = 0;
 294:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	// Length of the format string
	const size_t format_length = strlen(format);
 29b:	83 ec 0c             	sub    $0xc,%esp
 29e:	ff 75 0c             	pushl  0xc(%ebp)
 2a1:	e8 fc ff ff ff       	call   2a2 <vsprintf+0x3f>
 2a6:	83 c4 10             	add    $0x10,%esp
 2a9:	89 45 a4             	mov    %eax,-0x5c(%ebp)

	// Loop until all characters in format buffer is parsed
	while(i < format_length){
 2ac:	e9 40 09 00 00       	jmp    bf1 <vsprintf+0x98e>
		char c = format[i++];
 2b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 2b4:	8d 50 01             	lea    0x1(%eax),%edx
 2b7:	89 55 f0             	mov    %edx,-0x10(%ebp)
 2ba:	8b 55 0c             	mov    0xc(%ebp),%edx
 2bd:	01 d0                	add    %edx,%eax
 2bf:	0f b6 00             	movzbl (%eax),%eax
 2c2:	88 45 a3             	mov    %al,-0x5d(%ebp)
		
		// Check if char is beginning of command
		if(c == '%'){
 2c5:	80 7d a3 25          	cmpb   $0x25,-0x5d(%ebp)
 2c9:	0f 85 0e 09 00 00    	jne    bdd <vsprintf+0x97a>
			// Initiate flags to 0(No flags are set as default)
			flags_t flags;
			memset(&flags, 0, sizeof(flags_t));
 2cf:	83 ec 04             	sub    $0x4,%esp
 2d2:	6a 08                	push   $0x8
 2d4:	6a 00                	push   $0x0
 2d6:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
 2dc:	50                   	push   %eax
 2dd:	e8 fc ff ff ff       	call   2de <vsprintf+0x7b>
 2e2:	83 c4 10             	add    $0x10,%esp

			// The length of the command in format buffer
			uint32_t length = 0;
 2e5:	c7 85 6c ff ff ff 00 	movl   $0x0,-0x94(%ebp)
 2ec:	00 00 00 

			// &format[i] gives the string beginning at the char after '%'
			if(parseCommand(&format[i], &flags, &length)){
 2ef:	8b 55 0c             	mov    0xc(%ebp),%edx
 2f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 2f5:	01 c2                	add    %eax,%edx
 2f7:	83 ec 04             	sub    $0x4,%esp
 2fa:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
 300:	50                   	push   %eax
 301:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
 307:	50                   	push   %eax
 308:	52                   	push   %edx
 309:	e8 fc ff ff ff       	call   30a <vsprintf+0xa7>
 30e:	83 c4 10             	add    $0x10,%esp
 311:	85 c0                	test   %eax,%eax
 313:	74 0a                	je     31f <vsprintf+0xbc>
				// We have an error in the format
				return 0;
 315:	b8 00 00 00 00       	mov    $0x0,%eax
 31a:	e9 de 08 00 00       	jmp    bfd <vsprintf+0x99a>
			}

			// Adjust for command length
			i += length;
 31f:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
 325:	01 45 f0             	add    %eax,-0x10(%ebp)

			// Calculate minimum width
			int width = 0;
 328:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			if(flags.width != 0){
 32f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 335:	85 c0                	test   %eax,%eax
 337:	74 0b                	je     344 <vsprintf+0xe1>
				width = flags.width;
 339:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 33f:	89 45 ec             	mov    %eax,-0x14(%ebp)
 342:	eb 1b                	jmp    35f <vsprintf+0xfc>
			} else if(flags.width_as_arg){
 344:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 34b:	83 e0 20             	and    $0x20,%eax
 34e:	84 c0                	test   %al,%al
 350:	74 0d                	je     35f <vsprintf+0xfc>
				width = va_arg(ap, int);
 352:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 356:	8b 45 10             	mov    0x10(%ebp),%eax
 359:	8b 40 fc             	mov    -0x4(%eax),%eax
 35c:	89 45 ec             	mov    %eax,-0x14(%ebp)
			}

			char pad_char = (flags.zero_pad) ? '0' : ' ';
 35f:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 366:	83 e0 10             	and    $0x10,%eax
 369:	84 c0                	test   %al,%al
 36b:	74 07                	je     374 <vsprintf+0x111>
 36d:	b8 30 00 00 00       	mov    $0x30,%eax
 372:	eb 05                	jmp    379 <vsprintf+0x116>
 374:	b8 20 00 00 00       	mov    $0x20,%eax
 379:	88 45 a2             	mov    %al,-0x5e(%ebp)

			switch(flags.specifier){
 37c:	0f b6 85 74 ff ff ff 	movzbl -0x8c(%ebp),%eax
 383:	0f be c0             	movsbl %al,%eax
 386:	83 e8 25             	sub    $0x25,%eax
 389:	83 f8 53             	cmp    $0x53,%eax
 38c:	0f 87 5f 08 00 00    	ja     bf1 <vsprintf+0x98e>
 392:	8b 04 85 4c 00 00 00 	mov    0x4c(,%eax,4),%eax
 399:	ff e0                	jmp    *%eax
				case 'd':
				case 'i':{
					// Fetch integer from stack
					int c = va_arg(ap, int);
 39b:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 39f:	8b 45 10             	mov    0x10(%ebp),%eax
 3a2:	8b 40 fc             	mov    -0x4(%eax),%eax
 3a5:	89 45 9c             	mov    %eax,-0x64(%ebp)

					// Allocate a small buffer
					char s[32] = {0};
 3a8:	b9 00 00 00 00       	mov    $0x0,%ecx
 3ad:	b8 20 00 00 00       	mov    $0x20,%eax
 3b2:	83 e0 fc             	and    $0xfffffffc,%eax
 3b5:	89 c2                	mov    %eax,%edx
 3b7:	b8 00 00 00 00       	mov    $0x0,%eax
 3bc:	89 8c 05 4c ff ff ff 	mov    %ecx,-0xb4(%ebp,%eax,1)
 3c3:	83 c0 04             	add    $0x4,%eax
 3c6:	39 d0                	cmp    %edx,%eax
 3c8:	72 f2                	jb     3bc <vsprintf+0x159>

					// Convert int to string
					itoa_s(c, 10, s);
 3ca:	83 ec 04             	sub    $0x4,%esp
 3cd:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 3d3:	50                   	push   %eax
 3d4:	6a 0a                	push   $0xa
 3d6:	ff 75 9c             	pushl  -0x64(%ebp)
 3d9:	e8 fc ff ff ff       	call   3da <vsprintf+0x177>
 3de:	83 c4 10             	add    $0x10,%esp

					// Calculate pad length
					int width_delta = width - strlen(s);
 3e1:	8b 5d ec             	mov    -0x14(%ebp),%ebx
 3e4:	83 ec 0c             	sub    $0xc,%esp
 3e7:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 3ed:	50                   	push   %eax
 3ee:	e8 fc ff ff ff       	call   3ef <vsprintf+0x18c>
 3f3:	83 c4 10             	add    $0x10,%esp
 3f6:	29 c3                	sub    %eax,%ebx
 3f8:	89 d8                	mov    %ebx,%eax
 3fa:	89 45 e8             	mov    %eax,-0x18(%ebp)

					// If int is pos or 0
					if(c >= 0){
 3fd:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
 401:	78 48                	js     44b <vsprintf+0x1e8>

						// Manually insert '+' if positive
						if(flags.force_sign){
 403:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 40a:	83 e0 02             	and    $0x2,%eax
 40d:	84 c0                	test   %al,%al
 40f:	74 17                	je     428 <vsprintf+0x1c5>
							output_char('+');
 411:	8b 45 f4             	mov    -0xc(%ebp),%eax
 414:	8d 50 01             	lea    0x1(%eax),%edx
 417:	89 55 f4             	mov    %edx,-0xc(%ebp)
 41a:	8b 55 08             	mov    0x8(%ebp),%edx
 41d:	01 d0                	add    %edx,%eax
 41f:	c6 00 2b             	movb   $0x2b,(%eax)
							width_delta -= 1;
 422:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
 426:	eb 23                	jmp    44b <vsprintf+0x1e8>

						// Insert ' ' so positive values will line up with 
						// negative values
						} else if(flags.space){
 428:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 42f:	83 e0 04             	and    $0x4,%eax
 432:	84 c0                	test   %al,%al
 434:	74 15                	je     44b <vsprintf+0x1e8>
							output_char(' ');
 436:	8b 45 f4             	mov    -0xc(%ebp),%eax
 439:	8d 50 01             	lea    0x1(%eax),%edx
 43c:	89 55 f4             	mov    %edx,-0xc(%ebp)
 43f:	8b 55 08             	mov    0x8(%ebp),%edx
 442:	01 d0                	add    %edx,%eax
 444:	c6 00 20             	movb   $0x20,(%eax)
							width_delta -= 1;
 447:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
						}
					}

					if(flags.left_justify){
 44b:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 452:	83 e0 01             	and    $0x1,%eax
 455:	84 c0                	test   %al,%al
 457:	74 5e                	je     4b7 <vsprintf+0x254>
						output_string(s);
 459:	8b 55 08             	mov    0x8(%ebp),%edx
 45c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 45f:	01 c2                	add    %eax,%edx
 461:	83 ec 08             	sub    $0x8,%esp
 464:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 46a:	50                   	push   %eax
 46b:	52                   	push   %edx
 46c:	e8 fc ff ff ff       	call   46d <vsprintf+0x20a>
 471:	83 c4 10             	add    $0x10,%esp
 474:	83 ec 0c             	sub    $0xc,%esp
 477:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 47d:	50                   	push   %eax
 47e:	e8 fc ff ff ff       	call   47f <vsprintf+0x21c>
 483:	83 c4 10             	add    $0x10,%esp
 486:	01 45 f4             	add    %eax,-0xc(%ebp)
						PAD(width_delta, pad_char);
 489:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 490:	eb 18                	jmp    4aa <vsprintf+0x247>
 492:	8b 45 f4             	mov    -0xc(%ebp),%eax
 495:	8d 50 01             	lea    0x1(%eax),%edx
 498:	89 55 f4             	mov    %edx,-0xc(%ebp)
 49b:	8b 55 08             	mov    0x8(%ebp),%edx
 49e:	01 c2                	add    %eax,%edx
 4a0:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 4a4:	88 02                	mov    %al,(%edx)
 4a6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
 4aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 4ad:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 4b0:	7c e0                	jl     492 <vsprintf+0x22f>
					} else {
						PAD(width_delta, pad_char);
						output_string(s);
					}
					
					break;
 4b2:	e9 3a 07 00 00       	jmp    bf1 <vsprintf+0x98e>

					if(flags.left_justify){
						output_string(s);
						PAD(width_delta, pad_char);
					} else {
						PAD(width_delta, pad_char);
 4b7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
 4be:	eb 18                	jmp    4d8 <vsprintf+0x275>
 4c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 4c3:	8d 50 01             	lea    0x1(%eax),%edx
 4c6:	89 55 f4             	mov    %edx,-0xc(%ebp)
 4c9:	8b 55 08             	mov    0x8(%ebp),%edx
 4cc:	01 c2                	add    %eax,%edx
 4ce:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 4d2:	88 02                	mov    %al,(%edx)
 4d4:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 4d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 4db:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 4de:	7c e0                	jl     4c0 <vsprintf+0x25d>
						output_string(s);
 4e0:	8b 55 08             	mov    0x8(%ebp),%edx
 4e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 4e6:	01 c2                	add    %eax,%edx
 4e8:	83 ec 08             	sub    $0x8,%esp
 4eb:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 4f1:	50                   	push   %eax
 4f2:	52                   	push   %edx
 4f3:	e8 fc ff ff ff       	call   4f4 <vsprintf+0x291>
 4f8:	83 c4 10             	add    $0x10,%esp
 4fb:	83 ec 0c             	sub    $0xc,%esp
 4fe:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 504:	50                   	push   %eax
 505:	e8 fc ff ff ff       	call   506 <vsprintf+0x2a3>
 50a:	83 c4 10             	add    $0x10,%esp
 50d:	01 45 f4             	add    %eax,-0xc(%ebp)
					}
					
					break;
 510:	90                   	nop
 511:	e9 db 06 00 00       	jmp    bf1 <vsprintf+0x98e>
				}

				case 'o':{
					// Fetch integer from stack
					int c = va_arg(ap, int);
 516:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 51a:	8b 45 10             	mov    0x10(%ebp),%eax
 51d:	8b 40 fc             	mov    -0x4(%eax),%eax
 520:	89 45 98             	mov    %eax,-0x68(%ebp)

					// Allocate a small buffer
					char s[32] = {0};
 523:	b9 00 00 00 00       	mov    $0x0,%ecx
 528:	b8 20 00 00 00       	mov    $0x20,%eax
 52d:	83 e0 fc             	and    $0xfffffffc,%eax
 530:	89 c2                	mov    %eax,%edx
 532:	b8 00 00 00 00       	mov    $0x0,%eax
 537:	89 8c 05 4c ff ff ff 	mov    %ecx,-0xb4(%ebp,%eax,1)
 53e:	83 c0 04             	add    $0x4,%eax
 541:	39 d0                	cmp    %edx,%eax
 543:	72 f2                	jb     537 <vsprintf+0x2d4>

					
					// Convert int to string
					itoa_s(c, 8, s);
 545:	83 ec 04             	sub    $0x4,%esp
 548:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 54e:	50                   	push   %eax
 54f:	6a 08                	push   $0x8
 551:	ff 75 98             	pushl  -0x68(%ebp)
 554:	e8 fc ff ff ff       	call   555 <vsprintf+0x2f2>
 559:	83 c4 10             	add    $0x10,%esp
					

				
					// Calculate pad length
					int width_delta = width - strlen(s);
 55c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
 55f:	83 ec 0c             	sub    $0xc,%esp
 562:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 568:	50                   	push   %eax
 569:	e8 fc ff ff ff       	call   56a <vsprintf+0x307>
 56e:	83 c4 10             	add    $0x10,%esp
 571:	29 c3                	sub    %eax,%ebx
 573:	89 d8                	mov    %ebx,%eax
 575:	89 45 dc             	mov    %eax,-0x24(%ebp)

					// If int is pos or 0
					if(c >= 0){
 578:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
 57c:	78 48                	js     5c6 <vsprintf+0x363>
						
						// Manually insert '+' if positive
						if(flags.force_sign){
 57e:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 585:	83 e0 02             	and    $0x2,%eax
 588:	84 c0                	test   %al,%al
 58a:	74 17                	je     5a3 <vsprintf+0x340>
							output_char('+');
 58c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 58f:	8d 50 01             	lea    0x1(%eax),%edx
 592:	89 55 f4             	mov    %edx,-0xc(%ebp)
 595:	8b 55 08             	mov    0x8(%ebp),%edx
 598:	01 d0                	add    %edx,%eax
 59a:	c6 00 2b             	movb   $0x2b,(%eax)
							width_delta -= 1;
 59d:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
 5a1:	eb 23                	jmp    5c6 <vsprintf+0x363>

						// Insert ' ' so positive values will line up with 
						// negative values
						} else if(flags.space){
 5a3:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 5aa:	83 e0 04             	and    $0x4,%eax
 5ad:	84 c0                	test   %al,%al
 5af:	74 15                	je     5c6 <vsprintf+0x363>
							output_char(' ');
 5b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 5b4:	8d 50 01             	lea    0x1(%eax),%edx
 5b7:	89 55 f4             	mov    %edx,-0xc(%ebp)
 5ba:	8b 55 08             	mov    0x8(%ebp),%edx
 5bd:	01 d0                	add    %edx,%eax
 5bf:	c6 00 20             	movb   $0x20,(%eax)
							width_delta -= 1;
 5c2:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
						}
					}

					if(flags.print_prefix){
 5c6:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 5cd:	83 e0 08             	and    $0x8,%eax
 5d0:	84 c0                	test   %al,%al
 5d2:	74 30                	je     604 <vsprintf+0x3a1>
						output_string("0");
 5d4:	8b 55 08             	mov    0x8(%ebp),%edx
 5d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 5da:	01 d0                	add    %edx,%eax
 5dc:	83 ec 08             	sub    $0x8,%esp
 5df:	68 44 00 00 00       	push   $0x44
 5e4:	50                   	push   %eax
 5e5:	e8 fc ff ff ff       	call   5e6 <vsprintf+0x383>
 5ea:	83 c4 10             	add    $0x10,%esp
 5ed:	83 ec 0c             	sub    $0xc,%esp
 5f0:	68 44 00 00 00       	push   $0x44
 5f5:	e8 fc ff ff ff       	call   5f6 <vsprintf+0x393>
 5fa:	83 c4 10             	add    $0x10,%esp
 5fd:	01 45 f4             	add    %eax,-0xc(%ebp)
						width_delta -= 1;
 600:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
					}

					if(flags.left_justify){
 604:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 60b:	83 e0 01             	and    $0x1,%eax
 60e:	84 c0                	test   %al,%al
 610:	74 5e                	je     670 <vsprintf+0x40d>
						output_string(s);
 612:	8b 55 08             	mov    0x8(%ebp),%edx
 615:	8b 45 f4             	mov    -0xc(%ebp),%eax
 618:	01 c2                	add    %eax,%edx
 61a:	83 ec 08             	sub    $0x8,%esp
 61d:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 623:	50                   	push   %eax
 624:	52                   	push   %edx
 625:	e8 fc ff ff ff       	call   626 <vsprintf+0x3c3>
 62a:	83 c4 10             	add    $0x10,%esp
 62d:	83 ec 0c             	sub    $0xc,%esp
 630:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 636:	50                   	push   %eax
 637:	e8 fc ff ff ff       	call   638 <vsprintf+0x3d5>
 63c:	83 c4 10             	add    $0x10,%esp
 63f:	01 45 f4             	add    %eax,-0xc(%ebp)
						PAD(width_delta, pad_char);
 642:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
 649:	eb 18                	jmp    663 <vsprintf+0x400>
 64b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 64e:	8d 50 01             	lea    0x1(%eax),%edx
 651:	89 55 f4             	mov    %edx,-0xc(%ebp)
 654:	8b 55 08             	mov    0x8(%ebp),%edx
 657:	01 c2                	add    %eax,%edx
 659:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 65d:	88 02                	mov    %al,(%edx)
 65f:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
 663:	8b 45 d8             	mov    -0x28(%ebp),%eax
 666:	3b 45 dc             	cmp    -0x24(%ebp),%eax
 669:	7c e0                	jl     64b <vsprintf+0x3e8>
					} else {
						PAD(width_delta, pad_char);
						output_string(s);
					}
					
					break;
 66b:	e9 81 05 00 00       	jmp    bf1 <vsprintf+0x98e>

					if(flags.left_justify){
						output_string(s);
						PAD(width_delta, pad_char);
					} else {
						PAD(width_delta, pad_char);
 670:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 677:	eb 18                	jmp    691 <vsprintf+0x42e>
 679:	8b 45 f4             	mov    -0xc(%ebp),%eax
 67c:	8d 50 01             	lea    0x1(%eax),%edx
 67f:	89 55 f4             	mov    %edx,-0xc(%ebp)
 682:	8b 55 08             	mov    0x8(%ebp),%edx
 685:	01 c2                	add    %eax,%edx
 687:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 68b:	88 02                	mov    %al,(%edx)
 68d:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
 691:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 694:	3b 45 dc             	cmp    -0x24(%ebp),%eax
 697:	7c e0                	jl     679 <vsprintf+0x416>
						output_string(s);
 699:	8b 55 08             	mov    0x8(%ebp),%edx
 69c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 69f:	01 c2                	add    %eax,%edx
 6a1:	83 ec 08             	sub    $0x8,%esp
 6a4:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 6aa:	50                   	push   %eax
 6ab:	52                   	push   %edx
 6ac:	e8 fc ff ff ff       	call   6ad <vsprintf+0x44a>
 6b1:	83 c4 10             	add    $0x10,%esp
 6b4:	83 ec 0c             	sub    $0xc,%esp
 6b7:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 6bd:	50                   	push   %eax
 6be:	e8 fc ff ff ff       	call   6bf <vsprintf+0x45c>
 6c3:	83 c4 10             	add    $0x10,%esp
 6c6:	01 45 f4             	add    %eax,-0xc(%ebp)
					}
					
					break;
 6c9:	90                   	nop
 6ca:	e9 22 05 00 00       	jmp    bf1 <vsprintf+0x98e>
				}

				case 's':{
					// Fetch string pointer from stack
					char* c = (char*) va_arg(ap, char*);
 6cf:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 6d3:	8b 45 10             	mov    0x10(%ebp),%eax
 6d6:	8b 40 fc             	mov    -0x4(%eax),%eax
 6d9:	89 45 94             	mov    %eax,-0x6c(%ebp)

					// Allocate a small buffer
					// TODO: Increase if needed
					char s[32]={0};
 6dc:	b9 00 00 00 00       	mov    $0x0,%ecx
 6e1:	b8 20 00 00 00       	mov    $0x20,%eax
 6e6:	83 e0 fc             	and    $0xfffffffc,%eax
 6e9:	89 c2                	mov    %eax,%edx
 6eb:	b8 00 00 00 00       	mov    $0x0,%eax
 6f0:	89 8c 05 4c ff ff ff 	mov    %ecx,-0xb4(%ebp,%eax,1)
 6f7:	83 c0 04             	add    $0x4,%eax
 6fa:	39 d0                	cmp    %edx,%eax
 6fc:	72 f2                	jb     6f0 <vsprintf+0x48d>

					// Copy string to buffer
					strcpy(s, (const char*)c);
 6fe:	83 ec 08             	sub    $0x8,%esp
 701:	ff 75 94             	pushl  -0x6c(%ebp)
 704:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 70a:	50                   	push   %eax
 70b:	e8 fc ff ff ff       	call   70c <vsprintf+0x4a9>
 710:	83 c4 10             	add    $0x10,%esp

					// Calculate pad length
					int width_delta = width - strlen(s);
 713:	8b 5d ec             	mov    -0x14(%ebp),%ebx
 716:	83 ec 0c             	sub    $0xc,%esp
 719:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 71f:	50                   	push   %eax
 720:	e8 fc ff ff ff       	call   721 <vsprintf+0x4be>
 725:	83 c4 10             	add    $0x10,%esp
 728:	29 c3                	sub    %eax,%ebx
 72a:	89 d8                	mov    %ebx,%eax
 72c:	89 45 90             	mov    %eax,-0x70(%ebp)


					if(flags.left_justify){
 72f:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 736:	83 e0 01             	and    $0x1,%eax
 739:	84 c0                	test   %al,%al
 73b:	74 5e                	je     79b <vsprintf+0x538>
						output_string(s);
 73d:	8b 55 08             	mov    0x8(%ebp),%edx
 740:	8b 45 f4             	mov    -0xc(%ebp),%eax
 743:	01 c2                	add    %eax,%edx
 745:	83 ec 08             	sub    $0x8,%esp
 748:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 74e:	50                   	push   %eax
 74f:	52                   	push   %edx
 750:	e8 fc ff ff ff       	call   751 <vsprintf+0x4ee>
 755:	83 c4 10             	add    $0x10,%esp
 758:	83 ec 0c             	sub    $0xc,%esp
 75b:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 761:	50                   	push   %eax
 762:	e8 fc ff ff ff       	call   763 <vsprintf+0x500>
 767:	83 c4 10             	add    $0x10,%esp
 76a:	01 45 f4             	add    %eax,-0xc(%ebp)
						PAD(width_delta, pad_char);
 76d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
 774:	eb 18                	jmp    78e <vsprintf+0x52b>
 776:	8b 45 f4             	mov    -0xc(%ebp),%eax
 779:	8d 50 01             	lea    0x1(%eax),%edx
 77c:	89 55 f4             	mov    %edx,-0xc(%ebp)
 77f:	8b 55 08             	mov    0x8(%ebp),%edx
 782:	01 c2                	add    %eax,%edx
 784:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 788:	88 02                	mov    %al,(%edx)
 78a:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
 78e:	8b 45 d0             	mov    -0x30(%ebp),%eax
 791:	3b 45 90             	cmp    -0x70(%ebp),%eax
 794:	7c e0                	jl     776 <vsprintf+0x513>
					} else {
						PAD(width_delta, pad_char);
						output_string(s);
					}
					
					break;
 796:	e9 56 04 00 00       	jmp    bf1 <vsprintf+0x98e>

					if(flags.left_justify){
						output_string(s);
						PAD(width_delta, pad_char);
					} else {
						PAD(width_delta, pad_char);
 79b:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
 7a2:	eb 18                	jmp    7bc <vsprintf+0x559>
 7a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 7a7:	8d 50 01             	lea    0x1(%eax),%edx
 7aa:	89 55 f4             	mov    %edx,-0xc(%ebp)
 7ad:	8b 55 08             	mov    0x8(%ebp),%edx
 7b0:	01 c2                	add    %eax,%edx
 7b2:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 7b6:	88 02                	mov    %al,(%edx)
 7b8:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
 7bc:	8b 45 cc             	mov    -0x34(%ebp),%eax
 7bf:	3b 45 90             	cmp    -0x70(%ebp),%eax
 7c2:	7c e0                	jl     7a4 <vsprintf+0x541>
						output_string(s);
 7c4:	8b 55 08             	mov    0x8(%ebp),%edx
 7c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 7ca:	01 c2                	add    %eax,%edx
 7cc:	83 ec 08             	sub    $0x8,%esp
 7cf:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 7d5:	50                   	push   %eax
 7d6:	52                   	push   %edx
 7d7:	e8 fc ff ff ff       	call   7d8 <vsprintf+0x575>
 7dc:	83 c4 10             	add    $0x10,%esp
 7df:	83 ec 0c             	sub    $0xc,%esp
 7e2:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 7e8:	50                   	push   %eax
 7e9:	e8 fc ff ff ff       	call   7ea <vsprintf+0x587>
 7ee:	83 c4 10             	add    $0x10,%esp
 7f1:	01 45 f4             	add    %eax,-0xc(%ebp)
					}
					
					break;
 7f4:	90                   	nop
 7f5:	e9 f7 03 00 00       	jmp    bf1 <vsprintf+0x98e>
				}

				case 'u':{
					// Fetch integer from stack
					unsigned int c = va_arg(ap, unsigned int);
 7fa:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 7fe:	8b 45 10             	mov    0x10(%ebp),%eax
 801:	8b 40 fc             	mov    -0x4(%eax),%eax
 804:	89 45 8c             	mov    %eax,-0x74(%ebp)

					// Allocate a small buffer
					char s[32] = {0};
 807:	b9 00 00 00 00       	mov    $0x0,%ecx
 80c:	b8 20 00 00 00       	mov    $0x20,%eax
 811:	83 e0 fc             	and    $0xfffffffc,%eax
 814:	89 c2                	mov    %eax,%edx
 816:	b8 00 00 00 00       	mov    $0x0,%eax
 81b:	89 8c 05 4c ff ff ff 	mov    %ecx,-0xb4(%ebp,%eax,1)
 822:	83 c0 04             	add    $0x4,%eax
 825:	39 d0                	cmp    %edx,%eax
 827:	72 f2                	jb     81b <vsprintf+0x5b8>

					// Convert int to string
					itoa(c, 10, s);
 829:	83 ec 04             	sub    $0x4,%esp
 82c:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 832:	50                   	push   %eax
 833:	6a 0a                	push   $0xa
 835:	ff 75 8c             	pushl  -0x74(%ebp)
 838:	e8 fc ff ff ff       	call   839 <vsprintf+0x5d6>
 83d:	83 c4 10             	add    $0x10,%esp

					// Calculate pad length
					int width_delta = width - strlen(s);
 840:	8b 5d ec             	mov    -0x14(%ebp),%ebx
 843:	83 ec 0c             	sub    $0xc,%esp
 846:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 84c:	50                   	push   %eax
 84d:	e8 fc ff ff ff       	call   84e <vsprintf+0x5eb>
 852:	83 c4 10             	add    $0x10,%esp
 855:	29 c3                	sub    %eax,%ebx
 857:	89 d8                	mov    %ebx,%eax
 859:	89 45 88             	mov    %eax,-0x78(%ebp)


					if(flags.left_justify){
 85c:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 863:	83 e0 01             	and    $0x1,%eax
 866:	84 c0                	test   %al,%al
 868:	74 5e                	je     8c8 <vsprintf+0x665>
						output_string(s);
 86a:	8b 55 08             	mov    0x8(%ebp),%edx
 86d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 870:	01 c2                	add    %eax,%edx
 872:	83 ec 08             	sub    $0x8,%esp
 875:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 87b:	50                   	push   %eax
 87c:	52                   	push   %edx
 87d:	e8 fc ff ff ff       	call   87e <vsprintf+0x61b>
 882:	83 c4 10             	add    $0x10,%esp
 885:	83 ec 0c             	sub    $0xc,%esp
 888:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 88e:	50                   	push   %eax
 88f:	e8 fc ff ff ff       	call   890 <vsprintf+0x62d>
 894:	83 c4 10             	add    $0x10,%esp
 897:	01 45 f4             	add    %eax,-0xc(%ebp)
						PAD(width_delta, pad_char);
 89a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
 8a1:	eb 18                	jmp    8bb <vsprintf+0x658>
 8a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8a6:	8d 50 01             	lea    0x1(%eax),%edx
 8a9:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8ac:	8b 55 08             	mov    0x8(%ebp),%edx
 8af:	01 c2                	add    %eax,%edx
 8b1:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 8b5:	88 02                	mov    %al,(%edx)
 8b7:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
 8bb:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8be:	3b 45 88             	cmp    -0x78(%ebp),%eax
 8c1:	7c e0                	jl     8a3 <vsprintf+0x640>
					} else {
						PAD(width_delta, pad_char);
						output_string(s);
					}
					
					break;
 8c3:	e9 29 03 00 00       	jmp    bf1 <vsprintf+0x98e>

					if(flags.left_justify){
						output_string(s);
						PAD(width_delta, pad_char);
					} else {
						PAD(width_delta, pad_char);
 8c8:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
 8cf:	eb 18                	jmp    8e9 <vsprintf+0x686>
 8d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8d4:	8d 50 01             	lea    0x1(%eax),%edx
 8d7:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8da:	8b 55 08             	mov    0x8(%ebp),%edx
 8dd:	01 c2                	add    %eax,%edx
 8df:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 8e3:	88 02                	mov    %al,(%edx)
 8e5:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
 8e9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8ec:	3b 45 88             	cmp    -0x78(%ebp),%eax
 8ef:	7c e0                	jl     8d1 <vsprintf+0x66e>
						output_string(s);
 8f1:	8b 55 08             	mov    0x8(%ebp),%edx
 8f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8f7:	01 c2                	add    %eax,%edx
 8f9:	83 ec 08             	sub    $0x8,%esp
 8fc:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 902:	50                   	push   %eax
 903:	52                   	push   %edx
 904:	e8 fc ff ff ff       	call   905 <vsprintf+0x6a2>
 909:	83 c4 10             	add    $0x10,%esp
 90c:	83 ec 0c             	sub    $0xc,%esp
 90f:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 915:	50                   	push   %eax
 916:	e8 fc ff ff ff       	call   917 <vsprintf+0x6b4>
 91b:	83 c4 10             	add    $0x10,%esp
 91e:	01 45 f4             	add    %eax,-0xc(%ebp)
					}
					
					break;
 921:	90                   	nop
 922:	e9 ca 02 00 00       	jmp    bf1 <vsprintf+0x98e>

				case 'p': // A minor hack
				case 'x':
				case 'X':{
					// Fetch integer from stack
					unsigned int c = va_arg(ap, unsigned int);
 927:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 92b:	8b 45 10             	mov    0x10(%ebp),%eax
 92e:	8b 40 fc             	mov    -0x4(%eax),%eax
 931:	89 45 84             	mov    %eax,-0x7c(%ebp)

					// Allocate a small buffer
					char s[32] = {0};
 934:	b9 00 00 00 00       	mov    $0x0,%ecx
 939:	b8 20 00 00 00       	mov    $0x20,%eax
 93e:	83 e0 fc             	and    $0xfffffffc,%eax
 941:	89 c2                	mov    %eax,%edx
 943:	b8 00 00 00 00       	mov    $0x0,%eax
 948:	89 8c 05 4c ff ff ff 	mov    %ecx,-0xb4(%ebp,%eax,1)
 94f:	83 c0 04             	add    $0x4,%eax
 952:	39 d0                	cmp    %edx,%eax
 954:	72 f2                	jb     948 <vsprintf+0x6e5>

					itoa(c, 16, s);
 956:	83 ec 04             	sub    $0x4,%esp
 959:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 95f:	50                   	push   %eax
 960:	6a 10                	push   $0x10
 962:	ff 75 84             	pushl  -0x7c(%ebp)
 965:	e8 fc ff ff ff       	call   966 <vsprintf+0x703>
 96a:	83 c4 10             	add    $0x10,%esp

					// Calculate pad length
					int width_delta = width - strlen(s);
 96d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
 970:	83 ec 0c             	sub    $0xc,%esp
 973:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 979:	50                   	push   %eax
 97a:	e8 fc ff ff ff       	call   97b <vsprintf+0x718>
 97f:	83 c4 10             	add    $0x10,%esp
 982:	29 c3                	sub    %eax,%ebx
 984:	89 d8                	mov    %ebx,%eax
 986:	89 45 c0             	mov    %eax,-0x40(%ebp)

					if(flags.print_prefix){
 989:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 990:	83 e0 08             	and    $0x8,%eax
 993:	84 c0                	test   %al,%al
 995:	74 30                	je     9c7 <vsprintf+0x764>
						output_string("0x");
 997:	8b 55 08             	mov    0x8(%ebp),%edx
 99a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 99d:	01 d0                	add    %edx,%eax
 99f:	83 ec 08             	sub    $0x8,%esp
 9a2:	68 46 00 00 00       	push   $0x46
 9a7:	50                   	push   %eax
 9a8:	e8 fc ff ff ff       	call   9a9 <vsprintf+0x746>
 9ad:	83 c4 10             	add    $0x10,%esp
 9b0:	83 ec 0c             	sub    $0xc,%esp
 9b3:	68 46 00 00 00       	push   $0x46
 9b8:	e8 fc ff ff ff       	call   9b9 <vsprintf+0x756>
 9bd:	83 c4 10             	add    $0x10,%esp
 9c0:	01 45 f4             	add    %eax,-0xc(%ebp)
						width_delta -= 2;
 9c3:	83 6d c0 02          	subl   $0x2,-0x40(%ebp)
					}

					if(flags.left_justify){
 9c7:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 9ce:	83 e0 01             	and    $0x1,%eax
 9d1:	84 c0                	test   %al,%al
 9d3:	74 5e                	je     a33 <vsprintf+0x7d0>
						output_string(s);
 9d5:	8b 55 08             	mov    0x8(%ebp),%edx
 9d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 9db:	01 c2                	add    %eax,%edx
 9dd:	83 ec 08             	sub    $0x8,%esp
 9e0:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 9e6:	50                   	push   %eax
 9e7:	52                   	push   %edx
 9e8:	e8 fc ff ff ff       	call   9e9 <vsprintf+0x786>
 9ed:	83 c4 10             	add    $0x10,%esp
 9f0:	83 ec 0c             	sub    $0xc,%esp
 9f3:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 9f9:	50                   	push   %eax
 9fa:	e8 fc ff ff ff       	call   9fb <vsprintf+0x798>
 9ff:	83 c4 10             	add    $0x10,%esp
 a02:	01 45 f4             	add    %eax,-0xc(%ebp)
						PAD(width_delta, pad_char);
 a05:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
 a0c:	eb 18                	jmp    a26 <vsprintf+0x7c3>
 a0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 a11:	8d 50 01             	lea    0x1(%eax),%edx
 a14:	89 55 f4             	mov    %edx,-0xc(%ebp)
 a17:	8b 55 08             	mov    0x8(%ebp),%edx
 a1a:	01 c2                	add    %eax,%edx
 a1c:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 a20:	88 02                	mov    %al,(%edx)
 a22:	83 45 bc 01          	addl   $0x1,-0x44(%ebp)
 a26:	8b 45 bc             	mov    -0x44(%ebp),%eax
 a29:	3b 45 c0             	cmp    -0x40(%ebp),%eax
 a2c:	7c e0                	jl     a0e <vsprintf+0x7ab>
					} else {
						PAD(width_delta, pad_char);
						output_string(s);
					}
					
					break;
 a2e:	e9 be 01 00 00       	jmp    bf1 <vsprintf+0x98e>

					if(flags.left_justify){
						output_string(s);
						PAD(width_delta, pad_char);
					} else {
						PAD(width_delta, pad_char);
 a33:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 a3a:	eb 18                	jmp    a54 <vsprintf+0x7f1>
 a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 a3f:	8d 50 01             	lea    0x1(%eax),%edx
 a42:	89 55 f4             	mov    %edx,-0xc(%ebp)
 a45:	8b 55 08             	mov    0x8(%ebp),%edx
 a48:	01 c2                	add    %eax,%edx
 a4a:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 a4e:	88 02                	mov    %al,(%edx)
 a50:	83 45 b8 01          	addl   $0x1,-0x48(%ebp)
 a54:	8b 45 b8             	mov    -0x48(%ebp),%eax
 a57:	3b 45 c0             	cmp    -0x40(%ebp),%eax
 a5a:	7c e0                	jl     a3c <vsprintf+0x7d9>
						output_string(s);
 a5c:	8b 55 08             	mov    0x8(%ebp),%edx
 a5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 a62:	01 c2                	add    %eax,%edx
 a64:	83 ec 08             	sub    $0x8,%esp
 a67:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 a6d:	50                   	push   %eax
 a6e:	52                   	push   %edx
 a6f:	e8 fc ff ff ff       	call   a70 <vsprintf+0x80d>
 a74:	83 c4 10             	add    $0x10,%esp
 a77:	83 ec 0c             	sub    $0xc,%esp
 a7a:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 a80:	50                   	push   %eax
 a81:	e8 fc ff ff ff       	call   a82 <vsprintf+0x81f>
 a86:	83 c4 10             	add    $0x10,%esp
 a89:	01 45 f4             	add    %eax,-0xc(%ebp)
					}
					
					break;
 a8c:	90                   	nop
 a8d:	e9 5f 01 00 00       	jmp    bf1 <vsprintf+0x98e>
				}

				case 'c':{

					char c = va_arg(ap, char);
 a92:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 a96:	8b 45 10             	mov    0x10(%ebp),%eax
 a99:	0f b6 40 fc          	movzbl -0x4(%eax),%eax
 a9d:	88 45 83             	mov    %al,-0x7d(%ebp)

					int width_delta = width - 1;
 aa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
 aa3:	83 e8 01             	sub    $0x1,%eax
 aa6:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
					
					if(flags.left_justify){
 aac:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 ab3:	83 e0 01             	and    $0x1,%eax
 ab6:	84 c0                	test   %al,%al
 ab8:	74 45                	je     aff <vsprintf+0x89c>
						output_char(c);
 aba:	8b 45 f4             	mov    -0xc(%ebp),%eax
 abd:	8d 50 01             	lea    0x1(%eax),%edx
 ac0:	89 55 f4             	mov    %edx,-0xc(%ebp)
 ac3:	8b 55 08             	mov    0x8(%ebp),%edx
 ac6:	01 c2                	add    %eax,%edx
 ac8:	0f b6 45 83          	movzbl -0x7d(%ebp),%eax
 acc:	88 02                	mov    %al,(%edx)
						PAD(width_delta, pad_char);
 ace:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
 ad5:	eb 18                	jmp    aef <vsprintf+0x88c>
 ad7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 ada:	8d 50 01             	lea    0x1(%eax),%edx
 add:	89 55 f4             	mov    %edx,-0xc(%ebp)
 ae0:	8b 55 08             	mov    0x8(%ebp),%edx
 ae3:	01 c2                	add    %eax,%edx
 ae5:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 ae9:	88 02                	mov    %al,(%edx)
 aeb:	83 45 b4 01          	addl   $0x1,-0x4c(%ebp)
 aef:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 af2:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
 af8:	7c dd                	jl     ad7 <vsprintf+0x874>
					} else {
						PAD(width_delta, pad_char);
						output_char(c);
					}
					
					break;
 afa:	e9 f2 00 00 00       	jmp    bf1 <vsprintf+0x98e>
					
					if(flags.left_justify){
						output_char(c);
						PAD(width_delta, pad_char);
					} else {
						PAD(width_delta, pad_char);
 aff:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
 b06:	eb 18                	jmp    b20 <vsprintf+0x8bd>
 b08:	8b 45 f4             	mov    -0xc(%ebp),%eax
 b0b:	8d 50 01             	lea    0x1(%eax),%edx
 b0e:	89 55 f4             	mov    %edx,-0xc(%ebp)
 b11:	8b 55 08             	mov    0x8(%ebp),%edx
 b14:	01 c2                	add    %eax,%edx
 b16:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 b1a:	88 02                	mov    %al,(%edx)
 b1c:	83 45 b0 01          	addl   $0x1,-0x50(%ebp)
 b20:	8b 45 b0             	mov    -0x50(%ebp),%eax
 b23:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
 b29:	7c dd                	jl     b08 <vsprintf+0x8a5>
						output_char(c);
 b2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 b2e:	8d 50 01             	lea    0x1(%eax),%edx
 b31:	89 55 f4             	mov    %edx,-0xc(%ebp)
 b34:	8b 55 08             	mov    0x8(%ebp),%edx
 b37:	01 c2                	add    %eax,%edx
 b39:	0f b6 45 83          	movzbl -0x7d(%ebp),%eax
 b3d:	88 02                	mov    %al,(%edx)
					}
					
					break;
 b3f:	e9 ad 00 00 00       	jmp    bf1 <vsprintf+0x98e>
				}

				case '%':{

					int width_delta = width - 1;
 b44:	8b 45 ec             	mov    -0x14(%ebp),%eax
 b47:	83 e8 01             	sub    $0x1,%eax
 b4a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
					
					if(flags.left_justify){
 b50:	0f b6 85 75 ff ff ff 	movzbl -0x8b(%ebp),%eax
 b57:	83 e0 01             	and    $0x1,%eax
 b5a:	84 c0                	test   %al,%al
 b5c:	74 3f                	je     b9d <vsprintf+0x93a>
						output_char('%');
 b5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 b61:	8d 50 01             	lea    0x1(%eax),%edx
 b64:	89 55 f4             	mov    %edx,-0xc(%ebp)
 b67:	8b 55 08             	mov    0x8(%ebp),%edx
 b6a:	01 d0                	add    %edx,%eax
 b6c:	c6 00 25             	movb   $0x25,(%eax)
						PAD(width_delta, pad_char);
 b6f:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
 b76:	eb 18                	jmp    b90 <vsprintf+0x92d>
 b78:	8b 45 f4             	mov    -0xc(%ebp),%eax
 b7b:	8d 50 01             	lea    0x1(%eax),%edx
 b7e:	89 55 f4             	mov    %edx,-0xc(%ebp)
 b81:	8b 55 08             	mov    0x8(%ebp),%edx
 b84:	01 c2                	add    %eax,%edx
 b86:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 b8a:	88 02                	mov    %al,(%edx)
 b8c:	83 45 ac 01          	addl   $0x1,-0x54(%ebp)
 b90:	8b 45 ac             	mov    -0x54(%ebp),%eax
 b93:	3b 85 78 ff ff ff    	cmp    -0x88(%ebp),%eax
 b99:	7c dd                	jl     b78 <vsprintf+0x915>
					} else {
						PAD(width_delta, pad_char);
						output_char('%');
					}
					
					break;
 b9b:	eb 3d                	jmp    bda <vsprintf+0x977>
					
					if(flags.left_justify){
						output_char('%');
						PAD(width_delta, pad_char);
					} else {
						PAD(width_delta, pad_char);
 b9d:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
 ba4:	eb 18                	jmp    bbe <vsprintf+0x95b>
 ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 ba9:	8d 50 01             	lea    0x1(%eax),%edx
 bac:	89 55 f4             	mov    %edx,-0xc(%ebp)
 baf:	8b 55 08             	mov    0x8(%ebp),%edx
 bb2:	01 c2                	add    %eax,%edx
 bb4:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
 bb8:	88 02                	mov    %al,(%edx)
 bba:	83 45 a8 01          	addl   $0x1,-0x58(%ebp)
 bbe:	8b 45 a8             	mov    -0x58(%ebp),%eax
 bc1:	3b 85 78 ff ff ff    	cmp    -0x88(%ebp),%eax
 bc7:	7c dd                	jl     ba6 <vsprintf+0x943>
						output_char('%');
 bc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 bcc:	8d 50 01             	lea    0x1(%eax),%edx
 bcf:	89 55 f4             	mov    %edx,-0xc(%ebp)
 bd2:	8b 55 08             	mov    0x8(%ebp),%edx
 bd5:	01 d0                	add    %edx,%eax
 bd7:	c6 00 25             	movb   $0x25,(%eax)
					}
					
					break;
 bda:	90                   	nop
 bdb:	eb 14                	jmp    bf1 <vsprintf+0x98e>

			}


		} else {
			output_char(c);
 bdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 be0:	8d 50 01             	lea    0x1(%eax),%edx
 be3:	89 55 f4             	mov    %edx,-0xc(%ebp)
 be6:	8b 55 08             	mov    0x8(%ebp),%edx
 be9:	01 c2                	add    %eax,%edx
 beb:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
 bef:	88 02                	mov    %al,(%edx)

	// Length of the format string
	const size_t format_length = strlen(format);

	// Loop until all characters in format buffer is parsed
	while(i < format_length){
 bf1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 bf4:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
 bf7:	0f 82 b4 f6 ff ff    	jb     2b1 <vsprintf+0x4e>

		} else {
			output_char(c);
		}
	}
 bfd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 c00:	c9                   	leave  
 c01:	c3                   	ret    
